/*! For license information please see main.js.LICENSE.txt */
(()=>{var e={268:(e,t,n)=>{"use strict";n.r(t),n.d(t,{default:()=>u});var a=n(81),s=n.n(a),i=n(645),r=n.n(i)()(s());r.push([e.id,"@import url(https://fonts.googleapis.com/css2?family=Source+Code+Pro:wght@400;500;600;700&display=swap);"]),r.push([e.id,"\nhtml,\nbody {\n  font-family: 'Source Code Pro', monospace;\n}\n",""]);const u=r},645:e=>{"use strict";e.exports=function(e){var t=[];return t.toString=function(){return this.map((function(t){var n="",a=void 0!==t[5];return t[4]&&(n+="@supports (".concat(t[4],") {")),t[2]&&(n+="@media ".concat(t[2]," {")),a&&(n+="@layer".concat(t[5].length>0?" ".concat(t[5]):""," {")),n+=e(t),a&&(n+="}"),t[2]&&(n+="}"),t[4]&&(n+="}"),n})).join("")},t.i=function(e,n,a,s,i){"string"==typeof e&&(e=[[null,e,void 0]]);var r={};if(a)for(var u=0;u<this.length;u++){var o=this[u][0];null!=o&&(r[o]=!0)}for(var d=0;d<e.length;d++){var p=[].concat(e[d]);a&&r[p[0]]||(void 0!==i&&(void 0===p[5]||(p[1]="@layer".concat(p[5].length>0?" ".concat(p[5]):""," {").concat(p[1],"}")),p[5]=i),n&&(p[2]?(p[1]="@media ".concat(p[2]," {").concat(p[1],"}"),p[2]=n):p[2]=n),s&&(p[4]?(p[1]="@supports (".concat(p[4],") {").concat(p[1],"}"),p[4]=s):p[4]="".concat(s)),t.push(p))}},t}},81:e=>{"use strict";e.exports=function(e){return e[1]}},387:(e,t,n)=>{var a=n(268);a.__esModule&&(a=a.default),"string"==typeof a&&(a=[[e.id,a,""]]),a.locals&&(e.exports=a.locals),(0,n(346).Z)("0b345cf4",a,!1,{})},346:(e,t,n)=>{"use strict";function a(e,t){for(var n=[],a={},s=0;s<t.length;s++){var i=t[s],r=i[0],u={id:e+":"+s,css:i[1],media:i[2],sourceMap:i[3]};a[r]?a[r].parts.push(u):n.push(a[r]={id:r,parts:[u]})}return n}n.d(t,{Z:()=>c});var s="undefined"!=typeof document;if("undefined"!=typeof DEBUG&&DEBUG&&!s)throw new Error("vue-style-loader cannot be used in a non-browser environment. Use { target: 'node' } in your Webpack config to indicate a server-rendering environment.");var i={},r=s&&(document.head||document.getElementsByTagName("head")[0]),u=null,o=0,d=!1,p=function(){},l=null,m="data-vue-ssr-id",y="undefined"!=typeof navigator&&/msie [6-9]\b/.test(navigator.userAgent.toLowerCase());function c(e,t,n,s){d=n,l=s||{};var r=a(e,t);return h(r),function(t){for(var n=[],s=0;s<r.length;s++){var u=r[s];(o=i[u.id]).refs--,n.push(o)}for(t?h(r=a(e,t)):r=[],s=0;s<n.length;s++){var o;if(0===(o=n[s]).refs){for(var d=0;d<o.parts.length;d++)o.parts[d]();delete i[o.id]}}}}function h(e){for(var t=0;t<e.length;t++){var n=e[t],a=i[n.id];if(a){a.refs++;for(var s=0;s<a.parts.length;s++)a.parts[s](n.parts[s]);for(;s<n.parts.length;s++)a.parts.push(b(n.parts[s]));a.parts.length>n.parts.length&&(a.parts.length=n.parts.length)}else{var r=[];for(s=0;s<n.parts.length;s++)r.push(b(n.parts[s]));i[n.id]={id:n.id,refs:1,parts:r}}}}function f(){var e=document.createElement("style");return e.type="text/css",r.appendChild(e),e}function b(e){var t,n,a=document.querySelector("style["+m+'~="'+e.id+'"]');if(a){if(d)return p;a.parentNode.removeChild(a)}if(y){var s=o++;a=u||(u=f()),t=g.bind(null,a,s,!1),n=g.bind(null,a,s,!0)}else a=f(),t=w.bind(null,a),n=function(){a.parentNode.removeChild(a)};return t(e),function(a){if(a){if(a.css===e.css&&a.media===e.media&&a.sourceMap===e.sourceMap)return;t(e=a)}else n()}}var v,T=(v=[],function(e,t){return v[e]=t,v.filter(Boolean).join("\n")});function g(e,t,n,a){var s=n?"":a.css;if(e.styleSheet)e.styleSheet.cssText=T(t,s);else{var i=document.createTextNode(s),r=e.childNodes;r[t]&&e.removeChild(r[t]),r.length?e.insertBefore(i,r[t]):e.appendChild(i)}}function w(e,t){var n=t.css,a=t.media,s=t.sourceMap;if(a&&e.setAttribute("media",a),l.ssrId&&e.setAttribute(m,t.id),s&&(n+="\n/*# sourceURL="+s.sources[0]+" */",n+="\n/*# sourceMappingURL=data:application/json;base64,"+btoa(unescape(encodeURIComponent(JSON.stringify(s))))+" */"),e.styleSheet)e.styleSheet.cssText=n;else{for(;e.firstChild;)e.removeChild(e.firstChild);e.appendChild(document.createTextNode(n))}}}},t={};function n(a){var s=t[a];if(void 0!==s)return s.exports;var i=t[a]={id:a,exports:{}};return e[a](i,i.exports,n),i.exports}n.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return n.d(t,{a:t}),t},n.d=(e,t)=>{for(var a in t)n.o(t,a)&&!n.o(e,a)&&Object.defineProperty(e,a,{enumerable:!0,get:t[a]})},n.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),n.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),n.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},(()=>{"use strict";var e=Object.freeze({});function t(e){return null==e}function a(e){return null!=e}function s(e){return!0===e}function i(e){return"string"==typeof e||"number"==typeof e||"symbol"==typeof e||"boolean"==typeof e}function r(e){return null!==e&&"object"==typeof e}var u=Object.prototype.toString;function o(e){return"[object Object]"===u.call(e)}function d(e){var t=parseFloat(String(e));return t>=0&&Math.floor(t)===t&&isFinite(e)}function p(e){return a(e)&&"function"==typeof e.then&&"function"==typeof e.catch}function l(e){return null==e?"":Array.isArray(e)||o(e)&&e.toString===u?JSON.stringify(e,null,2):String(e)}function m(e){var t=parseFloat(e);return isNaN(t)?e:t}function y(e,t){for(var n=Object.create(null),a=e.split(","),s=0;s<a.length;s++)n[a[s]]=!0;return t?function(e){return n[e.toLowerCase()]}:function(e){return n[e]}}var c=y("slot,component",!0),h=y("key,ref,slot,slot-scope,is");function f(e,t){if(e.length){var n=e.indexOf(t);if(n>-1)return e.splice(n,1)}}var b=Object.prototype.hasOwnProperty;function v(e,t){return b.call(e,t)}function T(e){var t=Object.create(null);return function(n){return t[n]||(t[n]=e(n))}}var g=/-(\w)/g,w=T((function(e){return e.replace(g,(function(e,t){return t?t.toUpperCase():""}))})),R=T((function(e){return e.charAt(0).toUpperCase()+e.slice(1)})),A=/\B([A-Z])/g,k=T((function(e){return e.replace(A,"-$1").toLowerCase()})),x=Function.prototype.bind?function(e,t){return e.bind(t)}:function(e,t){function n(n){var a=arguments.length;return a?a>1?e.apply(t,arguments):e.call(t,n):e.call(t)}return n._length=e.length,n};function _(e,t){t=t||0;for(var n=e.length-t,a=new Array(n);n--;)a[n]=e[n+t];return a}function S(e,t){for(var n in t)e[n]=t[n];return e}function M(e){for(var t={},n=0;n<e.length;n++)e[n]&&S(t,e[n]);return t}function O(e,t,n){}var I=function(e,t,n){return!1},C=function(e){return e};function U(e,t){if(e===t)return!0;var n=r(e),a=r(t);if(!n||!a)return!n&&!a&&String(e)===String(t);try{var s=Array.isArray(e),i=Array.isArray(t);if(s&&i)return e.length===t.length&&e.every((function(e,n){return U(e,t[n])}));if(e instanceof Date&&t instanceof Date)return e.getTime()===t.getTime();if(s||i)return!1;var u=Object.keys(e),o=Object.keys(t);return u.length===o.length&&u.every((function(n){return U(e[n],t[n])}))}catch(e){return!1}}function E(e,t){for(var n=0;n<e.length;n++)if(U(e[n],t))return n;return-1}function P(e){var t=!1;return function(){t||(t=!0,e.apply(this,arguments))}}var L="data-server-rendered",D=["component","directive","filter"],$=["beforeCreate","created","beforeMount","mounted","beforeUpdate","updated","beforeDestroy","destroyed","activated","deactivated","errorCaptured","serverPrefetch"],B={optionMergeStrategies:Object.create(null),silent:!1,productionTip:!1,devtools:!1,performance:!1,errorHandler:null,warnHandler:null,ignoredElements:[],keyCodes:Object.create(null),isReservedTag:I,isReservedAttr:I,isUnknownElement:I,getTagNamespace:O,parsePlatformTagName:C,mustUseProp:I,async:!0,_lifecycleHooks:$},N=/a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;function j(e){var t=(e+"").charCodeAt(0);return 36===t||95===t}function F(e,t,n,a){Object.defineProperty(e,t,{value:n,enumerable:!!a,writable:!0,configurable:!0})}var W,z=new RegExp("[^"+N.source+".$_\\d]"),G="__proto__"in{},q="undefined"!=typeof window,V="undefined"!=typeof WXEnvironment&&!!WXEnvironment.platform,J=V&&WXEnvironment.platform.toLowerCase(),H=q&&window.navigator.userAgent.toLowerCase(),Y=H&&/msie|trident/.test(H),K=H&&H.indexOf("msie 9.0")>0,Z=H&&H.indexOf("edge/")>0,X=(H&&H.indexOf("android"),H&&/iphone|ipad|ipod|ios/.test(H)||"ios"===J),Q=(H&&/chrome\/\d+/.test(H),H&&/phantomjs/.test(H),H&&H.match(/firefox\/(\d+)/)),ee={}.watch,te=!1;if(q)try{var ne={};Object.defineProperty(ne,"passive",{get:function(){te=!0}}),window.addEventListener("test-passive",null,ne)}catch(e){}var ae=function(){return void 0===W&&(W=!q&&!V&&void 0!==n.g&&n.g.process&&"server"===n.g.process.env.VUE_ENV),W},se=q&&window.__VUE_DEVTOOLS_GLOBAL_HOOK__;function ie(e){return"function"==typeof e&&/native code/.test(e.toString())}var re,ue="undefined"!=typeof Symbol&&ie(Symbol)&&"undefined"!=typeof Reflect&&ie(Reflect.ownKeys);re="undefined"!=typeof Set&&ie(Set)?Set:function(){function e(){this.set=Object.create(null)}return e.prototype.has=function(e){return!0===this.set[e]},e.prototype.add=function(e){this.set[e]=!0},e.prototype.clear=function(){this.set=Object.create(null)},e}();var oe=O,de=0,pe=function(){this.id=de++,this.subs=[]};pe.prototype.addSub=function(e){this.subs.push(e)},pe.prototype.removeSub=function(e){f(this.subs,e)},pe.prototype.depend=function(){pe.target&&pe.target.addDep(this)},pe.prototype.notify=function(){for(var e=this.subs.slice(),t=0,n=e.length;t<n;t++)e[t].update()},pe.target=null;var le=[];function me(e){le.push(e),pe.target=e}function ye(){le.pop(),pe.target=le[le.length-1]}var ce=function(e,t,n,a,s,i,r,u){this.tag=e,this.data=t,this.children=n,this.text=a,this.elm=s,this.ns=void 0,this.context=i,this.fnContext=void 0,this.fnOptions=void 0,this.fnScopeId=void 0,this.key=t&&t.key,this.componentOptions=r,this.componentInstance=void 0,this.parent=void 0,this.raw=!1,this.isStatic=!1,this.isRootInsert=!0,this.isComment=!1,this.isCloned=!1,this.isOnce=!1,this.asyncFactory=u,this.asyncMeta=void 0,this.isAsyncPlaceholder=!1},he={child:{configurable:!0}};he.child.get=function(){return this.componentInstance},Object.defineProperties(ce.prototype,he);var fe=function(e){void 0===e&&(e="");var t=new ce;return t.text=e,t.isComment=!0,t};function be(e){return new ce(void 0,void 0,void 0,String(e))}function ve(e){var t=new ce(e.tag,e.data,e.children&&e.children.slice(),e.text,e.elm,e.context,e.componentOptions,e.asyncFactory);return t.ns=e.ns,t.isStatic=e.isStatic,t.key=e.key,t.isComment=e.isComment,t.fnContext=e.fnContext,t.fnOptions=e.fnOptions,t.fnScopeId=e.fnScopeId,t.asyncMeta=e.asyncMeta,t.isCloned=!0,t}var Te=Array.prototype,ge=Object.create(Te);["push","pop","shift","unshift","splice","sort","reverse"].forEach((function(e){var t=Te[e];F(ge,e,(function(){for(var n=[],a=arguments.length;a--;)n[a]=arguments[a];var s,i=t.apply(this,n),r=this.__ob__;switch(e){case"push":case"unshift":s=n;break;case"splice":s=n.slice(2)}return s&&r.observeArray(s),r.dep.notify(),i}))}));var we=Object.getOwnPropertyNames(ge),Re=!0;function Ae(e){Re=e}var ke=function(e){this.value=e,this.dep=new pe,this.vmCount=0,F(e,"__ob__",this),Array.isArray(e)?(G?function(e,t){e.__proto__=t}(e,ge):function(e,t,n){for(var a=0,s=n.length;a<s;a++){var i=n[a];F(e,i,t[i])}}(e,ge,we),this.observeArray(e)):this.walk(e)};function xe(e,t){var n;if(r(e)&&!(e instanceof ce))return v(e,"__ob__")&&e.__ob__ instanceof ke?n=e.__ob__:Re&&!ae()&&(Array.isArray(e)||o(e))&&Object.isExtensible(e)&&!e._isVue&&(n=new ke(e)),t&&n&&n.vmCount++,n}function _e(e,t,n,a,s){var i=new pe,r=Object.getOwnPropertyDescriptor(e,t);if(!r||!1!==r.configurable){var u=r&&r.get,o=r&&r.set;u&&!o||2!==arguments.length||(n=e[t]);var d=!s&&xe(n);Object.defineProperty(e,t,{enumerable:!0,configurable:!0,get:function(){var t=u?u.call(e):n;return pe.target&&(i.depend(),d&&(d.dep.depend(),Array.isArray(t)&&Oe(t))),t},set:function(t){var a=u?u.call(e):n;t===a||t!=t&&a!=a||u&&!o||(o?o.call(e,t):n=t,d=!s&&xe(t),i.notify())}})}}function Se(e,t,n){if(Array.isArray(e)&&d(t))return e.length=Math.max(e.length,t),e.splice(t,1,n),n;if(t in e&&!(t in Object.prototype))return e[t]=n,n;var a=e.__ob__;return e._isVue||a&&a.vmCount?n:a?(_e(a.value,t,n),a.dep.notify(),n):(e[t]=n,n)}function Me(e,t){if(Array.isArray(e)&&d(t))e.splice(t,1);else{var n=e.__ob__;e._isVue||n&&n.vmCount||v(e,t)&&(delete e[t],n&&n.dep.notify())}}function Oe(e){for(var t=void 0,n=0,a=e.length;n<a;n++)(t=e[n])&&t.__ob__&&t.__ob__.dep.depend(),Array.isArray(t)&&Oe(t)}ke.prototype.walk=function(e){for(var t=Object.keys(e),n=0;n<t.length;n++)_e(e,t[n])},ke.prototype.observeArray=function(e){for(var t=0,n=e.length;t<n;t++)xe(e[t])};var Ie=B.optionMergeStrategies;function Ce(e,t){if(!t)return e;for(var n,a,s,i=ue?Reflect.ownKeys(t):Object.keys(t),r=0;r<i.length;r++)"__ob__"!==(n=i[r])&&(a=e[n],s=t[n],v(e,n)?a!==s&&o(a)&&o(s)&&Ce(a,s):Se(e,n,s));return e}function Ue(e,t,n){return n?function(){var a="function"==typeof t?t.call(n,n):t,s="function"==typeof e?e.call(n,n):e;return a?Ce(a,s):s}:t?e?function(){return Ce("function"==typeof t?t.call(this,this):t,"function"==typeof e?e.call(this,this):e)}:t:e}function Ee(e,t){var n=t?e?e.concat(t):Array.isArray(t)?t:[t]:e;return n?function(e){for(var t=[],n=0;n<e.length;n++)-1===t.indexOf(e[n])&&t.push(e[n]);return t}(n):n}function Pe(e,t,n,a){var s=Object.create(e||null);return t?S(s,t):s}Ie.data=function(e,t,n){return n?Ue(e,t,n):t&&"function"!=typeof t?e:Ue(e,t)},$.forEach((function(e){Ie[e]=Ee})),D.forEach((function(e){Ie[e+"s"]=Pe})),Ie.watch=function(e,t,n,a){if(e===ee&&(e=void 0),t===ee&&(t=void 0),!t)return Object.create(e||null);if(!e)return t;var s={};for(var i in S(s,e),t){var r=s[i],u=t[i];r&&!Array.isArray(r)&&(r=[r]),s[i]=r?r.concat(u):Array.isArray(u)?u:[u]}return s},Ie.props=Ie.methods=Ie.inject=Ie.computed=function(e,t,n,a){if(!e)return t;var s=Object.create(null);return S(s,e),t&&S(s,t),s},Ie.provide=Ue;var Le=function(e,t){return void 0===t?e:t};function De(e,t,n){if("function"==typeof t&&(t=t.options),function(e,t){var n=e.props;if(n){var a,s,i={};if(Array.isArray(n))for(a=n.length;a--;)"string"==typeof(s=n[a])&&(i[w(s)]={type:null});else if(o(n))for(var r in n)s=n[r],i[w(r)]=o(s)?s:{type:s};e.props=i}}(t),function(e,t){var n=e.inject;if(n){var a=e.inject={};if(Array.isArray(n))for(var s=0;s<n.length;s++)a[n[s]]={from:n[s]};else if(o(n))for(var i in n){var r=n[i];a[i]=o(r)?S({from:i},r):{from:r}}}}(t),function(e){var t=e.directives;if(t)for(var n in t){var a=t[n];"function"==typeof a&&(t[n]={bind:a,update:a})}}(t),!t._base&&(t.extends&&(e=De(e,t.extends,n)),t.mixins))for(var a=0,s=t.mixins.length;a<s;a++)e=De(e,t.mixins[a],n);var i,r={};for(i in e)u(i);for(i in t)v(e,i)||u(i);function u(a){var s=Ie[a]||Le;r[a]=s(e[a],t[a],n,a)}return r}function $e(e,t,n,a){if("string"==typeof n){var s=e[t];if(v(s,n))return s[n];var i=w(n);if(v(s,i))return s[i];var r=R(i);return v(s,r)?s[r]:s[n]||s[i]||s[r]}}function Be(e,t,n,a){var s=t[e],i=!v(n,e),r=n[e],u=We(Boolean,s.type);if(u>-1)if(i&&!v(s,"default"))r=!1;else if(""===r||r===k(e)){var o=We(String,s.type);(o<0||u<o)&&(r=!0)}if(void 0===r){r=function(e,t,n){if(v(t,"default")){var a=t.default;return e&&e.$options.propsData&&void 0===e.$options.propsData[n]&&void 0!==e._props[n]?e._props[n]:"function"==typeof a&&"Function"!==je(t.type)?a.call(e):a}}(a,s,e);var d=Re;Ae(!0),xe(r),Ae(d)}return r}var Ne=/^\s*function (\w+)/;function je(e){var t=e&&e.toString().match(Ne);return t?t[1]:""}function Fe(e,t){return je(e)===je(t)}function We(e,t){if(!Array.isArray(t))return Fe(t,e)?0:-1;for(var n=0,a=t.length;n<a;n++)if(Fe(t[n],e))return n;return-1}function ze(e,t,n){me();try{if(t)for(var a=t;a=a.$parent;){var s=a.$options.errorCaptured;if(s)for(var i=0;i<s.length;i++)try{if(!1===s[i].call(a,e,t,n))return}catch(e){qe(e,a,"errorCaptured hook")}}qe(e,t,n)}finally{ye()}}function Ge(e,t,n,a,s){var i;try{(i=n?e.apply(t,n):e.call(t))&&!i._isVue&&p(i)&&!i._handled&&(i.catch((function(e){return ze(e,a,s+" (Promise/async)")})),i._handled=!0)}catch(e){ze(e,a,s)}return i}function qe(e,t,n){if(B.errorHandler)try{return B.errorHandler.call(null,e,t,n)}catch(t){t!==e&&Ve(t)}Ve(e)}function Ve(e,t,n){if(!q&&!V||"undefined"==typeof console)throw e;console.error(e)}var Je,He=!1,Ye=[],Ke=!1;function Ze(){Ke=!1;var e=Ye.slice(0);Ye.length=0;for(var t=0;t<e.length;t++)e[t]()}if("undefined"!=typeof Promise&&ie(Promise)){var Xe=Promise.resolve();Je=function(){Xe.then(Ze),X&&setTimeout(O)},He=!0}else if(Y||"undefined"==typeof MutationObserver||!ie(MutationObserver)&&"[object MutationObserverConstructor]"!==MutationObserver.toString())Je="undefined"!=typeof setImmediate&&ie(setImmediate)?function(){setImmediate(Ze)}:function(){setTimeout(Ze,0)};else{var Qe=1,et=new MutationObserver(Ze),tt=document.createTextNode(String(Qe));et.observe(tt,{characterData:!0}),Je=function(){Qe=(Qe+1)%2,tt.data=String(Qe)},He=!0}function nt(e,t){var n;if(Ye.push((function(){if(e)try{e.call(t)}catch(e){ze(e,t,"nextTick")}else n&&n(t)})),Ke||(Ke=!0,Je()),!e&&"undefined"!=typeof Promise)return new Promise((function(e){n=e}))}var at=new re;function st(e){it(e,at),at.clear()}function it(e,t){var n,a,s=Array.isArray(e);if(!(!s&&!r(e)||Object.isFrozen(e)||e instanceof ce)){if(e.__ob__){var i=e.__ob__.dep.id;if(t.has(i))return;t.add(i)}if(s)for(n=e.length;n--;)it(e[n],t);else for(n=(a=Object.keys(e)).length;n--;)it(e[a[n]],t)}}var rt=T((function(e){var t="&"===e.charAt(0),n="~"===(e=t?e.slice(1):e).charAt(0),a="!"===(e=n?e.slice(1):e).charAt(0);return{name:e=a?e.slice(1):e,once:n,capture:a,passive:t}}));function ut(e,t){function n(){var e=arguments,a=n.fns;if(!Array.isArray(a))return Ge(a,null,arguments,t,"v-on handler");for(var s=a.slice(),i=0;i<s.length;i++)Ge(s[i],null,e,t,"v-on handler")}return n.fns=e,n}function ot(e,n,a,i,r,u){var o,d,p,l;for(o in e)d=e[o],p=n[o],l=rt(o),t(d)||(t(p)?(t(d.fns)&&(d=e[o]=ut(d,u)),s(l.once)&&(d=e[o]=r(l.name,d,l.capture)),a(l.name,d,l.capture,l.passive,l.params)):d!==p&&(p.fns=d,e[o]=p));for(o in n)t(e[o])&&i((l=rt(o)).name,n[o],l.capture)}function dt(e,n,i){var r;e instanceof ce&&(e=e.data.hook||(e.data.hook={}));var u=e[n];function o(){i.apply(this,arguments),f(r.fns,o)}t(u)?r=ut([o]):a(u.fns)&&s(u.merged)?(r=u).fns.push(o):r=ut([u,o]),r.merged=!0,e[n]=r}function pt(e,t,n,s,i){if(a(t)){if(v(t,n))return e[n]=t[n],i||delete t[n],!0;if(v(t,s))return e[n]=t[s],i||delete t[s],!0}return!1}function lt(e){return i(e)?[be(e)]:Array.isArray(e)?yt(e):void 0}function mt(e){return a(e)&&a(e.text)&&!1===e.isComment}function yt(e,n){var r,u,o,d,p=[];for(r=0;r<e.length;r++)t(u=e[r])||"boolean"==typeof u||(d=p[o=p.length-1],Array.isArray(u)?u.length>0&&(mt((u=yt(u,(n||"")+"_"+r))[0])&&mt(d)&&(p[o]=be(d.text+u[0].text),u.shift()),p.push.apply(p,u)):i(u)?mt(d)?p[o]=be(d.text+u):""!==u&&p.push(be(u)):mt(u)&&mt(d)?p[o]=be(d.text+u.text):(s(e._isVList)&&a(u.tag)&&t(u.key)&&a(n)&&(u.key="__vlist"+n+"_"+r+"__"),p.push(u)));return p}function ct(e,t){if(e){for(var n=Object.create(null),a=ue?Reflect.ownKeys(e):Object.keys(e),s=0;s<a.length;s++){var i=a[s];if("__ob__"!==i){for(var r=e[i].from,u=t;u;){if(u._provided&&v(u._provided,r)){n[i]=u._provided[r];break}u=u.$parent}if(!u&&"default"in e[i]){var o=e[i].default;n[i]="function"==typeof o?o.call(t):o}}}return n}}function ht(e,t){if(!e||!e.length)return{};for(var n={},a=0,s=e.length;a<s;a++){var i=e[a],r=i.data;if(r&&r.attrs&&r.attrs.slot&&delete r.attrs.slot,i.context!==t&&i.fnContext!==t||!r||null==r.slot)(n.default||(n.default=[])).push(i);else{var u=r.slot,o=n[u]||(n[u]=[]);"template"===i.tag?o.push.apply(o,i.children||[]):o.push(i)}}for(var d in n)n[d].every(ft)&&delete n[d];return n}function ft(e){return e.isComment&&!e.asyncFactory||" "===e.text}function bt(e){return e.isComment&&e.asyncFactory}function vt(t,n,a){var s,i=Object.keys(n).length>0,r=t?!!t.$stable:!i,u=t&&t.$key;if(t){if(t._normalized)return t._normalized;if(r&&a&&a!==e&&u===a.$key&&!i&&!a.$hasNormal)return a;for(var o in s={},t)t[o]&&"$"!==o[0]&&(s[o]=Tt(n,o,t[o]))}else s={};for(var d in n)d in s||(s[d]=gt(n,d));return t&&Object.isExtensible(t)&&(t._normalized=s),F(s,"$stable",r),F(s,"$key",u),F(s,"$hasNormal",i),s}function Tt(e,t,n){var a=function(){var e=arguments.length?n.apply(null,arguments):n({}),t=(e=e&&"object"==typeof e&&!Array.isArray(e)?[e]:lt(e))&&e[0];return e&&(!t||1===e.length&&t.isComment&&!bt(t))?void 0:e};return n.proxy&&Object.defineProperty(e,t,{get:a,enumerable:!0,configurable:!0}),a}function gt(e,t){return function(){return e[t]}}function wt(e,t){var n,s,i,u,o;if(Array.isArray(e)||"string"==typeof e)for(n=new Array(e.length),s=0,i=e.length;s<i;s++)n[s]=t(e[s],s);else if("number"==typeof e)for(n=new Array(e),s=0;s<e;s++)n[s]=t(s+1,s);else if(r(e))if(ue&&e[Symbol.iterator]){n=[];for(var d=e[Symbol.iterator](),p=d.next();!p.done;)n.push(t(p.value,n.length)),p=d.next()}else for(u=Object.keys(e),n=new Array(u.length),s=0,i=u.length;s<i;s++)o=u[s],n[s]=t(e[o],o,s);return a(n)||(n=[]),n._isVList=!0,n}function Rt(e,t,n,a){var s,i=this.$scopedSlots[e];i?(n=n||{},a&&(n=S(S({},a),n)),s=i(n)||("function"==typeof t?t():t)):s=this.$slots[e]||("function"==typeof t?t():t);var r=n&&n.slot;return r?this.$createElement("template",{slot:r},s):s}function At(e){return $e(this.$options,"filters",e)||C}function kt(e,t){return Array.isArray(e)?-1===e.indexOf(t):e!==t}function xt(e,t,n,a,s){var i=B.keyCodes[t]||n;return s&&a&&!B.keyCodes[t]?kt(s,a):i?kt(i,e):a?k(a)!==t:void 0===e}function _t(e,t,n,a,s){if(n&&r(n)){var i;Array.isArray(n)&&(n=M(n));var u=function(r){if("class"===r||"style"===r||h(r))i=e;else{var u=e.attrs&&e.attrs.type;i=a||B.mustUseProp(t,u,r)?e.domProps||(e.domProps={}):e.attrs||(e.attrs={})}var o=w(r),d=k(r);o in i||d in i||(i[r]=n[r],s&&((e.on||(e.on={}))["update:"+r]=function(e){n[r]=e}))};for(var o in n)u(o)}return e}function St(e,t){var n=this._staticTrees||(this._staticTrees=[]),a=n[e];return a&&!t||Ot(a=n[e]=this.$options.staticRenderFns[e].call(this._renderProxy,null,this),"__static__"+e,!1),a}function Mt(e,t,n){return Ot(e,"__once__"+t+(n?"_"+n:""),!0),e}function Ot(e,t,n){if(Array.isArray(e))for(var a=0;a<e.length;a++)e[a]&&"string"!=typeof e[a]&&It(e[a],t+"_"+a,n);else It(e,t,n)}function It(e,t,n){e.isStatic=!0,e.key=t,e.isOnce=n}function Ct(e,t){if(t&&o(t)){var n=e.on=e.on?S({},e.on):{};for(var a in t){var s=n[a],i=t[a];n[a]=s?[].concat(s,i):i}}return e}function Ut(e,t,n,a){t=t||{$stable:!n};for(var s=0;s<e.length;s++){var i=e[s];Array.isArray(i)?Ut(i,t,n):i&&(i.proxy&&(i.fn.proxy=!0),t[i.key]=i.fn)}return a&&(t.$key=a),t}function Et(e,t){for(var n=0;n<t.length;n+=2){var a=t[n];"string"==typeof a&&a&&(e[t[n]]=t[n+1])}return e}function Pt(e,t){return"string"==typeof e?t+e:e}function Lt(e){e._o=Mt,e._n=m,e._s=l,e._l=wt,e._t=Rt,e._q=U,e._i=E,e._m=St,e._f=At,e._k=xt,e._b=_t,e._v=be,e._e=fe,e._u=Ut,e._g=Ct,e._d=Et,e._p=Pt}function Dt(t,n,a,i,r){var u,o=this,d=r.options;v(i,"_uid")?(u=Object.create(i))._original=i:(u=i,i=i._original);var p=s(d._compiled),l=!p;this.data=t,this.props=n,this.children=a,this.parent=i,this.listeners=t.on||e,this.injections=ct(d.inject,i),this.slots=function(){return o.$slots||vt(t.scopedSlots,o.$slots=ht(a,i)),o.$slots},Object.defineProperty(this,"scopedSlots",{enumerable:!0,get:function(){return vt(t.scopedSlots,this.slots())}}),p&&(this.$options=d,this.$slots=this.slots(),this.$scopedSlots=vt(t.scopedSlots,this.$slots)),d._scopeId?this._c=function(e,t,n,a){var s=zt(u,e,t,n,a,l);return s&&!Array.isArray(s)&&(s.fnScopeId=d._scopeId,s.fnContext=i),s}:this._c=function(e,t,n,a){return zt(u,e,t,n,a,l)}}function $t(e,t,n,a,s){var i=ve(e);return i.fnContext=n,i.fnOptions=a,t.slot&&((i.data||(i.data={})).slot=t.slot),i}function Bt(e,t){for(var n in t)e[w(n)]=t[n]}Lt(Dt.prototype);var Nt={init:function(e,t){if(e.componentInstance&&!e.componentInstance._isDestroyed&&e.data.keepAlive){var n=e;Nt.prepatch(n,n)}else(e.componentInstance=function(e,t){var n={_isComponent:!0,_parentVnode:e,parent:t},s=e.data.inlineTemplate;return a(s)&&(n.render=s.render,n.staticRenderFns=s.staticRenderFns),new e.componentOptions.Ctor(n)}(e,Qt)).$mount(t?e.elm:void 0,t)},prepatch:function(t,n){var a=n.componentOptions;!function(t,n,a,s,i){var r=s.data.scopedSlots,u=t.$scopedSlots,o=!!(r&&!r.$stable||u!==e&&!u.$stable||r&&t.$scopedSlots.$key!==r.$key||!r&&t.$scopedSlots.$key),d=!!(i||t.$options._renderChildren||o);if(t.$options._parentVnode=s,t.$vnode=s,t._vnode&&(t._vnode.parent=s),t.$options._renderChildren=i,t.$attrs=s.data.attrs||e,t.$listeners=a||e,n&&t.$options.props){Ae(!1);for(var p=t._props,l=t.$options._propKeys||[],m=0;m<l.length;m++){var y=l[m],c=t.$options.props;p[y]=Be(y,c,n,t)}Ae(!0),t.$options.propsData=n}a=a||e;var h=t.$options._parentListeners;t.$options._parentListeners=a,Xt(t,a,h),d&&(t.$slots=ht(i,s.context),t.$forceUpdate())}(n.componentInstance=t.componentInstance,a.propsData,a.listeners,n,a.children)},insert:function(e){var t,n=e.context,a=e.componentInstance;a._isMounted||(a._isMounted=!0,sn(a,"mounted")),e.data.keepAlive&&(n._isMounted?((t=a)._inactive=!1,un.push(t)):nn(a,!0))},destroy:function(e){var t=e.componentInstance;t._isDestroyed||(e.data.keepAlive?an(t,!0):t.$destroy())}},jt=Object.keys(Nt);function Ft(n,i,u,o,d){if(!t(n)){var l=u.$options._base;if(r(n)&&(n=l.extend(n)),"function"==typeof n){var m;if(t(n.cid)&&(n=function(e,n){if(s(e.error)&&a(e.errorComp))return e.errorComp;if(a(e.resolved))return e.resolved;var i=Vt;if(i&&a(e.owners)&&-1===e.owners.indexOf(i)&&e.owners.push(i),s(e.loading)&&a(e.loadingComp))return e.loadingComp;if(i&&!a(e.owners)){var u=e.owners=[i],o=!0,d=null,l=null;i.$on("hook:destroyed",(function(){return f(u,i)}));var m=function(e){for(var t=0,n=u.length;t<n;t++)u[t].$forceUpdate();e&&(u.length=0,null!==d&&(clearTimeout(d),d=null),null!==l&&(clearTimeout(l),l=null))},y=P((function(t){e.resolved=Jt(t,n),o?u.length=0:m(!0)})),c=P((function(t){a(e.errorComp)&&(e.error=!0,m(!0))})),h=e(y,c);return r(h)&&(p(h)?t(e.resolved)&&h.then(y,c):p(h.component)&&(h.component.then(y,c),a(h.error)&&(e.errorComp=Jt(h.error,n)),a(h.loading)&&(e.loadingComp=Jt(h.loading,n),0===h.delay?e.loading=!0:d=setTimeout((function(){d=null,t(e.resolved)&&t(e.error)&&(e.loading=!0,m(!1))}),h.delay||200)),a(h.timeout)&&(l=setTimeout((function(){l=null,t(e.resolved)&&c(null)}),h.timeout)))),o=!1,e.loading?e.loadingComp:e.resolved}}(m=n,l),void 0===n))return function(e,t,n,a,s){var i=fe();return i.asyncFactory=e,i.asyncMeta={data:t,context:n,children:a,tag:s},i}(m,i,u,o,d);i=i||{},_n(n),a(i.model)&&function(e,t){var n=e.model&&e.model.prop||"value",s=e.model&&e.model.event||"input";(t.attrs||(t.attrs={}))[n]=t.model.value;var i=t.on||(t.on={}),r=i[s],u=t.model.callback;a(r)?(Array.isArray(r)?-1===r.indexOf(u):r!==u)&&(i[s]=[u].concat(r)):i[s]=u}(n.options,i);var y=function(e,n,s){var i=n.options.props;if(!t(i)){var r={},u=e.attrs,o=e.props;if(a(u)||a(o))for(var d in i){var p=k(d);pt(r,o,d,p,!0)||pt(r,u,d,p,!1)}return r}}(i,n);if(s(n.options.functional))return function(t,n,s,i,r){var u=t.options,o={},d=u.props;if(a(d))for(var p in d)o[p]=Be(p,d,n||e);else a(s.attrs)&&Bt(o,s.attrs),a(s.props)&&Bt(o,s.props);var l=new Dt(s,o,r,i,t),m=u.render.call(null,l._c,l);if(m instanceof ce)return $t(m,s,l.parent,u);if(Array.isArray(m)){for(var y=lt(m)||[],c=new Array(y.length),h=0;h<y.length;h++)c[h]=$t(y[h],s,l.parent,u);return c}}(n,y,i,u,o);var c=i.on;if(i.on=i.nativeOn,s(n.options.abstract)){var h=i.slot;i={},h&&(i.slot=h)}!function(e){for(var t=e.hook||(e.hook={}),n=0;n<jt.length;n++){var a=jt[n],s=t[a],i=Nt[a];s===i||s&&s._merged||(t[a]=s?Wt(i,s):i)}}(i);var b=n.options.name||d;return new ce("vue-component-"+n.cid+(b?"-"+b:""),i,void 0,void 0,void 0,u,{Ctor:n,propsData:y,listeners:c,tag:d,children:o},m)}}}function Wt(e,t){var n=function(n,a){e(n,a),t(n,a)};return n._merged=!0,n}function zt(e,t,n,u,o,d){return(Array.isArray(n)||i(n))&&(o=u,u=n,n=void 0),s(d)&&(o=2),function(e,t,n,s,i){if(a(n)&&a(n.__ob__))return fe();if(a(n)&&a(n.is)&&(t=n.is),!t)return fe();var u,o,d;(Array.isArray(s)&&"function"==typeof s[0]&&((n=n||{}).scopedSlots={default:s[0]},s.length=0),2===i?s=lt(s):1===i&&(s=function(e){for(var t=0;t<e.length;t++)if(Array.isArray(e[t]))return Array.prototype.concat.apply([],e);return e}(s)),"string"==typeof t)?(o=e.$vnode&&e.$vnode.ns||B.getTagNamespace(t),u=B.isReservedTag(t)?new ce(B.parsePlatformTagName(t),n,s,void 0,void 0,e):n&&n.pre||!a(d=$e(e.$options,"components",t))?new ce(t,n,s,void 0,void 0,e):Ft(d,n,e,s,t)):u=Ft(t,n,e,s);return Array.isArray(u)?u:a(u)?(a(o)&&Gt(u,o),a(n)&&function(e){r(e.style)&&st(e.style),r(e.class)&&st(e.class)}(n),u):fe()}(e,t,n,u,o)}function Gt(e,n,i){if(e.ns=n,"foreignObject"===e.tag&&(n=void 0,i=!0),a(e.children))for(var r=0,u=e.children.length;r<u;r++){var o=e.children[r];a(o.tag)&&(t(o.ns)||s(i)&&"svg"!==o.tag)&&Gt(o,n,i)}}var qt,Vt=null;function Jt(e,t){return(e.__esModule||ue&&"Module"===e[Symbol.toStringTag])&&(e=e.default),r(e)?t.extend(e):e}function Ht(e){if(Array.isArray(e))for(var t=0;t<e.length;t++){var n=e[t];if(a(n)&&(a(n.componentOptions)||bt(n)))return n}}function Yt(e,t){qt.$on(e,t)}function Kt(e,t){qt.$off(e,t)}function Zt(e,t){var n=qt;return function a(){var s=t.apply(null,arguments);null!==s&&n.$off(e,a)}}function Xt(e,t,n){qt=e,ot(t,n||{},Yt,Kt,Zt,e),qt=void 0}var Qt=null;function en(e){var t=Qt;return Qt=e,function(){Qt=t}}function tn(e){for(;e&&(e=e.$parent);)if(e._inactive)return!0;return!1}function nn(e,t){if(t){if(e._directInactive=!1,tn(e))return}else if(e._directInactive)return;if(e._inactive||null===e._inactive){e._inactive=!1;for(var n=0;n<e.$children.length;n++)nn(e.$children[n]);sn(e,"activated")}}function an(e,t){if(!(t&&(e._directInactive=!0,tn(e))||e._inactive)){e._inactive=!0;for(var n=0;n<e.$children.length;n++)an(e.$children[n]);sn(e,"deactivated")}}function sn(e,t){me();var n=e.$options[t],a=t+" hook";if(n)for(var s=0,i=n.length;s<i;s++)Ge(n[s],e,null,e,a);e._hasHookEvent&&e.$emit("hook:"+t),ye()}var rn=[],un=[],on={},dn=!1,pn=!1,ln=0,mn=0,yn=Date.now;if(q&&!Y){var cn=window.performance;cn&&"function"==typeof cn.now&&yn()>document.createEvent("Event").timeStamp&&(yn=function(){return cn.now()})}function hn(){var e,t;for(mn=yn(),pn=!0,rn.sort((function(e,t){return e.id-t.id})),ln=0;ln<rn.length;ln++)(e=rn[ln]).before&&e.before(),t=e.id,on[t]=null,e.run();var n=un.slice(),a=rn.slice();ln=rn.length=un.length=0,on={},dn=pn=!1,function(e){for(var t=0;t<e.length;t++)e[t]._inactive=!0,nn(e[t],!0)}(n),function(e){for(var t=e.length;t--;){var n=e[t],a=n.vm;a._watcher===n&&a._isMounted&&!a._isDestroyed&&sn(a,"updated")}}(a),se&&B.devtools&&se.emit("flush")}var fn=0,bn=function(e,t,n,a,s){this.vm=e,s&&(e._watcher=this),e._watchers.push(this),a?(this.deep=!!a.deep,this.user=!!a.user,this.lazy=!!a.lazy,this.sync=!!a.sync,this.before=a.before):this.deep=this.user=this.lazy=this.sync=!1,this.cb=n,this.id=++fn,this.active=!0,this.dirty=this.lazy,this.deps=[],this.newDeps=[],this.depIds=new re,this.newDepIds=new re,this.expression="","function"==typeof t?this.getter=t:(this.getter=function(e){if(!z.test(e)){var t=e.split(".");return function(e){for(var n=0;n<t.length;n++){if(!e)return;e=e[t[n]]}return e}}}(t),this.getter||(this.getter=O)),this.value=this.lazy?void 0:this.get()};bn.prototype.get=function(){var e;me(this);var t=this.vm;try{e=this.getter.call(t,t)}catch(e){if(!this.user)throw e;ze(e,t,'getter for watcher "'+this.expression+'"')}finally{this.deep&&st(e),ye(),this.cleanupDeps()}return e},bn.prototype.addDep=function(e){var t=e.id;this.newDepIds.has(t)||(this.newDepIds.add(t),this.newDeps.push(e),this.depIds.has(t)||e.addSub(this))},bn.prototype.cleanupDeps=function(){for(var e=this.deps.length;e--;){var t=this.deps[e];this.newDepIds.has(t.id)||t.removeSub(this)}var n=this.depIds;this.depIds=this.newDepIds,this.newDepIds=n,this.newDepIds.clear(),n=this.deps,this.deps=this.newDeps,this.newDeps=n,this.newDeps.length=0},bn.prototype.update=function(){this.lazy?this.dirty=!0:this.sync?this.run():function(e){var t=e.id;if(null==on[t]){if(on[t]=!0,pn){for(var n=rn.length-1;n>ln&&rn[n].id>e.id;)n--;rn.splice(n+1,0,e)}else rn.push(e);dn||(dn=!0,nt(hn))}}(this)},bn.prototype.run=function(){if(this.active){var e=this.get();if(e!==this.value||r(e)||this.deep){var t=this.value;if(this.value=e,this.user){var n='callback for watcher "'+this.expression+'"';Ge(this.cb,this.vm,[e,t],this.vm,n)}else this.cb.call(this.vm,e,t)}}},bn.prototype.evaluate=function(){this.value=this.get(),this.dirty=!1},bn.prototype.depend=function(){for(var e=this.deps.length;e--;)this.deps[e].depend()},bn.prototype.teardown=function(){if(this.active){this.vm._isBeingDestroyed||f(this.vm._watchers,this);for(var e=this.deps.length;e--;)this.deps[e].removeSub(this);this.active=!1}};var vn={enumerable:!0,configurable:!0,get:O,set:O};function Tn(e,t,n){vn.get=function(){return this[t][n]},vn.set=function(e){this[t][n]=e},Object.defineProperty(e,n,vn)}var gn={lazy:!0};function wn(e,t,n){var a=!ae();"function"==typeof n?(vn.get=a?Rn(t):An(n),vn.set=O):(vn.get=n.get?a&&!1!==n.cache?Rn(t):An(n.get):O,vn.set=n.set||O),Object.defineProperty(e,t,vn)}function Rn(e){return function(){var t=this._computedWatchers&&this._computedWatchers[e];if(t)return t.dirty&&t.evaluate(),pe.target&&t.depend(),t.value}}function An(e){return function(){return e.call(this,this)}}function kn(e,t,n,a){return o(n)&&(a=n,n=n.handler),"string"==typeof n&&(n=e[n]),e.$watch(t,n,a)}var xn=0;function _n(e){var t=e.options;if(e.super){var n=_n(e.super);if(n!==e.superOptions){e.superOptions=n;var a=function(e){var t,n=e.options,a=e.sealedOptions;for(var s in n)n[s]!==a[s]&&(t||(t={}),t[s]=n[s]);return t}(e);a&&S(e.extendOptions,a),(t=e.options=De(n,e.extendOptions)).name&&(t.components[t.name]=e)}}return t}function Sn(e){this._init(e)}function Mn(e){return e&&(e.Ctor.options.name||e.tag)}function On(e,t){return Array.isArray(e)?e.indexOf(t)>-1:"string"==typeof e?e.split(",").indexOf(t)>-1:(n=e,!("[object RegExp]"!==u.call(n))&&e.test(t));var n}function In(e,t){var n=e.cache,a=e.keys,s=e._vnode;for(var i in n){var r=n[i];if(r){var u=r.name;u&&!t(u)&&Cn(n,i,a,s)}}}function Cn(e,t,n,a){var s=e[t];!s||a&&s.tag===a.tag||s.componentInstance.$destroy(),e[t]=null,f(n,t)}!function(t){t.prototype._init=function(t){var n=this;n._uid=xn++,n._isVue=!0,t&&t._isComponent?function(e,t){var n=e.$options=Object.create(e.constructor.options),a=t._parentVnode;n.parent=t.parent,n._parentVnode=a;var s=a.componentOptions;n.propsData=s.propsData,n._parentListeners=s.listeners,n._renderChildren=s.children,n._componentTag=s.tag,t.render&&(n.render=t.render,n.staticRenderFns=t.staticRenderFns)}(n,t):n.$options=De(_n(n.constructor),t||{},n),n._renderProxy=n,n._self=n,function(e){var t=e.$options,n=t.parent;if(n&&!t.abstract){for(;n.$options.abstract&&n.$parent;)n=n.$parent;n.$children.push(e)}e.$parent=n,e.$root=n?n.$root:e,e.$children=[],e.$refs={},e._watcher=null,e._inactive=null,e._directInactive=!1,e._isMounted=!1,e._isDestroyed=!1,e._isBeingDestroyed=!1}(n),function(e){e._events=Object.create(null),e._hasHookEvent=!1;var t=e.$options._parentListeners;t&&Xt(e,t)}(n),function(t){t._vnode=null,t._staticTrees=null;var n=t.$options,a=t.$vnode=n._parentVnode,s=a&&a.context;t.$slots=ht(n._renderChildren,s),t.$scopedSlots=e,t._c=function(e,n,a,s){return zt(t,e,n,a,s,!1)},t.$createElement=function(e,n,a,s){return zt(t,e,n,a,s,!0)};var i=a&&a.data;_e(t,"$attrs",i&&i.attrs||e,null,!0),_e(t,"$listeners",n._parentListeners||e,null,!0)}(n),sn(n,"beforeCreate"),function(e){var t=ct(e.$options.inject,e);t&&(Ae(!1),Object.keys(t).forEach((function(n){_e(e,n,t[n])})),Ae(!0))}(n),function(e){e._watchers=[];var t=e.$options;t.props&&function(e,t){var n=e.$options.propsData||{},a=e._props={},s=e.$options._propKeys=[];e.$parent&&Ae(!1);var i=function(i){s.push(i);var r=Be(i,t,n,e);_e(a,i,r),i in e||Tn(e,"_props",i)};for(var r in t)i(r);Ae(!0)}(e,t.props),t.methods&&function(e,t){for(var n in e.$options.props,t)e[n]="function"!=typeof t[n]?O:x(t[n],e)}(e,t.methods),t.data?function(e){var t=e.$options.data;o(t=e._data="function"==typeof t?function(e,t){me();try{return e.call(t,t)}catch(e){return ze(e,t,"data()"),{}}finally{ye()}}(t,e):t||{})||(t={});for(var n=Object.keys(t),a=e.$options.props,s=(e.$options.methods,n.length);s--;){var i=n[s];a&&v(a,i)||j(i)||Tn(e,"_data",i)}xe(t,!0)}(e):xe(e._data={},!0),t.computed&&function(e,t){var n=e._computedWatchers=Object.create(null),a=ae();for(var s in t){var i=t[s],r="function"==typeof i?i:i.get;a||(n[s]=new bn(e,r||O,O,gn)),s in e||wn(e,s,i)}}(e,t.computed),t.watch&&t.watch!==ee&&function(e,t){for(var n in t){var a=t[n];if(Array.isArray(a))for(var s=0;s<a.length;s++)kn(e,n,a[s]);else kn(e,n,a)}}(e,t.watch)}(n),function(e){var t=e.$options.provide;t&&(e._provided="function"==typeof t?t.call(e):t)}(n),sn(n,"created"),n.$options.el&&n.$mount(n.$options.el)}}(Sn),function(e){Object.defineProperty(e.prototype,"$data",{get:function(){return this._data}}),Object.defineProperty(e.prototype,"$props",{get:function(){return this._props}}),e.prototype.$set=Se,e.prototype.$delete=Me,e.prototype.$watch=function(e,t,n){var a=this;if(o(t))return kn(a,e,t,n);(n=n||{}).user=!0;var s=new bn(a,e,t,n);if(n.immediate){var i='callback for immediate watcher "'+s.expression+'"';me(),Ge(t,a,[s.value],a,i),ye()}return function(){s.teardown()}}}(Sn),function(e){var t=/^hook:/;e.prototype.$on=function(e,n){var a=this;if(Array.isArray(e))for(var s=0,i=e.length;s<i;s++)a.$on(e[s],n);else(a._events[e]||(a._events[e]=[])).push(n),t.test(e)&&(a._hasHookEvent=!0);return a},e.prototype.$once=function(e,t){var n=this;function a(){n.$off(e,a),t.apply(n,arguments)}return a.fn=t,n.$on(e,a),n},e.prototype.$off=function(e,t){var n=this;if(!arguments.length)return n._events=Object.create(null),n;if(Array.isArray(e)){for(var a=0,s=e.length;a<s;a++)n.$off(e[a],t);return n}var i,r=n._events[e];if(!r)return n;if(!t)return n._events[e]=null,n;for(var u=r.length;u--;)if((i=r[u])===t||i.fn===t){r.splice(u,1);break}return n},e.prototype.$emit=function(e){var t=this,n=t._events[e];if(n){n=n.length>1?_(n):n;for(var a=_(arguments,1),s='event handler for "'+e+'"',i=0,r=n.length;i<r;i++)Ge(n[i],t,a,t,s)}return t}}(Sn),function(e){e.prototype._update=function(e,t){var n=this,a=n.$el,s=n._vnode,i=en(n);n._vnode=e,n.$el=s?n.__patch__(s,e):n.__patch__(n.$el,e,t,!1),i(),a&&(a.__vue__=null),n.$el&&(n.$el.__vue__=n),n.$vnode&&n.$parent&&n.$vnode===n.$parent._vnode&&(n.$parent.$el=n.$el)},e.prototype.$forceUpdate=function(){this._watcher&&this._watcher.update()},e.prototype.$destroy=function(){var e=this;if(!e._isBeingDestroyed){sn(e,"beforeDestroy"),e._isBeingDestroyed=!0;var t=e.$parent;!t||t._isBeingDestroyed||e.$options.abstract||f(t.$children,e),e._watcher&&e._watcher.teardown();for(var n=e._watchers.length;n--;)e._watchers[n].teardown();e._data.__ob__&&e._data.__ob__.vmCount--,e._isDestroyed=!0,e.__patch__(e._vnode,null),sn(e,"destroyed"),e.$off(),e.$el&&(e.$el.__vue__=null),e.$vnode&&(e.$vnode.parent=null)}}}(Sn),function(e){Lt(e.prototype),e.prototype.$nextTick=function(e){return nt(e,this)},e.prototype._render=function(){var e,t=this,n=t.$options,a=n.render,s=n._parentVnode;s&&(t.$scopedSlots=vt(s.data.scopedSlots,t.$slots,t.$scopedSlots)),t.$vnode=s;try{Vt=t,e=a.call(t._renderProxy,t.$createElement)}catch(n){ze(n,t,"render"),e=t._vnode}finally{Vt=null}return Array.isArray(e)&&1===e.length&&(e=e[0]),e instanceof ce||(e=fe()),e.parent=s,e}}(Sn);var Un=[String,RegExp,Array],En={name:"keep-alive",abstract:!0,props:{include:Un,exclude:Un,max:[String,Number]},methods:{cacheVNode:function(){var e=this,t=e.cache,n=e.keys,a=e.vnodeToCache,s=e.keyToCache;if(a){var i=a.tag,r=a.componentInstance,u=a.componentOptions;t[s]={name:Mn(u),tag:i,componentInstance:r},n.push(s),this.max&&n.length>parseInt(this.max)&&Cn(t,n[0],n,this._vnode),this.vnodeToCache=null}}},created:function(){this.cache=Object.create(null),this.keys=[]},destroyed:function(){for(var e in this.cache)Cn(this.cache,e,this.keys)},mounted:function(){var e=this;this.cacheVNode(),this.$watch("include",(function(t){In(e,(function(e){return On(t,e)}))})),this.$watch("exclude",(function(t){In(e,(function(e){return!On(t,e)}))}))},updated:function(){this.cacheVNode()},render:function(){var e=this.$slots.default,t=Ht(e),n=t&&t.componentOptions;if(n){var a=Mn(n),s=this.include,i=this.exclude;if(s&&(!a||!On(s,a))||i&&a&&On(i,a))return t;var r=this.cache,u=this.keys,o=null==t.key?n.Ctor.cid+(n.tag?"::"+n.tag:""):t.key;r[o]?(t.componentInstance=r[o].componentInstance,f(u,o),u.push(o)):(this.vnodeToCache=t,this.keyToCache=o),t.data.keepAlive=!0}return t||e&&e[0]}},Pn={KeepAlive:En};!function(e){var t={get:function(){return B}};Object.defineProperty(e,"config",t),e.util={warn:oe,extend:S,mergeOptions:De,defineReactive:_e},e.set=Se,e.delete=Me,e.nextTick=nt,e.observable=function(e){return xe(e),e},e.options=Object.create(null),D.forEach((function(t){e.options[t+"s"]=Object.create(null)})),e.options._base=e,S(e.options.components,Pn),function(e){e.use=function(e){var t=this._installedPlugins||(this._installedPlugins=[]);if(t.indexOf(e)>-1)return this;var n=_(arguments,1);return n.unshift(this),"function"==typeof e.install?e.install.apply(e,n):"function"==typeof e&&e.apply(null,n),t.push(e),this}}(e),function(e){e.mixin=function(e){return this.options=De(this.options,e),this}}(e),function(e){e.cid=0;var t=1;e.extend=function(e){e=e||{};var n=this,a=n.cid,s=e._Ctor||(e._Ctor={});if(s[a])return s[a];var i=e.name||n.options.name,r=function(e){this._init(e)};return(r.prototype=Object.create(n.prototype)).constructor=r,r.cid=t++,r.options=De(n.options,e),r.super=n,r.options.props&&function(e){var t=e.options.props;for(var n in t)Tn(e.prototype,"_props",n)}(r),r.options.computed&&function(e){var t=e.options.computed;for(var n in t)wn(e.prototype,n,t[n])}(r),r.extend=n.extend,r.mixin=n.mixin,r.use=n.use,D.forEach((function(e){r[e]=n[e]})),i&&(r.options.components[i]=r),r.superOptions=n.options,r.extendOptions=e,r.sealedOptions=S({},r.options),s[a]=r,r}}(e),function(e){D.forEach((function(t){e[t]=function(e,n){return n?("component"===t&&o(n)&&(n.name=n.name||e,n=this.options._base.extend(n)),"directive"===t&&"function"==typeof n&&(n={bind:n,update:n}),this.options[t+"s"][e]=n,n):this.options[t+"s"][e]}}))}(e)}(Sn),Object.defineProperty(Sn.prototype,"$isServer",{get:ae}),Object.defineProperty(Sn.prototype,"$ssrContext",{get:function(){return this.$vnode&&this.$vnode.ssrContext}}),Object.defineProperty(Sn,"FunctionalRenderContext",{value:Dt}),Sn.version="2.6.14";var Ln=y("style,class"),Dn=y("input,textarea,option,select,progress"),$n=function(e,t,n){return"value"===n&&Dn(e)&&"button"!==t||"selected"===n&&"option"===e||"checked"===n&&"input"===e||"muted"===n&&"video"===e},Bn=y("contenteditable,draggable,spellcheck"),Nn=y("events,caret,typing,plaintext-only"),jn=y("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible"),Fn="http://www.w3.org/1999/xlink",Wn=function(e){return":"===e.charAt(5)&&"xlink"===e.slice(0,5)},zn=function(e){return Wn(e)?e.slice(6,e.length):""},Gn=function(e){return null==e||!1===e};function qn(e,t){return{staticClass:Vn(e.staticClass,t.staticClass),class:a(e.class)?[e.class,t.class]:t.class}}function Vn(e,t){return e?t?e+" "+t:e:t||""}function Jn(e){return Array.isArray(e)?function(e){for(var t,n="",s=0,i=e.length;s<i;s++)a(t=Jn(e[s]))&&""!==t&&(n&&(n+=" "),n+=t);return n}(e):r(e)?function(e){var t="";for(var n in e)e[n]&&(t&&(t+=" "),t+=n);return t}(e):"string"==typeof e?e:""}var Hn={svg:"http://www.w3.org/2000/svg",math:"http://www.w3.org/1998/Math/MathML"},Yn=y("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"),Kn=y("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view",!0),Zn=function(e){return Yn(e)||Kn(e)};function Xn(e){return Kn(e)?"svg":"math"===e?"math":void 0}var Qn=Object.create(null),ea=y("text,number,password,search,email,tel,url");function ta(e){return"string"==typeof e?document.querySelector(e)||document.createElement("div"):e}var na=Object.freeze({createElement:function(e,t){var n=document.createElement(e);return"select"!==e||t.data&&t.data.attrs&&void 0!==t.data.attrs.multiple&&n.setAttribute("multiple","multiple"),n},createElementNS:function(e,t){return document.createElementNS(Hn[e],t)},createTextNode:function(e){return document.createTextNode(e)},createComment:function(e){return document.createComment(e)},insertBefore:function(e,t,n){e.insertBefore(t,n)},removeChild:function(e,t){e.removeChild(t)},appendChild:function(e,t){e.appendChild(t)},parentNode:function(e){return e.parentNode},nextSibling:function(e){return e.nextSibling},tagName:function(e){return e.tagName},setTextContent:function(e,t){e.textContent=t},setStyleScope:function(e,t){e.setAttribute(t,"")}}),aa={create:function(e,t){sa(t)},update:function(e,t){e.data.ref!==t.data.ref&&(sa(e,!0),sa(t))},destroy:function(e){sa(e,!0)}};function sa(e,t){var n=e.data.ref;if(a(n)){var s=e.context,i=e.componentInstance||e.elm,r=s.$refs;t?Array.isArray(r[n])?f(r[n],i):r[n]===i&&(r[n]=void 0):e.data.refInFor?Array.isArray(r[n])?r[n].indexOf(i)<0&&r[n].push(i):r[n]=[i]:r[n]=i}}var ia=new ce("",{},[]),ra=["create","activate","update","remove","destroy"];function ua(e,n){return e.key===n.key&&e.asyncFactory===n.asyncFactory&&(e.tag===n.tag&&e.isComment===n.isComment&&a(e.data)===a(n.data)&&function(e,t){if("input"!==e.tag)return!0;var n,s=a(n=e.data)&&a(n=n.attrs)&&n.type,i=a(n=t.data)&&a(n=n.attrs)&&n.type;return s===i||ea(s)&&ea(i)}(e,n)||s(e.isAsyncPlaceholder)&&t(n.asyncFactory.error))}function oa(e,t,n){var s,i,r={};for(s=t;s<=n;++s)a(i=e[s].key)&&(r[i]=s);return r}var da={create:pa,update:pa,destroy:function(e){pa(e,ia)}};function pa(e,t){(e.data.directives||t.data.directives)&&function(e,t){var n,a,s,i=e===ia,r=t===ia,u=ma(e.data.directives,e.context),o=ma(t.data.directives,t.context),d=[],p=[];for(n in o)a=u[n],s=o[n],a?(s.oldValue=a.value,s.oldArg=a.arg,ca(s,"update",t,e),s.def&&s.def.componentUpdated&&p.push(s)):(ca(s,"bind",t,e),s.def&&s.def.inserted&&d.push(s));if(d.length){var l=function(){for(var n=0;n<d.length;n++)ca(d[n],"inserted",t,e)};i?dt(t,"insert",l):l()}if(p.length&&dt(t,"postpatch",(function(){for(var n=0;n<p.length;n++)ca(p[n],"componentUpdated",t,e)})),!i)for(n in u)o[n]||ca(u[n],"unbind",e,e,r)}(e,t)}var la=Object.create(null);function ma(e,t){var n,a,s=Object.create(null);if(!e)return s;for(n=0;n<e.length;n++)(a=e[n]).modifiers||(a.modifiers=la),s[ya(a)]=a,a.def=$e(t.$options,"directives",a.name);return s}function ya(e){return e.rawName||e.name+"."+Object.keys(e.modifiers||{}).join(".")}function ca(e,t,n,a,s){var i=e.def&&e.def[t];if(i)try{i(n.elm,e,n,a,s)}catch(a){ze(a,n.context,"directive "+e.name+" "+t+" hook")}}var ha=[aa,da];function fa(e,n){var s=n.componentOptions;if(!(a(s)&&!1===s.Ctor.options.inheritAttrs||t(e.data.attrs)&&t(n.data.attrs))){var i,r,u=n.elm,o=e.data.attrs||{},d=n.data.attrs||{};for(i in a(d.__ob__)&&(d=n.data.attrs=S({},d)),d)r=d[i],o[i]!==r&&ba(u,i,r,n.data.pre);for(i in(Y||Z)&&d.value!==o.value&&ba(u,"value",d.value),o)t(d[i])&&(Wn(i)?u.removeAttributeNS(Fn,zn(i)):Bn(i)||u.removeAttribute(i))}}function ba(e,t,n,a){a||e.tagName.indexOf("-")>-1?va(e,t,n):jn(t)?Gn(n)?e.removeAttribute(t):(n="allowfullscreen"===t&&"EMBED"===e.tagName?"true":t,e.setAttribute(t,n)):Bn(t)?e.setAttribute(t,function(e,t){return Gn(t)||"false"===t?"false":"contenteditable"===e&&Nn(t)?t:"true"}(t,n)):Wn(t)?Gn(n)?e.removeAttributeNS(Fn,zn(t)):e.setAttributeNS(Fn,t,n):va(e,t,n)}function va(e,t,n){if(Gn(n))e.removeAttribute(t);else{if(Y&&!K&&"TEXTAREA"===e.tagName&&"placeholder"===t&&""!==n&&!e.__ieph){var a=function(t){t.stopImmediatePropagation(),e.removeEventListener("input",a)};e.addEventListener("input",a),e.__ieph=!0}e.setAttribute(t,n)}}var Ta={create:fa,update:fa};function ga(e,n){var s=n.elm,i=n.data,r=e.data;if(!(t(i.staticClass)&&t(i.class)&&(t(r)||t(r.staticClass)&&t(r.class)))){var u=function(e){for(var t=e.data,n=e,s=e;a(s.componentInstance);)(s=s.componentInstance._vnode)&&s.data&&(t=qn(s.data,t));for(;a(n=n.parent);)n&&n.data&&(t=qn(t,n.data));return i=t.staticClass,r=t.class,a(i)||a(r)?Vn(i,Jn(r)):"";var i,r}(n),o=s._transitionClasses;a(o)&&(u=Vn(u,Jn(o))),u!==s._prevClass&&(s.setAttribute("class",u),s._prevClass=u)}}var wa,Ra,Aa,ka,xa,_a,Sa={create:ga,update:ga},Ma=/[\w).+\-_$\]]/;function Oa(e){var t,n,a,s,i,r=!1,u=!1,o=!1,d=!1,p=0,l=0,m=0,y=0;for(a=0;a<e.length;a++)if(n=t,t=e.charCodeAt(a),r)39===t&&92!==n&&(r=!1);else if(u)34===t&&92!==n&&(u=!1);else if(o)96===t&&92!==n&&(o=!1);else if(d)47===t&&92!==n&&(d=!1);else if(124!==t||124===e.charCodeAt(a+1)||124===e.charCodeAt(a-1)||p||l||m){switch(t){case 34:u=!0;break;case 39:r=!0;break;case 96:o=!0;break;case 40:m++;break;case 41:m--;break;case 91:l++;break;case 93:l--;break;case 123:p++;break;case 125:p--}if(47===t){for(var c=a-1,h=void 0;c>=0&&" "===(h=e.charAt(c));c--);h&&Ma.test(h)||(d=!0)}}else void 0===s?(y=a+1,s=e.slice(0,a).trim()):f();function f(){(i||(i=[])).push(e.slice(y,a).trim()),y=a+1}if(void 0===s?s=e.slice(0,a).trim():0!==y&&f(),i)for(a=0;a<i.length;a++)s=Ia(s,i[a]);return s}function Ia(e,t){var n=t.indexOf("(");if(n<0)return'_f("'+t+'")('+e+")";var a=t.slice(0,n),s=t.slice(n+1);return'_f("'+a+'")('+e+(")"!==s?","+s:s)}function Ca(e,t){console.error("[Vue compiler]: "+e)}function Ua(e,t){return e?e.map((function(e){return e[t]})).filter((function(e){return e})):[]}function Ea(e,t,n,a,s){(e.props||(e.props=[])).push(Wa({name:t,value:n,dynamic:s},a)),e.plain=!1}function Pa(e,t,n,a,s){(s?e.dynamicAttrs||(e.dynamicAttrs=[]):e.attrs||(e.attrs=[])).push(Wa({name:t,value:n,dynamic:s},a)),e.plain=!1}function La(e,t,n,a){e.attrsMap[t]=n,e.attrsList.push(Wa({name:t,value:n},a))}function Da(e,t,n,a,s,i,r,u){(e.directives||(e.directives=[])).push(Wa({name:t,rawName:n,value:a,arg:s,isDynamicArg:i,modifiers:r},u)),e.plain=!1}function $a(e,t,n){return n?"_p("+t+',"'+e+'")':e+t}function Ba(t,n,a,s,i,r,u,o){var d;(s=s||e).right?o?n="("+n+")==='click'?'contextmenu':("+n+")":"click"===n&&(n="contextmenu",delete s.right):s.middle&&(o?n="("+n+")==='click'?'mouseup':("+n+")":"click"===n&&(n="mouseup")),s.capture&&(delete s.capture,n=$a("!",n,o)),s.once&&(delete s.once,n=$a("~",n,o)),s.passive&&(delete s.passive,n=$a("&",n,o)),s.native?(delete s.native,d=t.nativeEvents||(t.nativeEvents={})):d=t.events||(t.events={});var p=Wa({value:a.trim(),dynamic:o},u);s!==e&&(p.modifiers=s);var l=d[n];Array.isArray(l)?i?l.unshift(p):l.push(p):d[n]=l?i?[p,l]:[l,p]:p,t.plain=!1}function Na(e,t,n){var a=ja(e,":"+t)||ja(e,"v-bind:"+t);if(null!=a)return Oa(a);if(!1!==n){var s=ja(e,t);if(null!=s)return JSON.stringify(s)}}function ja(e,t,n){var a;if(null!=(a=e.attrsMap[t]))for(var s=e.attrsList,i=0,r=s.length;i<r;i++)if(s[i].name===t){s.splice(i,1);break}return n&&delete e.attrsMap[t],a}function Fa(e,t){for(var n=e.attrsList,a=0,s=n.length;a<s;a++){var i=n[a];if(t.test(i.name))return n.splice(a,1),i}}function Wa(e,t){return t&&(null!=t.start&&(e.start=t.start),null!=t.end&&(e.end=t.end)),e}function za(e,t,n){var a=n||{},s=a.number,i="$$v";a.trim&&(i="(typeof $$v === 'string'? $$v.trim(): $$v)"),s&&(i="_n("+i+")");var r=Ga(t,i);e.model={value:"("+t+")",expression:JSON.stringify(t),callback:"function ($$v) {"+r+"}"}}function Ga(e,t){var n=function(e){if(e=e.trim(),wa=e.length,e.indexOf("[")<0||e.lastIndexOf("]")<wa-1)return(ka=e.lastIndexOf("."))>-1?{exp:e.slice(0,ka),key:'"'+e.slice(ka+1)+'"'}:{exp:e,key:null};for(Ra=e,ka=xa=_a=0;!Va();)Ja(Aa=qa())?Ya(Aa):91===Aa&&Ha(Aa);return{exp:e.slice(0,xa),key:e.slice(xa+1,_a)}}(e);return null===n.key?e+"="+t:"$set("+n.exp+", "+n.key+", "+t+")"}function qa(){return Ra.charCodeAt(++ka)}function Va(){return ka>=wa}function Ja(e){return 34===e||39===e}function Ha(e){var t=1;for(xa=ka;!Va();)if(Ja(e=qa()))Ya(e);else if(91===e&&t++,93===e&&t--,0===t){_a=ka;break}}function Ya(e){for(var t=e;!Va()&&(e=qa())!==t;);}var Ka;function Za(e,t,n){var a=Ka;return function s(){var i=t.apply(null,arguments);null!==i&&es(e,s,n,a)}}var Xa=He&&!(Q&&Number(Q[1])<=53);function Qa(e,t,n,a){if(Xa){var s=mn,i=t;t=i._wrapper=function(e){if(e.target===e.currentTarget||e.timeStamp>=s||e.timeStamp<=0||e.target.ownerDocument!==document)return i.apply(this,arguments)}}Ka.addEventListener(e,t,te?{capture:n,passive:a}:n)}function es(e,t,n,a){(a||Ka).removeEventListener(e,t._wrapper||t,n)}function ts(e,n){if(!t(e.data.on)||!t(n.data.on)){var s=n.data.on||{},i=e.data.on||{};Ka=n.elm,function(e){if(a(e.__r)){var t=Y?"change":"input";e[t]=[].concat(e.__r,e[t]||[]),delete e.__r}a(e.__c)&&(e.change=[].concat(e.__c,e.change||[]),delete e.__c)}(s),ot(s,i,Qa,es,Za,n.context),Ka=void 0}}var ns,as={create:ts,update:ts};function ss(e,n){if(!t(e.data.domProps)||!t(n.data.domProps)){var s,i,r=n.elm,u=e.data.domProps||{},o=n.data.domProps||{};for(s in a(o.__ob__)&&(o=n.data.domProps=S({},o)),u)s in o||(r[s]="");for(s in o){if(i=o[s],"textContent"===s||"innerHTML"===s){if(n.children&&(n.children.length=0),i===u[s])continue;1===r.childNodes.length&&r.removeChild(r.childNodes[0])}if("value"===s&&"PROGRESS"!==r.tagName){r._value=i;var d=t(i)?"":String(i);is(r,d)&&(r.value=d)}else if("innerHTML"===s&&Kn(r.tagName)&&t(r.innerHTML)){(ns=ns||document.createElement("div")).innerHTML="<svg>"+i+"</svg>";for(var p=ns.firstChild;r.firstChild;)r.removeChild(r.firstChild);for(;p.firstChild;)r.appendChild(p.firstChild)}else if(i!==u[s])try{r[s]=i}catch(e){}}}}function is(e,t){return!e.composing&&("OPTION"===e.tagName||function(e,t){var n=!0;try{n=document.activeElement!==e}catch(e){}return n&&e.value!==t}(e,t)||function(e,t){var n=e.value,s=e._vModifiers;if(a(s)){if(s.number)return m(n)!==m(t);if(s.trim)return n.trim()!==t.trim()}return n!==t}(e,t))}var rs={create:ss,update:ss},us=T((function(e){var t={},n=/:(.+)/;return e.split(/;(?![^(]*\))/g).forEach((function(e){if(e){var a=e.split(n);a.length>1&&(t[a[0].trim()]=a[1].trim())}})),t}));function os(e){var t=ds(e.style);return e.staticStyle?S(e.staticStyle,t):t}function ds(e){return Array.isArray(e)?M(e):"string"==typeof e?us(e):e}var ps,ls=/^--/,ms=/\s*!important$/,ys=function(e,t,n){if(ls.test(t))e.style.setProperty(t,n);else if(ms.test(n))e.style.setProperty(k(t),n.replace(ms,""),"important");else{var a=hs(t);if(Array.isArray(n))for(var s=0,i=n.length;s<i;s++)e.style[a]=n[s];else e.style[a]=n}},cs=["Webkit","Moz","ms"],hs=T((function(e){if(ps=ps||document.createElement("div").style,"filter"!==(e=w(e))&&e in ps)return e;for(var t=e.charAt(0).toUpperCase()+e.slice(1),n=0;n<cs.length;n++){var a=cs[n]+t;if(a in ps)return a}}));function fs(e,n){var s=n.data,i=e.data;if(!(t(s.staticStyle)&&t(s.style)&&t(i.staticStyle)&&t(i.style))){var r,u,o=n.elm,d=i.staticStyle,p=i.normalizedStyle||i.style||{},l=d||p,m=ds(n.data.style)||{};n.data.normalizedStyle=a(m.__ob__)?S({},m):m;var y=function(e,t){for(var n,a={},s=e;s.componentInstance;)(s=s.componentInstance._vnode)&&s.data&&(n=os(s.data))&&S(a,n);(n=os(e.data))&&S(a,n);for(var i=e;i=i.parent;)i.data&&(n=os(i.data))&&S(a,n);return a}(n);for(u in l)t(y[u])&&ys(o,u,"");for(u in y)(r=y[u])!==l[u]&&ys(o,u,null==r?"":r)}}var bs={create:fs,update:fs},vs=/\s+/;function Ts(e,t){if(t&&(t=t.trim()))if(e.classList)t.indexOf(" ")>-1?t.split(vs).forEach((function(t){return e.classList.add(t)})):e.classList.add(t);else{var n=" "+(e.getAttribute("class")||"")+" ";n.indexOf(" "+t+" ")<0&&e.setAttribute("class",(n+t).trim())}}function gs(e,t){if(t&&(t=t.trim()))if(e.classList)t.indexOf(" ")>-1?t.split(vs).forEach((function(t){return e.classList.remove(t)})):e.classList.remove(t),e.classList.length||e.removeAttribute("class");else{for(var n=" "+(e.getAttribute("class")||"")+" ",a=" "+t+" ";n.indexOf(a)>=0;)n=n.replace(a," ");(n=n.trim())?e.setAttribute("class",n):e.removeAttribute("class")}}function ws(e){if(e){if("object"==typeof e){var t={};return!1!==e.css&&S(t,Rs(e.name||"v")),S(t,e),t}return"string"==typeof e?Rs(e):void 0}}var Rs=T((function(e){return{enterClass:e+"-enter",enterToClass:e+"-enter-to",enterActiveClass:e+"-enter-active",leaveClass:e+"-leave",leaveToClass:e+"-leave-to",leaveActiveClass:e+"-leave-active"}})),As=q&&!K,ks="transition",xs="animation",_s="transition",Ss="transitionend",Ms="animation",Os="animationend";As&&(void 0===window.ontransitionend&&void 0!==window.onwebkittransitionend&&(_s="WebkitTransition",Ss="webkitTransitionEnd"),void 0===window.onanimationend&&void 0!==window.onwebkitanimationend&&(Ms="WebkitAnimation",Os="webkitAnimationEnd"));var Is=q?window.requestAnimationFrame?window.requestAnimationFrame.bind(window):setTimeout:function(e){return e()};function Cs(e){Is((function(){Is(e)}))}function Us(e,t){var n=e._transitionClasses||(e._transitionClasses=[]);n.indexOf(t)<0&&(n.push(t),Ts(e,t))}function Es(e,t){e._transitionClasses&&f(e._transitionClasses,t),gs(e,t)}function Ps(e,t,n){var a=Ds(e,t),s=a.type,i=a.timeout,r=a.propCount;if(!s)return n();var u=s===ks?Ss:Os,o=0,d=function(){e.removeEventListener(u,p),n()},p=function(t){t.target===e&&++o>=r&&d()};setTimeout((function(){o<r&&d()}),i+1),e.addEventListener(u,p)}var Ls=/\b(transform|all)(,|$)/;function Ds(e,t){var n,a=window.getComputedStyle(e),s=(a[_s+"Delay"]||"").split(", "),i=(a[_s+"Duration"]||"").split(", "),r=$s(s,i),u=(a[Ms+"Delay"]||"").split(", "),o=(a[Ms+"Duration"]||"").split(", "),d=$s(u,o),p=0,l=0;return t===ks?r>0&&(n=ks,p=r,l=i.length):t===xs?d>0&&(n=xs,p=d,l=o.length):l=(n=(p=Math.max(r,d))>0?r>d?ks:xs:null)?n===ks?i.length:o.length:0,{type:n,timeout:p,propCount:l,hasTransform:n===ks&&Ls.test(a[_s+"Property"])}}function $s(e,t){for(;e.length<t.length;)e=e.concat(e);return Math.max.apply(null,t.map((function(t,n){return Bs(t)+Bs(e[n])})))}function Bs(e){return 1e3*Number(e.slice(0,-1).replace(",","."))}function Ns(e,n){var s=e.elm;a(s._leaveCb)&&(s._leaveCb.cancelled=!0,s._leaveCb());var i=ws(e.data.transition);if(!t(i)&&!a(s._enterCb)&&1===s.nodeType){for(var u=i.css,o=i.type,d=i.enterClass,p=i.enterToClass,l=i.enterActiveClass,y=i.appearClass,c=i.appearToClass,h=i.appearActiveClass,f=i.beforeEnter,b=i.enter,v=i.afterEnter,T=i.enterCancelled,g=i.beforeAppear,w=i.appear,R=i.afterAppear,A=i.appearCancelled,k=i.duration,x=Qt,_=Qt.$vnode;_&&_.parent;)x=_.context,_=_.parent;var S=!x._isMounted||!e.isRootInsert;if(!S||w||""===w){var M=S&&y?y:d,O=S&&h?h:l,I=S&&c?c:p,C=S&&g||f,U=S&&"function"==typeof w?w:b,E=S&&R||v,L=S&&A||T,D=m(r(k)?k.enter:k),$=!1!==u&&!K,B=Ws(U),N=s._enterCb=P((function(){$&&(Es(s,I),Es(s,O)),N.cancelled?($&&Es(s,M),L&&L(s)):E&&E(s),s._enterCb=null}));e.data.show||dt(e,"insert",(function(){var t=s.parentNode,n=t&&t._pending&&t._pending[e.key];n&&n.tag===e.tag&&n.elm._leaveCb&&n.elm._leaveCb(),U&&U(s,N)})),C&&C(s),$&&(Us(s,M),Us(s,O),Cs((function(){Es(s,M),N.cancelled||(Us(s,I),B||(Fs(D)?setTimeout(N,D):Ps(s,o,N)))}))),e.data.show&&(n&&n(),U&&U(s,N)),$||B||N()}}}function js(e,n){var s=e.elm;a(s._enterCb)&&(s._enterCb.cancelled=!0,s._enterCb());var i=ws(e.data.transition);if(t(i)||1!==s.nodeType)return n();if(!a(s._leaveCb)){var u=i.css,o=i.type,d=i.leaveClass,p=i.leaveToClass,l=i.leaveActiveClass,y=i.beforeLeave,c=i.leave,h=i.afterLeave,f=i.leaveCancelled,b=i.delayLeave,v=i.duration,T=!1!==u&&!K,g=Ws(c),w=m(r(v)?v.leave:v),R=s._leaveCb=P((function(){s.parentNode&&s.parentNode._pending&&(s.parentNode._pending[e.key]=null),T&&(Es(s,p),Es(s,l)),R.cancelled?(T&&Es(s,d),f&&f(s)):(n(),h&&h(s)),s._leaveCb=null}));b?b(A):A()}function A(){R.cancelled||(!e.data.show&&s.parentNode&&((s.parentNode._pending||(s.parentNode._pending={}))[e.key]=e),y&&y(s),T&&(Us(s,d),Us(s,l),Cs((function(){Es(s,d),R.cancelled||(Us(s,p),g||(Fs(w)?setTimeout(R,w):Ps(s,o,R)))}))),c&&c(s,R),T||g||R())}}function Fs(e){return"number"==typeof e&&!isNaN(e)}function Ws(e){if(t(e))return!1;var n=e.fns;return a(n)?Ws(Array.isArray(n)?n[0]:n):(e._length||e.length)>1}function zs(e,t){!0!==t.data.show&&Ns(t)}var Gs=function(e){var n,r,u={},o=e.modules,d=e.nodeOps;for(n=0;n<ra.length;++n)for(u[ra[n]]=[],r=0;r<o.length;++r)a(o[r][ra[n]])&&u[ra[n]].push(o[r][ra[n]]);function p(e){var t=d.parentNode(e);a(t)&&d.removeChild(t,e)}function l(e,t,n,i,r,o,p){if(a(e.elm)&&a(o)&&(e=o[p]=ve(e)),e.isRootInsert=!r,!function(e,t,n,i){var r=e.data;if(a(r)){var o=a(e.componentInstance)&&r.keepAlive;if(a(r=r.hook)&&a(r=r.init)&&r(e,!1),a(e.componentInstance))return m(e,t),c(n,e.elm,i),s(o)&&function(e,t,n,s){for(var i,r=e;r.componentInstance;)if(a(i=(r=r.componentInstance._vnode).data)&&a(i=i.transition)){for(i=0;i<u.activate.length;++i)u.activate[i](ia,r);t.push(r);break}c(n,e.elm,s)}(e,t,n,i),!0}}(e,t,n,i)){var l=e.data,y=e.children,f=e.tag;a(f)?(e.elm=e.ns?d.createElementNS(e.ns,f):d.createElement(f,e),v(e),h(e,y,t),a(l)&&b(e,t),c(n,e.elm,i)):s(e.isComment)?(e.elm=d.createComment(e.text),c(n,e.elm,i)):(e.elm=d.createTextNode(e.text),c(n,e.elm,i))}}function m(e,t){a(e.data.pendingInsert)&&(t.push.apply(t,e.data.pendingInsert),e.data.pendingInsert=null),e.elm=e.componentInstance.$el,f(e)?(b(e,t),v(e)):(sa(e),t.push(e))}function c(e,t,n){a(e)&&(a(n)?d.parentNode(n)===e&&d.insertBefore(e,t,n):d.appendChild(e,t))}function h(e,t,n){if(Array.isArray(t))for(var a=0;a<t.length;++a)l(t[a],n,e.elm,null,!0,t,a);else i(e.text)&&d.appendChild(e.elm,d.createTextNode(String(e.text)))}function f(e){for(;e.componentInstance;)e=e.componentInstance._vnode;return a(e.tag)}function b(e,t){for(var s=0;s<u.create.length;++s)u.create[s](ia,e);a(n=e.data.hook)&&(a(n.create)&&n.create(ia,e),a(n.insert)&&t.push(e))}function v(e){var t;if(a(t=e.fnScopeId))d.setStyleScope(e.elm,t);else for(var n=e;n;)a(t=n.context)&&a(t=t.$options._scopeId)&&d.setStyleScope(e.elm,t),n=n.parent;a(t=Qt)&&t!==e.context&&t!==e.fnContext&&a(t=t.$options._scopeId)&&d.setStyleScope(e.elm,t)}function T(e,t,n,a,s,i){for(;a<=s;++a)l(n[a],i,e,t,!1,n,a)}function g(e){var t,n,s=e.data;if(a(s))for(a(t=s.hook)&&a(t=t.destroy)&&t(e),t=0;t<u.destroy.length;++t)u.destroy[t](e);if(a(t=e.children))for(n=0;n<e.children.length;++n)g(e.children[n])}function w(e,t,n){for(;t<=n;++t){var s=e[t];a(s)&&(a(s.tag)?(R(s),g(s)):p(s.elm))}}function R(e,t){if(a(t)||a(e.data)){var n,s=u.remove.length+1;for(a(t)?t.listeners+=s:t=function(e,t){function n(){0==--n.listeners&&p(e)}return n.listeners=t,n}(e.elm,s),a(n=e.componentInstance)&&a(n=n._vnode)&&a(n.data)&&R(n,t),n=0;n<u.remove.length;++n)u.remove[n](e,t);a(n=e.data.hook)&&a(n=n.remove)?n(e,t):t()}else p(e.elm)}function A(e,t,n,s){for(var i=n;i<s;i++){var r=t[i];if(a(r)&&ua(e,r))return i}}function k(e,n,i,r,o,p){if(e!==n){a(n.elm)&&a(r)&&(n=r[o]=ve(n));var m=n.elm=e.elm;if(s(e.isAsyncPlaceholder))a(n.asyncFactory.resolved)?S(e.elm,n,i):n.isAsyncPlaceholder=!0;else if(s(n.isStatic)&&s(e.isStatic)&&n.key===e.key&&(s(n.isCloned)||s(n.isOnce)))n.componentInstance=e.componentInstance;else{var y,c=n.data;a(c)&&a(y=c.hook)&&a(y=y.prepatch)&&y(e,n);var h=e.children,b=n.children;if(a(c)&&f(n)){for(y=0;y<u.update.length;++y)u.update[y](e,n);a(y=c.hook)&&a(y=y.update)&&y(e,n)}t(n.text)?a(h)&&a(b)?h!==b&&function(e,n,s,i,r){for(var u,o,p,m=0,y=0,c=n.length-1,h=n[0],f=n[c],b=s.length-1,v=s[0],g=s[b],R=!r;m<=c&&y<=b;)t(h)?h=n[++m]:t(f)?f=n[--c]:ua(h,v)?(k(h,v,i,s,y),h=n[++m],v=s[++y]):ua(f,g)?(k(f,g,i,s,b),f=n[--c],g=s[--b]):ua(h,g)?(k(h,g,i,s,b),R&&d.insertBefore(e,h.elm,d.nextSibling(f.elm)),h=n[++m],g=s[--b]):ua(f,v)?(k(f,v,i,s,y),R&&d.insertBefore(e,f.elm,h.elm),f=n[--c],v=s[++y]):(t(u)&&(u=oa(n,m,c)),t(o=a(v.key)?u[v.key]:A(v,n,m,c))?l(v,i,e,h.elm,!1,s,y):ua(p=n[o],v)?(k(p,v,i,s,y),n[o]=void 0,R&&d.insertBefore(e,p.elm,h.elm)):l(v,i,e,h.elm,!1,s,y),v=s[++y]);m>c?T(e,t(s[b+1])?null:s[b+1].elm,s,y,b,i):y>b&&w(n,m,c)}(m,h,b,i,p):a(b)?(a(e.text)&&d.setTextContent(m,""),T(m,null,b,0,b.length-1,i)):a(h)?w(h,0,h.length-1):a(e.text)&&d.setTextContent(m,""):e.text!==n.text&&d.setTextContent(m,n.text),a(c)&&a(y=c.hook)&&a(y=y.postpatch)&&y(e,n)}}}function x(e,t,n){if(s(n)&&a(e.parent))e.parent.data.pendingInsert=t;else for(var i=0;i<t.length;++i)t[i].data.hook.insert(t[i])}var _=y("attrs,class,staticClass,staticStyle,key");function S(e,t,n,i){var r,u=t.tag,o=t.data,d=t.children;if(i=i||o&&o.pre,t.elm=e,s(t.isComment)&&a(t.asyncFactory))return t.isAsyncPlaceholder=!0,!0;if(a(o)&&(a(r=o.hook)&&a(r=r.init)&&r(t,!0),a(r=t.componentInstance)))return m(t,n),!0;if(a(u)){if(a(d))if(e.hasChildNodes())if(a(r=o)&&a(r=r.domProps)&&a(r=r.innerHTML)){if(r!==e.innerHTML)return!1}else{for(var p=!0,l=e.firstChild,y=0;y<d.length;y++){if(!l||!S(l,d[y],n,i)){p=!1;break}l=l.nextSibling}if(!p||l)return!1}else h(t,d,n);if(a(o)){var c=!1;for(var f in o)if(!_(f)){c=!0,b(t,n);break}!c&&o.class&&st(o.class)}}else e.data!==t.text&&(e.data=t.text);return!0}return function(e,n,i,r){if(!t(n)){var o,p=!1,m=[];if(t(e))p=!0,l(n,m);else{var y=a(e.nodeType);if(!y&&ua(e,n))k(e,n,m,null,null,r);else{if(y){if(1===e.nodeType&&e.hasAttribute(L)&&(e.removeAttribute(L),i=!0),s(i)&&S(e,n,m))return x(n,m,!0),e;o=e,e=new ce(d.tagName(o).toLowerCase(),{},[],void 0,o)}var c=e.elm,h=d.parentNode(c);if(l(n,m,c._leaveCb?null:h,d.nextSibling(c)),a(n.parent))for(var b=n.parent,v=f(n);b;){for(var T=0;T<u.destroy.length;++T)u.destroy[T](b);if(b.elm=n.elm,v){for(var R=0;R<u.create.length;++R)u.create[R](ia,b);var A=b.data.hook.insert;if(A.merged)for(var _=1;_<A.fns.length;_++)A.fns[_]()}else sa(b);b=b.parent}a(h)?w([e],0,0):a(e.tag)&&g(e)}}return x(n,m,p),n.elm}a(e)&&g(e)}}({nodeOps:na,modules:[Ta,Sa,as,rs,bs,q?{create:zs,activate:zs,remove:function(e,t){!0!==e.data.show?js(e,t):t()}}:{}].concat(ha)});K&&document.addEventListener("selectionchange",(function(){var e=document.activeElement;e&&e.vmodel&&Xs(e,"input")}));var qs={inserted:function(e,t,n,a){"select"===n.tag?(a.elm&&!a.elm._vOptions?dt(n,"postpatch",(function(){qs.componentUpdated(e,t,n)})):Vs(e,t,n.context),e._vOptions=[].map.call(e.options,Ys)):("textarea"===n.tag||ea(e.type))&&(e._vModifiers=t.modifiers,t.modifiers.lazy||(e.addEventListener("compositionstart",Ks),e.addEventListener("compositionend",Zs),e.addEventListener("change",Zs),K&&(e.vmodel=!0)))},componentUpdated:function(e,t,n){if("select"===n.tag){Vs(e,t,n.context);var a=e._vOptions,s=e._vOptions=[].map.call(e.options,Ys);s.some((function(e,t){return!U(e,a[t])}))&&(e.multiple?t.value.some((function(e){return Hs(e,s)})):t.value!==t.oldValue&&Hs(t.value,s))&&Xs(e,"change")}}};function Vs(e,t,n){Js(e,t),(Y||Z)&&setTimeout((function(){Js(e,t)}),0)}function Js(e,t,n){var a=t.value,s=e.multiple;if(!s||Array.isArray(a)){for(var i,r,u=0,o=e.options.length;u<o;u++)if(r=e.options[u],s)i=E(a,Ys(r))>-1,r.selected!==i&&(r.selected=i);else if(U(Ys(r),a))return void(e.selectedIndex!==u&&(e.selectedIndex=u));s||(e.selectedIndex=-1)}}function Hs(e,t){return t.every((function(t){return!U(t,e)}))}function Ys(e){return"_value"in e?e._value:e.value}function Ks(e){e.target.composing=!0}function Zs(e){e.target.composing&&(e.target.composing=!1,Xs(e.target,"input"))}function Xs(e,t){var n=document.createEvent("HTMLEvents");n.initEvent(t,!0,!0),e.dispatchEvent(n)}function Qs(e){return!e.componentInstance||e.data&&e.data.transition?e:Qs(e.componentInstance._vnode)}var ei={bind:function(e,t,n){var a=t.value,s=(n=Qs(n)).data&&n.data.transition,i=e.__vOriginalDisplay="none"===e.style.display?"":e.style.display;a&&s?(n.data.show=!0,Ns(n,(function(){e.style.display=i}))):e.style.display=a?i:"none"},update:function(e,t,n){var a=t.value;!a!=!t.oldValue&&((n=Qs(n)).data&&n.data.transition?(n.data.show=!0,a?Ns(n,(function(){e.style.display=e.__vOriginalDisplay})):js(n,(function(){e.style.display="none"}))):e.style.display=a?e.__vOriginalDisplay:"none")},unbind:function(e,t,n,a,s){s||(e.style.display=e.__vOriginalDisplay)}},ti={model:qs,show:ei},ni={name:String,appear:Boolean,css:Boolean,mode:String,type:String,enterClass:String,leaveClass:String,enterToClass:String,leaveToClass:String,enterActiveClass:String,leaveActiveClass:String,appearClass:String,appearActiveClass:String,appearToClass:String,duration:[Number,String,Object]};function ai(e){var t=e&&e.componentOptions;return t&&t.Ctor.options.abstract?ai(Ht(t.children)):e}function si(e){var t={},n=e.$options;for(var a in n.propsData)t[a]=e[a];var s=n._parentListeners;for(var i in s)t[w(i)]=s[i];return t}function ii(e,t){if(/\d-keep-alive$/.test(t.tag))return e("keep-alive",{props:t.componentOptions.propsData})}var ri=function(e){return e.tag||bt(e)},ui=function(e){return"show"===e.name},oi={name:"transition",props:ni,abstract:!0,render:function(e){var t=this,n=this.$slots.default;if(n&&(n=n.filter(ri)).length){var a=this.mode,s=n[0];if(function(e){for(;e=e.parent;)if(e.data.transition)return!0}(this.$vnode))return s;var r=ai(s);if(!r)return s;if(this._leaving)return ii(e,s);var u="__transition-"+this._uid+"-";r.key=null==r.key?r.isComment?u+"comment":u+r.tag:i(r.key)?0===String(r.key).indexOf(u)?r.key:u+r.key:r.key;var o=(r.data||(r.data={})).transition=si(this),d=this._vnode,p=ai(d);if(r.data.directives&&r.data.directives.some(ui)&&(r.data.show=!0),p&&p.data&&!function(e,t){return t.key===e.key&&t.tag===e.tag}(r,p)&&!bt(p)&&(!p.componentInstance||!p.componentInstance._vnode.isComment)){var l=p.data.transition=S({},o);if("out-in"===a)return this._leaving=!0,dt(l,"afterLeave",(function(){t._leaving=!1,t.$forceUpdate()})),ii(e,s);if("in-out"===a){if(bt(r))return d;var m,y=function(){m()};dt(o,"afterEnter",y),dt(o,"enterCancelled",y),dt(l,"delayLeave",(function(e){m=e}))}}return s}}},di=S({tag:String,moveClass:String},ni);delete di.mode;var pi={props:di,beforeMount:function(){var e=this,t=this._update;this._update=function(n,a){var s=en(e);e.__patch__(e._vnode,e.kept,!1,!0),e._vnode=e.kept,s(),t.call(e,n,a)}},render:function(e){for(var t=this.tag||this.$vnode.data.tag||"span",n=Object.create(null),a=this.prevChildren=this.children,s=this.$slots.default||[],i=this.children=[],r=si(this),u=0;u<s.length;u++){var o=s[u];o.tag&&null!=o.key&&0!==String(o.key).indexOf("__vlist")&&(i.push(o),n[o.key]=o,(o.data||(o.data={})).transition=r)}if(a){for(var d=[],p=[],l=0;l<a.length;l++){var m=a[l];m.data.transition=r,m.data.pos=m.elm.getBoundingClientRect(),n[m.key]?d.push(m):p.push(m)}this.kept=e(t,null,d),this.removed=p}return e(t,null,i)},updated:function(){var e=this.prevChildren,t=this.moveClass||(this.name||"v")+"-move";e.length&&this.hasMove(e[0].elm,t)&&(e.forEach(li),e.forEach(mi),e.forEach(yi),this._reflow=document.body.offsetHeight,e.forEach((function(e){if(e.data.moved){var n=e.elm,a=n.style;Us(n,t),a.transform=a.WebkitTransform=a.transitionDuration="",n.addEventListener(Ss,n._moveCb=function e(a){a&&a.target!==n||a&&!/transform$/.test(a.propertyName)||(n.removeEventListener(Ss,e),n._moveCb=null,Es(n,t))})}})))},methods:{hasMove:function(e,t){if(!As)return!1;if(this._hasMove)return this._hasMove;var n=e.cloneNode();e._transitionClasses&&e._transitionClasses.forEach((function(e){gs(n,e)})),Ts(n,t),n.style.display="none",this.$el.appendChild(n);var a=Ds(n);return this.$el.removeChild(n),this._hasMove=a.hasTransform}}};function li(e){e.elm._moveCb&&e.elm._moveCb(),e.elm._enterCb&&e.elm._enterCb()}function mi(e){e.data.newPos=e.elm.getBoundingClientRect()}function yi(e){var t=e.data.pos,n=e.data.newPos,a=t.left-n.left,s=t.top-n.top;if(a||s){e.data.moved=!0;var i=e.elm.style;i.transform=i.WebkitTransform="translate("+a+"px,"+s+"px)",i.transitionDuration="0s"}}var ci={Transition:oi,TransitionGroup:pi};Sn.config.mustUseProp=$n,Sn.config.isReservedTag=Zn,Sn.config.isReservedAttr=Ln,Sn.config.getTagNamespace=Xn,Sn.config.isUnknownElement=function(e){if(!q)return!0;if(Zn(e))return!1;if(e=e.toLowerCase(),null!=Qn[e])return Qn[e];var t=document.createElement(e);return e.indexOf("-")>-1?Qn[e]=t.constructor===window.HTMLUnknownElement||t.constructor===window.HTMLElement:Qn[e]=/HTMLUnknownElement/.test(t.toString())},S(Sn.options.directives,ti),S(Sn.options.components,ci),Sn.prototype.__patch__=q?Gs:O,Sn.prototype.$mount=function(e,t){return function(e,t,n){var a;return e.$el=t,e.$options.render||(e.$options.render=fe),sn(e,"beforeMount"),a=function(){e._update(e._render(),n)},new bn(e,a,O,{before:function(){e._isMounted&&!e._isDestroyed&&sn(e,"beforeUpdate")}},!0),n=!1,null==e.$vnode&&(e._isMounted=!0,sn(e,"mounted")),e}(this,e=e&&q?ta(e):void 0,t)},q&&setTimeout((function(){B.devtools&&se&&se.emit("init",Sn)}),0);var hi,fi=/\{\{((?:.|\r?\n)+?)\}\}/g,bi=/[-.*+?^${}()|[\]\/\\]/g,vi=T((function(e){var t=e[0].replace(bi,"\\$&"),n=e[1].replace(bi,"\\$&");return new RegExp(t+"((?:.|\\n)+?)"+n,"g")})),Ti={staticKeys:["staticClass"],transformNode:function(e,t){t.warn;var n=ja(e,"class");n&&(e.staticClass=JSON.stringify(n));var a=Na(e,"class",!1);a&&(e.classBinding=a)},genData:function(e){var t="";return e.staticClass&&(t+="staticClass:"+e.staticClass+","),e.classBinding&&(t+="class:"+e.classBinding+","),t}},gi={staticKeys:["staticStyle"],transformNode:function(e,t){t.warn;var n=ja(e,"style");n&&(e.staticStyle=JSON.stringify(us(n)));var a=Na(e,"style",!1);a&&(e.styleBinding=a)},genData:function(e){var t="";return e.staticStyle&&(t+="staticStyle:"+e.staticStyle+","),e.styleBinding&&(t+="style:("+e.styleBinding+"),"),t}},wi=y("area,base,br,col,embed,frame,hr,img,input,isindex,keygen,link,meta,param,source,track,wbr"),Ri=y("colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source"),Ai=y("address,article,aside,base,blockquote,body,caption,col,colgroup,dd,details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,title,tr,track"),ki=/^\s*([^\s"'<>\/=]+)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/,xi=/^\s*((?:v-[\w-]+:|@|:|#)\[[^=]+?\][^\s"'<>\/=]*)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/,_i="[a-zA-Z_][\\-\\.0-9_a-zA-Z"+N.source+"]*",Si="((?:"+_i+"\\:)?"+_i+")",Mi=new RegExp("^<"+Si),Oi=/^\s*(\/?)>/,Ii=new RegExp("^<\\/"+Si+"[^>]*>"),Ci=/^<!DOCTYPE [^>]+>/i,Ui=/^<!\--/,Ei=/^<!\[/,Pi=y("script,style,textarea",!0),Li={},Di={"&lt;":"<","&gt;":">","&quot;":'"',"&amp;":"&","&#10;":"\n","&#9;":"\t","&#39;":"'"},$i=/&(?:lt|gt|quot|amp|#39);/g,Bi=/&(?:lt|gt|quot|amp|#39|#10|#9);/g,Ni=y("pre,textarea",!0),ji=function(e,t){return e&&Ni(e)&&"\n"===t[0]};function Fi(e,t){var n=t?Bi:$i;return e.replace(n,(function(e){return Di[e]}))}var Wi,zi,Gi,qi,Vi,Ji,Hi,Yi,Ki=/^@|^v-on:/,Zi=/^v-|^@|^:|^#/,Xi=/([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/,Qi=/,([^,\}\]]*)(?:,([^,\}\]]*))?$/,er=/^\(|\)$/g,tr=/^\[.*\]$/,nr=/:(.*)$/,ar=/^:|^\.|^v-bind:/,sr=/\.[^.\]]+(?=[^\]]*$)/g,ir=/^v-slot(:|$)|^#/,rr=/[\r\n]/,ur=/[ \f\t\r\n]+/g,or=T((function(e){return(hi=hi||document.createElement("div")).innerHTML=e,hi.textContent})),dr="_empty_";function pr(e,t,n){return{type:1,tag:e,attrsList:t,attrsMap:fr(t),rawAttrsMap:{},parent:n,children:[]}}function lr(e,t){var n;!function(e){var t=Na(e,"key");t&&(e.key=t)}(e),e.plain=!e.key&&!e.scopedSlots&&!e.attrsList.length,function(e){var t=Na(e,"ref");t&&(e.ref=t,e.refInFor=function(e){for(var t=e;t;){if(void 0!==t.for)return!0;t=t.parent}return!1}(e))}(e),function(e){var t;"template"===e.tag?(t=ja(e,"scope"),e.slotScope=t||ja(e,"slot-scope")):(t=ja(e,"slot-scope"))&&(e.slotScope=t);var n=Na(e,"slot");if(n&&(e.slotTarget='""'===n?'"default"':n,e.slotTargetDynamic=!(!e.attrsMap[":slot"]&&!e.attrsMap["v-bind:slot"]),"template"===e.tag||e.slotScope||Pa(e,"slot",n,function(e,t){return e.rawAttrsMap[":slot"]||e.rawAttrsMap["v-bind:slot"]||e.rawAttrsMap.slot}(e))),"template"===e.tag){var a=Fa(e,ir);if(a){var s=cr(a),i=s.name,r=s.dynamic;e.slotTarget=i,e.slotTargetDynamic=r,e.slotScope=a.value||dr}}else{var u=Fa(e,ir);if(u){var o=e.scopedSlots||(e.scopedSlots={}),d=cr(u),p=d.name,l=d.dynamic,m=o[p]=pr("template",[],e);m.slotTarget=p,m.slotTargetDynamic=l,m.children=e.children.filter((function(e){if(!e.slotScope)return e.parent=m,!0})),m.slotScope=u.value||dr,e.children=[],e.plain=!1}}}(e),"slot"===(n=e).tag&&(n.slotName=Na(n,"name")),function(e){var t;(t=Na(e,"is"))&&(e.component=t),null!=ja(e,"inline-template")&&(e.inlineTemplate=!0)}(e);for(var a=0;a<Gi.length;a++)e=Gi[a](e,t)||e;return function(e){var t,n,a,s,i,r,u,o,d=e.attrsList;for(t=0,n=d.length;t<n;t++)if(a=s=d[t].name,i=d[t].value,Zi.test(a))if(e.hasBindings=!0,(r=hr(a.replace(Zi,"")))&&(a=a.replace(sr,"")),ar.test(a))a=a.replace(ar,""),i=Oa(i),(o=tr.test(a))&&(a=a.slice(1,-1)),r&&(r.prop&&!o&&"innerHtml"===(a=w(a))&&(a="innerHTML"),r.camel&&!o&&(a=w(a)),r.sync&&(u=Ga(i,"$event"),o?Ba(e,'"update:"+('+a+")",u,null,!1,0,d[t],!0):(Ba(e,"update:"+w(a),u,null,!1,0,d[t]),k(a)!==w(a)&&Ba(e,"update:"+k(a),u,null,!1,0,d[t])))),r&&r.prop||!e.component&&Hi(e.tag,e.attrsMap.type,a)?Ea(e,a,i,d[t],o):Pa(e,a,i,d[t],o);else if(Ki.test(a))a=a.replace(Ki,""),(o=tr.test(a))&&(a=a.slice(1,-1)),Ba(e,a,i,r,!1,0,d[t],o);else{var p=(a=a.replace(Zi,"")).match(nr),l=p&&p[1];o=!1,l&&(a=a.slice(0,-(l.length+1)),tr.test(l)&&(l=l.slice(1,-1),o=!0)),Da(e,a,s,i,l,o,r,d[t])}else Pa(e,a,JSON.stringify(i),d[t]),!e.component&&"muted"===a&&Hi(e.tag,e.attrsMap.type,a)&&Ea(e,a,"true",d[t])}(e),e}function mr(e){var t;if(t=ja(e,"v-for")){var n=function(e){var t=e.match(Xi);if(t){var n={};n.for=t[2].trim();var a=t[1].trim().replace(er,""),s=a.match(Qi);return s?(n.alias=a.replace(Qi,"").trim(),n.iterator1=s[1].trim(),s[2]&&(n.iterator2=s[2].trim())):n.alias=a,n}}(t);n&&S(e,n)}}function yr(e,t){e.ifConditions||(e.ifConditions=[]),e.ifConditions.push(t)}function cr(e){var t=e.name.replace(ir,"");return t||"#"!==e.name[0]&&(t="default"),tr.test(t)?{name:t.slice(1,-1),dynamic:!0}:{name:'"'+t+'"',dynamic:!1}}function hr(e){var t=e.match(sr);if(t){var n={};return t.forEach((function(e){n[e.slice(1)]=!0})),n}}function fr(e){for(var t={},n=0,a=e.length;n<a;n++)t[e[n].name]=e[n].value;return t}var br=/^xmlns:NS\d+/,vr=/^NS\d+:/;function Tr(e){return pr(e.tag,e.attrsList.slice(),e.parent)}var gr,wr,Rr,Ar=[Ti,gi,{preTransformNode:function(e,t){if("input"===e.tag){var n,a=e.attrsMap;if(!a["v-model"])return;if((a[":type"]||a["v-bind:type"])&&(n=Na(e,"type")),a.type||n||!a["v-bind"]||(n="("+a["v-bind"]+").type"),n){var s=ja(e,"v-if",!0),i=s?"&&("+s+")":"",r=null!=ja(e,"v-else",!0),u=ja(e,"v-else-if",!0),o=Tr(e);mr(o),La(o,"type","checkbox"),lr(o,t),o.processed=!0,o.if="("+n+")==='checkbox'"+i,yr(o,{exp:o.if,block:o});var d=Tr(e);ja(d,"v-for",!0),La(d,"type","radio"),lr(d,t),yr(o,{exp:"("+n+")==='radio'"+i,block:d});var p=Tr(e);return ja(p,"v-for",!0),La(p,":type",n),lr(p,t),yr(o,{exp:s,block:p}),r?o.else=!0:u&&(o.elseif=u),o}}}}],kr={model:function(e,t,n){var a=t.value,s=t.modifiers,i=e.tag,r=e.attrsMap.type;if(e.component)return za(e,a,s),!1;if("select"===i)!function(e,t,n){var a='var $$selectedVal = Array.prototype.filter.call($event.target.options,function(o){return o.selected}).map(function(o){var val = "_value" in o ? o._value : o.value;return '+(n&&n.number?"_n(val)":"val")+"});";Ba(e,"change",a=a+" "+Ga(t,"$event.target.multiple ? $$selectedVal : $$selectedVal[0]"),null,!0)}(e,a,s);else if("input"===i&&"checkbox"===r)!function(e,t,n){var a=n&&n.number,s=Na(e,"value")||"null",i=Na(e,"true-value")||"true",r=Na(e,"false-value")||"false";Ea(e,"checked","Array.isArray("+t+")?_i("+t+","+s+")>-1"+("true"===i?":("+t+")":":_q("+t+","+i+")")),Ba(e,"change","var $$a="+t+",$$el=$event.target,$$c=$$el.checked?("+i+"):("+r+");if(Array.isArray($$a)){var $$v="+(a?"_n("+s+")":s)+",$$i=_i($$a,$$v);if($$el.checked){$$i<0&&("+Ga(t,"$$a.concat([$$v])")+")}else{$$i>-1&&("+Ga(t,"$$a.slice(0,$$i).concat($$a.slice($$i+1))")+")}}else{"+Ga(t,"$$c")+"}",null,!0)}(e,a,s);else if("input"===i&&"radio"===r)!function(e,t,n){var a=n&&n.number,s=Na(e,"value")||"null";Ea(e,"checked","_q("+t+","+(s=a?"_n("+s+")":s)+")"),Ba(e,"change",Ga(t,s),null,!0)}(e,a,s);else if("input"===i||"textarea"===i)!function(e,t,n){var a=e.attrsMap.type,s=n||{},i=s.lazy,r=s.number,u=s.trim,o=!i&&"range"!==a,d=i?"change":"range"===a?"__r":"input",p="$event.target.value";u&&(p="$event.target.value.trim()"),r&&(p="_n("+p+")");var l=Ga(t,p);o&&(l="if($event.target.composing)return;"+l),Ea(e,"value","("+t+")"),Ba(e,d,l,null,!0),(u||r)&&Ba(e,"blur","$forceUpdate()")}(e,a,s);else if(!B.isReservedTag(i))return za(e,a,s),!1;return!0},text:function(e,t){t.value&&Ea(e,"textContent","_s("+t.value+")",t)},html:function(e,t){t.value&&Ea(e,"innerHTML","_s("+t.value+")",t)}},xr={expectHTML:!0,modules:Ar,directives:kr,isPreTag:function(e){return"pre"===e},isUnaryTag:wi,mustUseProp:$n,canBeLeftOpenTag:Ri,isReservedTag:Zn,getTagNamespace:Xn,staticKeys:(Rr=Ar,Rr.reduce((function(e,t){return e.concat(t.staticKeys||[])}),[]).join(","))},_r=T((function(e){return y("type,tag,attrsList,attrsMap,plain,parent,children,attrs,start,end,rawAttrsMap"+(e?","+e:""))}));function Sr(e,t){e&&(gr=_r(t.staticKeys||""),wr=t.isReservedTag||I,Mr(e),Or(e,!1))}function Mr(e){if(e.static=function(e){return 2!==e.type&&(3===e.type||!(!e.pre&&(e.hasBindings||e.if||e.for||c(e.tag)||!wr(e.tag)||function(e){for(;e.parent;){if("template"!==(e=e.parent).tag)return!1;if(e.for)return!0}return!1}(e)||!Object.keys(e).every(gr))))}(e),1===e.type){if(!wr(e.tag)&&"slot"!==e.tag&&null==e.attrsMap["inline-template"])return;for(var t=0,n=e.children.length;t<n;t++){var a=e.children[t];Mr(a),a.static||(e.static=!1)}if(e.ifConditions)for(var s=1,i=e.ifConditions.length;s<i;s++){var r=e.ifConditions[s].block;Mr(r),r.static||(e.static=!1)}}}function Or(e,t){if(1===e.type){if((e.static||e.once)&&(e.staticInFor=t),e.static&&e.children.length&&(1!==e.children.length||3!==e.children[0].type))return void(e.staticRoot=!0);if(e.staticRoot=!1,e.children)for(var n=0,a=e.children.length;n<a;n++)Or(e.children[n],t||!!e.for);if(e.ifConditions)for(var s=1,i=e.ifConditions.length;s<i;s++)Or(e.ifConditions[s].block,t)}}var Ir=/^([\w$_]+|\([^)]*?\))\s*=>|^function(?:\s+[\w$]+)?\s*\(/,Cr=/\([^)]*?\);*$/,Ur=/^[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['[^']*?']|\["[^"]*?"]|\[\d+]|\[[A-Za-z_$][\w$]*])*$/,Er={esc:27,tab:9,enter:13,space:32,up:38,left:37,right:39,down:40,delete:[8,46]},Pr={esc:["Esc","Escape"],tab:"Tab",enter:"Enter",space:[" ","Spacebar"],up:["Up","ArrowUp"],left:["Left","ArrowLeft"],right:["Right","ArrowRight"],down:["Down","ArrowDown"],delete:["Backspace","Delete","Del"]},Lr=function(e){return"if("+e+")return null;"},Dr={stop:"$event.stopPropagation();",prevent:"$event.preventDefault();",self:Lr("$event.target !== $event.currentTarget"),ctrl:Lr("!$event.ctrlKey"),shift:Lr("!$event.shiftKey"),alt:Lr("!$event.altKey"),meta:Lr("!$event.metaKey"),left:Lr("'button' in $event && $event.button !== 0"),middle:Lr("'button' in $event && $event.button !== 1"),right:Lr("'button' in $event && $event.button !== 2")};function $r(e,t){var n=t?"nativeOn:":"on:",a="",s="";for(var i in e){var r=Br(e[i]);e[i]&&e[i].dynamic?s+=i+","+r+",":a+='"'+i+'":'+r+","}return a="{"+a.slice(0,-1)+"}",s?n+"_d("+a+",["+s.slice(0,-1)+"])":n+a}function Br(e){if(!e)return"function(){}";if(Array.isArray(e))return"["+e.map((function(e){return Br(e)})).join(",")+"]";var t=Ur.test(e.value),n=Ir.test(e.value),a=Ur.test(e.value.replace(Cr,""));if(e.modifiers){var s="",i="",r=[];for(var u in e.modifiers)if(Dr[u])i+=Dr[u],Er[u]&&r.push(u);else if("exact"===u){var o=e.modifiers;i+=Lr(["ctrl","shift","alt","meta"].filter((function(e){return!o[e]})).map((function(e){return"$event."+e+"Key"})).join("||"))}else r.push(u);return r.length&&(s+=function(e){return"if(!$event.type.indexOf('key')&&"+e.map(Nr).join("&&")+")return null;"}(r)),i&&(s+=i),"function($event){"+s+(t?"return "+e.value+".apply(null, arguments)":n?"return ("+e.value+").apply(null, arguments)":a?"return "+e.value:e.value)+"}"}return t||n?e.value:"function($event){"+(a?"return "+e.value:e.value)+"}"}function Nr(e){var t=parseInt(e,10);if(t)return"$event.keyCode!=="+t;var n=Er[e],a=Pr[e];return"_k($event.keyCode,"+JSON.stringify(e)+","+JSON.stringify(n)+",$event.key,"+JSON.stringify(a)+")"}var jr={on:function(e,t){e.wrapListeners=function(e){return"_g("+e+","+t.value+")"}},bind:function(e,t){e.wrapData=function(n){return"_b("+n+",'"+e.tag+"',"+t.value+","+(t.modifiers&&t.modifiers.prop?"true":"false")+(t.modifiers&&t.modifiers.sync?",true":"")+")"}},cloak:O},Fr=function(e){this.options=e,this.warn=e.warn||Ca,this.transforms=Ua(e.modules,"transformCode"),this.dataGenFns=Ua(e.modules,"genData"),this.directives=S(S({},jr),e.directives);var t=e.isReservedTag||I;this.maybeComponent=function(e){return!!e.component||!t(e.tag)},this.onceId=0,this.staticRenderFns=[],this.pre=!1};function Wr(e,t){var n=new Fr(t);return{render:"with(this){return "+(e?"script"===e.tag?"null":zr(e,n):'_c("div")')+"}",staticRenderFns:n.staticRenderFns}}function zr(e,t){if(e.parent&&(e.pre=e.pre||e.parent.pre),e.staticRoot&&!e.staticProcessed)return Gr(e,t);if(e.once&&!e.onceProcessed)return qr(e,t);if(e.for&&!e.forProcessed)return Hr(e,t);if(e.if&&!e.ifProcessed)return Vr(e,t);if("template"!==e.tag||e.slotTarget||t.pre){if("slot"===e.tag)return function(e,t){var n=e.slotName||'"default"',a=Xr(e,t),s="_t("+n+(a?",function(){return "+a+"}":""),i=e.attrs||e.dynamicAttrs?tu((e.attrs||[]).concat(e.dynamicAttrs||[]).map((function(e){return{name:w(e.name),value:e.value,dynamic:e.dynamic}}))):null,r=e.attrsMap["v-bind"];return!i&&!r||a||(s+=",null"),i&&(s+=","+i),r&&(s+=(i?"":",null")+","+r),s+")"}(e,t);var n;if(e.component)n=function(e,t,n){var a=t.inlineTemplate?null:Xr(t,n,!0);return"_c("+e+","+Yr(t,n)+(a?","+a:"")+")"}(e.component,e,t);else{var a;(!e.plain||e.pre&&t.maybeComponent(e))&&(a=Yr(e,t));var s=e.inlineTemplate?null:Xr(e,t,!0);n="_c('"+e.tag+"'"+(a?","+a:"")+(s?","+s:"")+")"}for(var i=0;i<t.transforms.length;i++)n=t.transforms[i](e,n);return n}return Xr(e,t)||"void 0"}function Gr(e,t){e.staticProcessed=!0;var n=t.pre;return e.pre&&(t.pre=e.pre),t.staticRenderFns.push("with(this){return "+zr(e,t)+"}"),t.pre=n,"_m("+(t.staticRenderFns.length-1)+(e.staticInFor?",true":"")+")"}function qr(e,t){if(e.onceProcessed=!0,e.if&&!e.ifProcessed)return Vr(e,t);if(e.staticInFor){for(var n="",a=e.parent;a;){if(a.for){n=a.key;break}a=a.parent}return n?"_o("+zr(e,t)+","+t.onceId+++","+n+")":zr(e,t)}return Gr(e,t)}function Vr(e,t,n,a){return e.ifProcessed=!0,Jr(e.ifConditions.slice(),t,n,a)}function Jr(e,t,n,a){if(!e.length)return a||"_e()";var s=e.shift();return s.exp?"("+s.exp+")?"+i(s.block)+":"+Jr(e,t,n,a):""+i(s.block);function i(e){return n?n(e,t):e.once?qr(e,t):zr(e,t)}}function Hr(e,t,n,a){var s=e.for,i=e.alias,r=e.iterator1?","+e.iterator1:"",u=e.iterator2?","+e.iterator2:"";return e.forProcessed=!0,(a||"_l")+"(("+s+"),function("+i+r+u+"){return "+(n||zr)(e,t)+"})"}function Yr(e,t){var n="{",a=function(e,t){var n=e.directives;if(n){var a,s,i,r,u="directives:[",o=!1;for(a=0,s=n.length;a<s;a++){i=n[a],r=!0;var d=t.directives[i.name];d&&(r=!!d(e,i,t.warn)),r&&(o=!0,u+='{name:"'+i.name+'",rawName:"'+i.rawName+'"'+(i.value?",value:("+i.value+"),expression:"+JSON.stringify(i.value):"")+(i.arg?",arg:"+(i.isDynamicArg?i.arg:'"'+i.arg+'"'):"")+(i.modifiers?",modifiers:"+JSON.stringify(i.modifiers):"")+"},")}return o?u.slice(0,-1)+"]":void 0}}(e,t);a&&(n+=a+","),e.key&&(n+="key:"+e.key+","),e.ref&&(n+="ref:"+e.ref+","),e.refInFor&&(n+="refInFor:true,"),e.pre&&(n+="pre:true,"),e.component&&(n+='tag:"'+e.tag+'",');for(var s=0;s<t.dataGenFns.length;s++)n+=t.dataGenFns[s](e);if(e.attrs&&(n+="attrs:"+tu(e.attrs)+","),e.props&&(n+="domProps:"+tu(e.props)+","),e.events&&(n+=$r(e.events,!1)+","),e.nativeEvents&&(n+=$r(e.nativeEvents,!0)+","),e.slotTarget&&!e.slotScope&&(n+="slot:"+e.slotTarget+","),e.scopedSlots&&(n+=function(e,t,n){var a=e.for||Object.keys(t).some((function(e){var n=t[e];return n.slotTargetDynamic||n.if||n.for||Kr(n)})),s=!!e.if;if(!a)for(var i=e.parent;i;){if(i.slotScope&&i.slotScope!==dr||i.for){a=!0;break}i.if&&(s=!0),i=i.parent}var r=Object.keys(t).map((function(e){return Zr(t[e],n)})).join(",");return"scopedSlots:_u(["+r+"]"+(a?",null,true":"")+(!a&&s?",null,false,"+function(e){for(var t=5381,n=e.length;n;)t=33*t^e.charCodeAt(--n);return t>>>0}(r):"")+")"}(e,e.scopedSlots,t)+","),e.model&&(n+="model:{value:"+e.model.value+",callback:"+e.model.callback+",expression:"+e.model.expression+"},"),e.inlineTemplate){var i=function(e,t){var n=e.children[0];if(n&&1===n.type){var a=Wr(n,t.options);return"inlineTemplate:{render:function(){"+a.render+"},staticRenderFns:["+a.staticRenderFns.map((function(e){return"function(){"+e+"}"})).join(",")+"]}"}}(e,t);i&&(n+=i+",")}return n=n.replace(/,$/,"")+"}",e.dynamicAttrs&&(n="_b("+n+',"'+e.tag+'",'+tu(e.dynamicAttrs)+")"),e.wrapData&&(n=e.wrapData(n)),e.wrapListeners&&(n=e.wrapListeners(n)),n}function Kr(e){return 1===e.type&&("slot"===e.tag||e.children.some(Kr))}function Zr(e,t){var n=e.attrsMap["slot-scope"];if(e.if&&!e.ifProcessed&&!n)return Vr(e,t,Zr,"null");if(e.for&&!e.forProcessed)return Hr(e,t,Zr);var a=e.slotScope===dr?"":String(e.slotScope),s="function("+a+"){return "+("template"===e.tag?e.if&&n?"("+e.if+")?"+(Xr(e,t)||"undefined")+":undefined":Xr(e,t)||"undefined":zr(e,t))+"}",i=a?"":",proxy:true";return"{key:"+(e.slotTarget||'"default"')+",fn:"+s+i+"}"}function Xr(e,t,n,a,s){var i=e.children;if(i.length){var r=i[0];if(1===i.length&&r.for&&"template"!==r.tag&&"slot"!==r.tag){var u=n?t.maybeComponent(r)?",1":",0":"";return""+(a||zr)(r,t)+u}var o=n?function(e,t){for(var n=0,a=0;a<e.length;a++){var s=e[a];if(1===s.type){if(Qr(s)||s.ifConditions&&s.ifConditions.some((function(e){return Qr(e.block)}))){n=2;break}(t(s)||s.ifConditions&&s.ifConditions.some((function(e){return t(e.block)})))&&(n=1)}}return n}(i,t.maybeComponent):0,d=s||eu;return"["+i.map((function(e){return d(e,t)})).join(",")+"]"+(o?","+o:"")}}function Qr(e){return void 0!==e.for||"template"===e.tag||"slot"===e.tag}function eu(e,t){return 1===e.type?zr(e,t):3===e.type&&e.isComment?function(e){return"_e("+JSON.stringify(e.text)+")"}(e):"_v("+(2===(n=e).type?n.expression:nu(JSON.stringify(n.text)))+")";var n}function tu(e){for(var t="",n="",a=0;a<e.length;a++){var s=e[a],i=nu(s.value);s.dynamic?n+=s.name+","+i+",":t+='"'+s.name+'":'+i+","}return t="{"+t.slice(0,-1)+"}",n?"_d("+t+",["+n.slice(0,-1)+"])":t}function nu(e){return e.replace(/\u2028/g,"\\u2028").replace(/\u2029/g,"\\u2029")}function au(e,t){try{return new Function(e)}catch(n){return t.push({err:n,code:e}),O}}function su(e){var t=Object.create(null);return function(n,a,s){(a=S({},a)).warn,delete a.warn;var i=a.delimiters?String(a.delimiters)+n:n;if(t[i])return t[i];var r=e(n,a),u={},o=[];return u.render=au(r.render,o),u.staticRenderFns=r.staticRenderFns.map((function(e){return au(e,o)})),t[i]=u}}new RegExp("\\b"+"do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,super,throw,while,yield,delete,export,import,return,switch,default,extends,finally,continue,debugger,function,arguments".split(",").join("\\b|\\b")+"\\b"),new RegExp("\\b"+"delete,typeof,void".split(",").join("\\s*\\([^\\)]*\\)|\\b")+"\\s*\\([^\\)]*\\)");var iu,ru,uu=(iu=function(e,t){var n=function(e,t){Wi=t.warn||Ca,Ji=t.isPreTag||I,Hi=t.mustUseProp||I,Yi=t.getTagNamespace||I,t.isReservedTag,Gi=Ua(t.modules,"transformNode"),qi=Ua(t.modules,"preTransformNode"),Vi=Ua(t.modules,"postTransformNode"),zi=t.delimiters;var n,a,s=[],i=!1!==t.preserveWhitespace,r=t.whitespace,u=!1,o=!1;function d(e){if(p(e),u||e.processed||(e=lr(e,t)),s.length||e===n||n.if&&(e.elseif||e.else)&&yr(n,{exp:e.elseif,block:e}),a&&!e.forbidden)if(e.elseif||e.else)r=e,d=function(e){for(var t=e.length;t--;){if(1===e[t].type)return e[t];e.pop()}}(a.children),d&&d.if&&yr(d,{exp:r.elseif,block:r});else{if(e.slotScope){var i=e.slotTarget||'"default"';(a.scopedSlots||(a.scopedSlots={}))[i]=e}a.children.push(e),e.parent=a}var r,d;e.children=e.children.filter((function(e){return!e.slotScope})),p(e),e.pre&&(u=!1),Ji(e.tag)&&(o=!1);for(var l=0;l<Vi.length;l++)Vi[l](e,t)}function p(e){if(!o)for(var t;(t=e.children[e.children.length-1])&&3===t.type&&" "===t.text;)e.children.pop()}return function(e,t){for(var n,a,s=[],i=t.expectHTML,r=t.isUnaryTag||I,u=t.canBeLeftOpenTag||I,o=0;e;){if(n=e,a&&Pi(a)){var d=0,p=a.toLowerCase(),l=Li[p]||(Li[p]=new RegExp("([\\s\\S]*?)(</"+p+"[^>]*>)","i")),m=e.replace(l,(function(e,n,a){return d=a.length,Pi(p)||"noscript"===p||(n=n.replace(/<!\--([\s\S]*?)-->/g,"$1").replace(/<!\[CDATA\[([\s\S]*?)]]>/g,"$1")),ji(p,n)&&(n=n.slice(1)),t.chars&&t.chars(n),""}));o+=e.length-m.length,e=m,_(p,o-d,o)}else{var y=e.indexOf("<");if(0===y){if(Ui.test(e)){var c=e.indexOf("--\x3e");if(c>=0){t.shouldKeepComment&&t.comment(e.substring(4,c),o,o+c+3),A(c+3);continue}}if(Ei.test(e)){var h=e.indexOf("]>");if(h>=0){A(h+2);continue}}var f=e.match(Ci);if(f){A(f[0].length);continue}var b=e.match(Ii);if(b){var v=o;A(b[0].length),_(b[1],v,o);continue}var T=k();if(T){x(T),ji(T.tagName,e)&&A(1);continue}}var g=void 0,w=void 0,R=void 0;if(y>=0){for(w=e.slice(y);!(Ii.test(w)||Mi.test(w)||Ui.test(w)||Ei.test(w)||(R=w.indexOf("<",1))<0);)y+=R,w=e.slice(y);g=e.substring(0,y)}y<0&&(g=e),g&&A(g.length),t.chars&&g&&t.chars(g,o-g.length,o)}if(e===n){t.chars&&t.chars(e);break}}function A(t){o+=t,e=e.substring(t)}function k(){var t=e.match(Mi);if(t){var n,a,s={tagName:t[1],attrs:[],start:o};for(A(t[0].length);!(n=e.match(Oi))&&(a=e.match(xi)||e.match(ki));)a.start=o,A(a[0].length),a.end=o,s.attrs.push(a);if(n)return s.unarySlash=n[1],A(n[0].length),s.end=o,s}}function x(e){var n=e.tagName,o=e.unarySlash;i&&("p"===a&&Ai(n)&&_(a),u(n)&&a===n&&_(n));for(var d=r(n)||!!o,p=e.attrs.length,l=new Array(p),m=0;m<p;m++){var y=e.attrs[m],c=y[3]||y[4]||y[5]||"",h="a"===n&&"href"===y[1]?t.shouldDecodeNewlinesForHref:t.shouldDecodeNewlines;l[m]={name:y[1],value:Fi(c,h)}}d||(s.push({tag:n,lowerCasedTag:n.toLowerCase(),attrs:l,start:e.start,end:e.end}),a=n),t.start&&t.start(n,l,d,e.start,e.end)}function _(e,n,i){var r,u;if(null==n&&(n=o),null==i&&(i=o),e)for(u=e.toLowerCase(),r=s.length-1;r>=0&&s[r].lowerCasedTag!==u;r--);else r=0;if(r>=0){for(var d=s.length-1;d>=r;d--)t.end&&t.end(s[d].tag,n,i);s.length=r,a=r&&s[r-1].tag}else"br"===u?t.start&&t.start(e,[],!0,n,i):"p"===u&&(t.start&&t.start(e,[],!1,n,i),t.end&&t.end(e,n,i))}_()}(e,{warn:Wi,expectHTML:t.expectHTML,isUnaryTag:t.isUnaryTag,canBeLeftOpenTag:t.canBeLeftOpenTag,shouldDecodeNewlines:t.shouldDecodeNewlines,shouldDecodeNewlinesForHref:t.shouldDecodeNewlinesForHref,shouldKeepComment:t.comments,outputSourceRange:t.outputSourceRange,start:function(e,i,r,p,l){var m=a&&a.ns||Yi(e);Y&&"svg"===m&&(i=function(e){for(var t=[],n=0;n<e.length;n++){var a=e[n];br.test(a.name)||(a.name=a.name.replace(vr,""),t.push(a))}return t}(i));var y,c=pr(e,i,a);m&&(c.ns=m),"style"!==(y=c).tag&&("script"!==y.tag||y.attrsMap.type&&"text/javascript"!==y.attrsMap.type)||ae()||(c.forbidden=!0);for(var h=0;h<qi.length;h++)c=qi[h](c,t)||c;u||(function(e){null!=ja(e,"v-pre")&&(e.pre=!0)}(c),c.pre&&(u=!0)),Ji(c.tag)&&(o=!0),u?function(e){var t=e.attrsList,n=t.length;if(n)for(var a=e.attrs=new Array(n),s=0;s<n;s++)a[s]={name:t[s].name,value:JSON.stringify(t[s].value)},null!=t[s].start&&(a[s].start=t[s].start,a[s].end=t[s].end);else e.pre||(e.plain=!0)}(c):c.processed||(mr(c),function(e){var t=ja(e,"v-if");if(t)e.if=t,yr(e,{exp:t,block:e});else{null!=ja(e,"v-else")&&(e.else=!0);var n=ja(e,"v-else-if");n&&(e.elseif=n)}}(c),function(e){null!=ja(e,"v-once")&&(e.once=!0)}(c)),n||(n=c),r?d(c):(a=c,s.push(c))},end:function(e,t,n){var i=s[s.length-1];s.length-=1,a=s[s.length-1],d(i)},chars:function(e,t,n){if(a&&(!Y||"textarea"!==a.tag||a.attrsMap.placeholder!==e)){var s,d,p,l=a.children;(e=o||e.trim()?"script"===(s=a).tag||"style"===s.tag?e:or(e):l.length?r?"condense"===r&&rr.test(e)?"":" ":i?" ":"":"")&&(o||"condense"!==r||(e=e.replace(ur," ")),!u&&" "!==e&&(d=function(e,t){var n=t?vi(t):fi;if(n.test(e)){for(var a,s,i,r=[],u=[],o=n.lastIndex=0;a=n.exec(e);){(s=a.index)>o&&(u.push(i=e.slice(o,s)),r.push(JSON.stringify(i)));var d=Oa(a[1].trim());r.push("_s("+d+")"),u.push({"@binding":d}),o=s+a[0].length}return o<e.length&&(u.push(i=e.slice(o)),r.push(JSON.stringify(i))),{expression:r.join("+"),tokens:u}}}(e,zi))?p={type:2,expression:d.expression,tokens:d.tokens,text:e}:" "===e&&l.length&&" "===l[l.length-1].text||(p={type:3,text:e}),p&&l.push(p))}},comment:function(e,t,n){if(a){var s={type:3,text:e,isComment:!0};a.children.push(s)}}}),n}(e.trim(),t);!1!==t.optimize&&Sr(n,t);var a=Wr(n,t);return{ast:n,render:a.render,staticRenderFns:a.staticRenderFns}},function(e){function t(t,n){var a=Object.create(e),s=[],i=[];if(n)for(var r in n.modules&&(a.modules=(e.modules||[]).concat(n.modules)),n.directives&&(a.directives=S(Object.create(e.directives||null),n.directives)),n)"modules"!==r&&"directives"!==r&&(a[r]=n[r]);a.warn=function(e,t,n){(n?i:s).push(e)};var u=iu(t.trim(),a);return u.errors=s,u.tips=i,u}return{compile:t,compileToFunctions:su(t)}}),ou=uu(xr),du=(ou.compile,ou.compileToFunctions);function pu(e){return(ru=ru||document.createElement("div")).innerHTML=e?'<a href="\n"/>':'<div a="\n"/>',ru.innerHTML.indexOf("&#10;")>0}var lu=!!q&&pu(!1),mu=!!q&&pu(!0),yu=T((function(e){var t=ta(e);return t&&t.innerHTML})),cu=Sn.prototype.$mount;Sn.prototype.$mount=function(e,t){if((e=e&&ta(e))===document.body||e===document.documentElement)return this;var n=this.$options;if(!n.render){var a=n.template;if(a)if("string"==typeof a)"#"===a.charAt(0)&&(a=yu(a));else{if(!a.nodeType)return this;a=a.innerHTML}else e&&(a=function(e){if(e.outerHTML)return e.outerHTML;var t=document.createElement("div");return t.appendChild(e.cloneNode(!0)),t.innerHTML}(e));if(a){var s=du(a,{outputSourceRange:!1,shouldDecodeNewlines:lu,shouldDecodeNewlinesForHref:mu,delimiters:n.delimiters,comments:n.comments},this),i=s.render,r=s.staticRenderFns;n.render=i,n.staticRenderFns=r}}return cu.call(this,e,t)},Sn.compile=du;const hu=Sn;function fu(e,t){for(var n in t)e[n]=t[n];return e}var bu=/[!'()*]/g,vu=function(e){return"%"+e.charCodeAt(0).toString(16)},Tu=/%2C/g,gu=function(e){return encodeURIComponent(e).replace(bu,vu).replace(Tu,",")};function wu(e){try{return decodeURIComponent(e)}catch(e){}return e}var Ru=function(e){return null==e||"object"==typeof e?e:String(e)};function Au(e){var t={};return(e=e.trim().replace(/^(\?|#|&)/,""))?(e.split("&").forEach((function(e){var n=e.replace(/\+/g," ").split("="),a=wu(n.shift()),s=n.length>0?wu(n.join("=")):null;void 0===t[a]?t[a]=s:Array.isArray(t[a])?t[a].push(s):t[a]=[t[a],s]})),t):t}function ku(e){var t=e?Object.keys(e).map((function(t){var n=e[t];if(void 0===n)return"";if(null===n)return gu(t);if(Array.isArray(n)){var a=[];return n.forEach((function(e){void 0!==e&&(null===e?a.push(gu(t)):a.push(gu(t)+"="+gu(e)))})),a.join("&")}return gu(t)+"="+gu(n)})).filter((function(e){return e.length>0})).join("&"):null;return t?"?"+t:""}var xu=/\/?$/;function _u(e,t,n,a){var s=a&&a.options.stringifyQuery,i=t.query||{};try{i=Su(i)}catch(e){}var r={name:t.name||e&&e.name,meta:e&&e.meta||{},path:t.path||"/",hash:t.hash||"",query:i,params:t.params||{},fullPath:Iu(t,s),matched:e?Ou(e):[]};return n&&(r.redirectedFrom=Iu(n,s)),Object.freeze(r)}function Su(e){if(Array.isArray(e))return e.map(Su);if(e&&"object"==typeof e){var t={};for(var n in e)t[n]=Su(e[n]);return t}return e}var Mu=_u(null,{path:"/"});function Ou(e){for(var t=[];e;)t.unshift(e),e=e.parent;return t}function Iu(e,t){var n=e.path,a=e.query;void 0===a&&(a={});var s=e.hash;return void 0===s&&(s=""),(n||"/")+(t||ku)(a)+s}function Cu(e,t,n){return t===Mu?e===t:!!t&&(e.path&&t.path?e.path.replace(xu,"")===t.path.replace(xu,"")&&(n||e.hash===t.hash&&Uu(e.query,t.query)):!(!e.name||!t.name)&&e.name===t.name&&(n||e.hash===t.hash&&Uu(e.query,t.query)&&Uu(e.params,t.params)))}function Uu(e,t){if(void 0===e&&(e={}),void 0===t&&(t={}),!e||!t)return e===t;var n=Object.keys(e).sort(),a=Object.keys(t).sort();return n.length===a.length&&n.every((function(n,s){var i=e[n];if(a[s]!==n)return!1;var r=t[n];return null==i||null==r?i===r:"object"==typeof i&&"object"==typeof r?Uu(i,r):String(i)===String(r)}))}function Eu(e){for(var t=0;t<e.matched.length;t++){var n=e.matched[t];for(var a in n.instances){var s=n.instances[a],i=n.enteredCbs[a];if(s&&i){delete n.enteredCbs[a];for(var r=0;r<i.length;r++)s._isBeingDestroyed||i[r](s)}}}}var Pu={name:"RouterView",functional:!0,props:{name:{type:String,default:"default"}},render:function(e,t){var n=t.props,a=t.children,s=t.parent,i=t.data;i.routerView=!0;for(var r=s.$createElement,u=n.name,o=s.$route,d=s._routerViewCache||(s._routerViewCache={}),p=0,l=!1;s&&s._routerRoot!==s;){var m=s.$vnode?s.$vnode.data:{};m.routerView&&p++,m.keepAlive&&s._directInactive&&s._inactive&&(l=!0),s=s.$parent}if(i.routerViewDepth=p,l){var y=d[u],c=y&&y.component;return c?(y.configProps&&Lu(c,i,y.route,y.configProps),r(c,i,a)):r()}var h=o.matched[p],f=h&&h.components[u];if(!h||!f)return d[u]=null,r();d[u]={component:f},i.registerRouteInstance=function(e,t){var n=h.instances[u];(t&&n!==e||!t&&n===e)&&(h.instances[u]=t)},(i.hook||(i.hook={})).prepatch=function(e,t){h.instances[u]=t.componentInstance},i.hook.init=function(e){e.data.keepAlive&&e.componentInstance&&e.componentInstance!==h.instances[u]&&(h.instances[u]=e.componentInstance),Eu(o)};var b=h.props&&h.props[u];return b&&(fu(d[u],{route:o,configProps:b}),Lu(f,i,o,b)),r(f,i,a)}};function Lu(e,t,n,a){var s=t.props=function(e,t){switch(typeof t){case"undefined":return;case"object":return t;case"function":return t(e);case"boolean":return t?e.params:void 0}}(n,a);if(s){s=t.props=fu({},s);var i=t.attrs=t.attrs||{};for(var r in s)e.props&&r in e.props||(i[r]=s[r],delete s[r])}}function Du(e,t,n){var a=e.charAt(0);if("/"===a)return e;if("?"===a||"#"===a)return t+e;var s=t.split("/");n&&s[s.length-1]||s.pop();for(var i=e.replace(/^\//,"").split("/"),r=0;r<i.length;r++){var u=i[r];".."===u?s.pop():"."!==u&&s.push(u)}return""!==s[0]&&s.unshift(""),s.join("/")}function $u(e){return e.replace(/\/+/g,"/")}var Bu=Array.isArray||function(e){return"[object Array]"==Object.prototype.toString.call(e)},Nu=function e(t,n,a){return Bu(n)||(a=n||a,n=[]),a=a||{},t instanceof RegExp?function(e,t){var n=e.source.match(/\((?!\?)/g);if(n)for(var a=0;a<n.length;a++)t.push({name:a,prefix:null,delimiter:null,optional:!1,repeat:!1,partial:!1,asterisk:!1,pattern:null});return Ku(e,t)}(t,n):Bu(t)?function(t,n,a){for(var s=[],i=0;i<t.length;i++)s.push(e(t[i],n,a).source);return Ku(new RegExp("(?:"+s.join("|")+")",Zu(a)),n)}(t,n,a):function(e,t,n){return Xu(Gu(e,n),t,n)}(t,n,a)},ju=Gu,Fu=Ju,Wu=Xu,zu=new RegExp(["(\\\\.)","([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"].join("|"),"g");function Gu(e,t){for(var n,a=[],s=0,i=0,r="",u=t&&t.delimiter||"/";null!=(n=zu.exec(e));){var o=n[0],d=n[1],p=n.index;if(r+=e.slice(i,p),i=p+o.length,d)r+=d[1];else{var l=e[i],m=n[2],y=n[3],c=n[4],h=n[5],f=n[6],b=n[7];r&&(a.push(r),r="");var v=null!=m&&null!=l&&l!==m,T="+"===f||"*"===f,g="?"===f||"*"===f,w=n[2]||u,R=c||h;a.push({name:y||s++,prefix:m||"",delimiter:w,optional:g,repeat:T,partial:v,asterisk:!!b,pattern:R?Yu(R):b?".*":"[^"+Hu(w)+"]+?"})}}return i<e.length&&(r+=e.substr(i)),r&&a.push(r),a}function qu(e){return encodeURI(e).replace(/[\/?#]/g,(function(e){return"%"+e.charCodeAt(0).toString(16).toUpperCase()}))}function Vu(e){return encodeURI(e).replace(/[?#]/g,(function(e){return"%"+e.charCodeAt(0).toString(16).toUpperCase()}))}function Ju(e,t){for(var n=new Array(e.length),a=0;a<e.length;a++)"object"==typeof e[a]&&(n[a]=new RegExp("^(?:"+e[a].pattern+")$",Zu(t)));return function(t,a){for(var s="",i=t||{},r=(a||{}).pretty?qu:encodeURIComponent,u=0;u<e.length;u++){var o=e[u];if("string"!=typeof o){var d,p=i[o.name];if(null==p){if(o.optional){o.partial&&(s+=o.prefix);continue}throw new TypeError('Expected "'+o.name+'" to be defined')}if(Bu(p)){if(!o.repeat)throw new TypeError('Expected "'+o.name+'" to not repeat, but received `'+JSON.stringify(p)+"`");if(0===p.length){if(o.optional)continue;throw new TypeError('Expected "'+o.name+'" to not be empty')}for(var l=0;l<p.length;l++){if(d=r(p[l]),!n[u].test(d))throw new TypeError('Expected all "'+o.name+'" to match "'+o.pattern+'", but received `'+JSON.stringify(d)+"`");s+=(0===l?o.prefix:o.delimiter)+d}}else{if(d=o.asterisk?Vu(p):r(p),!n[u].test(d))throw new TypeError('Expected "'+o.name+'" to match "'+o.pattern+'", but received "'+d+'"');s+=o.prefix+d}}else s+=o}return s}}function Hu(e){return e.replace(/([.+*?=^!:${}()[\]|\/\\])/g,"\\$1")}function Yu(e){return e.replace(/([=!:$\/()])/g,"\\$1")}function Ku(e,t){return e.keys=t,e}function Zu(e){return e&&e.sensitive?"":"i"}function Xu(e,t,n){Bu(t)||(n=t||n,t=[]);for(var a=(n=n||{}).strict,s=!1!==n.end,i="",r=0;r<e.length;r++){var u=e[r];if("string"==typeof u)i+=Hu(u);else{var o=Hu(u.prefix),d="(?:"+u.pattern+")";t.push(u),u.repeat&&(d+="(?:"+o+d+")*"),i+=d=u.optional?u.partial?o+"("+d+")?":"(?:"+o+"("+d+"))?":o+"("+d+")"}}var p=Hu(n.delimiter||"/"),l=i.slice(-p.length)===p;return a||(i=(l?i.slice(0,-p.length):i)+"(?:"+p+"(?=$))?"),i+=s?"$":a&&l?"":"(?="+p+"|$)",Ku(new RegExp("^"+i,Zu(n)),t)}Nu.parse=ju,Nu.compile=function(e,t){return Ju(Gu(e,t),t)},Nu.tokensToFunction=Fu,Nu.tokensToRegExp=Wu;var Qu=Object.create(null);function eo(e,t,n){t=t||{};try{var a=Qu[e]||(Qu[e]=Nu.compile(e));return"string"==typeof t.pathMatch&&(t[0]=t.pathMatch),a(t,{pretty:!0})}catch(e){return""}finally{delete t[0]}}function to(e,t,n,a){var s="string"==typeof e?{path:e}:e;if(s._normalized)return s;if(s.name){var i=(s=fu({},e)).params;return i&&"object"==typeof i&&(s.params=fu({},i)),s}if(!s.path&&s.params&&t){(s=fu({},s))._normalized=!0;var r=fu(fu({},t.params),s.params);if(t.name)s.name=t.name,s.params=r;else if(t.matched.length){var u=t.matched[t.matched.length-1].path;s.path=eo(u,r,t.path)}return s}var o=function(e){var t="",n="",a=e.indexOf("#");a>=0&&(t=e.slice(a),e=e.slice(0,a));var s=e.indexOf("?");return s>=0&&(n=e.slice(s+1),e=e.slice(0,s)),{path:e,query:n,hash:t}}(s.path||""),d=t&&t.path||"/",p=o.path?Du(o.path,d,n||s.append):d,l=function(e,t,n){void 0===t&&(t={});var a,s=n||Au;try{a=s(e||"")}catch(e){a={}}for(var i in t){var r=t[i];a[i]=Array.isArray(r)?r.map(Ru):Ru(r)}return a}(o.query,s.query,a&&a.options.parseQuery),m=s.hash||o.hash;return m&&"#"!==m.charAt(0)&&(m="#"+m),{_normalized:!0,path:p,query:l,hash:m}}var no,ao=function(){},so={name:"RouterLink",props:{to:{type:[String,Object],required:!0},tag:{type:String,default:"a"},custom:Boolean,exact:Boolean,exactPath:Boolean,append:Boolean,replace:Boolean,activeClass:String,exactActiveClass:String,ariaCurrentValue:{type:String,default:"page"},event:{type:[String,Array],default:"click"}},render:function(e){var t=this,n=this.$router,a=this.$route,s=n.resolve(this.to,a,this.append),i=s.location,r=s.route,u=s.href,o={},d=n.options.linkActiveClass,p=n.options.linkExactActiveClass,l=null==d?"router-link-active":d,m=null==p?"router-link-exact-active":p,y=null==this.activeClass?l:this.activeClass,c=null==this.exactActiveClass?m:this.exactActiveClass,h=r.redirectedFrom?_u(null,to(r.redirectedFrom),null,n):r;o[c]=Cu(a,h,this.exactPath),o[y]=this.exact||this.exactPath?o[c]:function(e,t){return 0===e.path.replace(xu,"/").indexOf(t.path.replace(xu,"/"))&&(!t.hash||e.hash===t.hash)&&function(e,t){for(var n in t)if(!(n in e))return!1;return!0}(e.query,t.query)}(a,h);var f=o[c]?this.ariaCurrentValue:null,b=function(e){io(e)&&(t.replace?n.replace(i,ao):n.push(i,ao))},v={click:io};Array.isArray(this.event)?this.event.forEach((function(e){v[e]=b})):v[this.event]=b;var T={class:o},g=!this.$scopedSlots.$hasNormal&&this.$scopedSlots.default&&this.$scopedSlots.default({href:u,route:r,navigate:b,isActive:o[y],isExactActive:o[c]});if(g){if(1===g.length)return g[0];if(g.length>1||!g.length)return 0===g.length?e():e("span",{},g)}if("a"===this.tag)T.on=v,T.attrs={href:u,"aria-current":f};else{var w=ro(this.$slots.default);if(w){w.isStatic=!1;var R=w.data=fu({},w.data);for(var A in R.on=R.on||{},R.on){var k=R.on[A];A in v&&(R.on[A]=Array.isArray(k)?k:[k])}for(var x in v)x in R.on?R.on[x].push(v[x]):R.on[x]=b;var _=w.data.attrs=fu({},w.data.attrs);_.href=u,_["aria-current"]=f}else T.on=v}return e(this.tag,T,this.$slots.default)}};function io(e){if(!(e.metaKey||e.altKey||e.ctrlKey||e.shiftKey||e.defaultPrevented||void 0!==e.button&&0!==e.button)){if(e.currentTarget&&e.currentTarget.getAttribute){var t=e.currentTarget.getAttribute("target");if(/\b_blank\b/i.test(t))return}return e.preventDefault&&e.preventDefault(),!0}}function ro(e){if(e)for(var t,n=0;n<e.length;n++){if("a"===(t=e[n]).tag)return t;if(t.children&&(t=ro(t.children)))return t}}var uo="undefined"!=typeof window;function oo(e,t,n,a,s){var i=t||[],r=n||Object.create(null),u=a||Object.create(null);e.forEach((function(e){po(i,r,u,e,s)}));for(var o=0,d=i.length;o<d;o++)"*"===i[o]&&(i.push(i.splice(o,1)[0]),d--,o--);return{pathList:i,pathMap:r,nameMap:u}}function po(e,t,n,a,s,i){var r=a.path,u=a.name,o=a.pathToRegexpOptions||{},d=function(e,t,n){return n||(e=e.replace(/\/$/,"")),"/"===e[0]||null==t?e:$u(t.path+"/"+e)}(r,s,o.strict);"boolean"==typeof a.caseSensitive&&(o.sensitive=a.caseSensitive);var p={path:d,regex:lo(d,o),components:a.components||{default:a.component},alias:a.alias?"string"==typeof a.alias?[a.alias]:a.alias:[],instances:{},enteredCbs:{},name:u,parent:s,matchAs:i,redirect:a.redirect,beforeEnter:a.beforeEnter,meta:a.meta||{},props:null==a.props?{}:a.components?a.props:{default:a.props}};if(a.children&&a.children.forEach((function(a){var s=i?$u(i+"/"+a.path):void 0;po(e,t,n,a,p,s)})),t[p.path]||(e.push(p.path),t[p.path]=p),void 0!==a.alias)for(var l=Array.isArray(a.alias)?a.alias:[a.alias],m=0;m<l.length;++m){var y={path:l[m],children:a.children};po(e,t,n,y,s,p.path||"/")}u&&(n[u]||(n[u]=p))}function lo(e,t){return Nu(e,[],t)}function mo(e,t){var n=oo(e),a=n.pathList,s=n.pathMap,i=n.nameMap;function r(e,n,r){var o=to(e,n,!1,t),d=o.name;if(d){var p=i[d];if(!p)return u(null,o);var l=p.regex.keys.filter((function(e){return!e.optional})).map((function(e){return e.name}));if("object"!=typeof o.params&&(o.params={}),n&&"object"==typeof n.params)for(var m in n.params)!(m in o.params)&&l.indexOf(m)>-1&&(o.params[m]=n.params[m]);return o.path=eo(p.path,o.params),u(p,o,r)}if(o.path){o.params={};for(var y=0;y<a.length;y++){var c=a[y],h=s[c];if(yo(h.regex,o.path,o.params))return u(h,o,r)}}return u(null,o)}function u(e,n,a){return e&&e.redirect?function(e,n){var a=e.redirect,s="function"==typeof a?a(_u(e,n,null,t)):a;if("string"==typeof s&&(s={path:s}),!s||"object"!=typeof s)return u(null,n);var o=s,d=o.name,p=o.path,l=n.query,m=n.hash,y=n.params;if(l=o.hasOwnProperty("query")?o.query:l,m=o.hasOwnProperty("hash")?o.hash:m,y=o.hasOwnProperty("params")?o.params:y,d)return i[d],r({_normalized:!0,name:d,query:l,hash:m,params:y},void 0,n);if(p){var c=function(e,t){return Du(e,t.parent?t.parent.path:"/",!0)}(p,e);return r({_normalized:!0,path:eo(c,y),query:l,hash:m},void 0,n)}return u(null,n)}(e,a||n):e&&e.matchAs?function(e,t,n){var a=r({_normalized:!0,path:eo(n,t.params)});if(a){var s=a.matched,i=s[s.length-1];return t.params=a.params,u(i,t)}return u(null,t)}(0,n,e.matchAs):_u(e,n,a,t)}return{match:r,addRoute:function(e,t){var n="object"!=typeof e?i[e]:void 0;oo([t||e],a,s,i,n),n&&n.alias.length&&oo(n.alias.map((function(e){return{path:e,children:[t]}})),a,s,i,n)},getRoutes:function(){return a.map((function(e){return s[e]}))},addRoutes:function(e){oo(e,a,s,i)}}}function yo(e,t,n){var a=t.match(e);if(!a)return!1;if(!n)return!0;for(var s=1,i=a.length;s<i;++s){var r=e.keys[s-1];r&&(n[r.name||"pathMatch"]="string"==typeof a[s]?wu(a[s]):a[s])}return!0}var co=uo&&window.performance&&window.performance.now?window.performance:Date;function ho(){return co.now().toFixed(3)}var fo=ho();function bo(){return fo}function vo(e){return fo=e}var To=Object.create(null);function go(){"scrollRestoration"in window.history&&(window.history.scrollRestoration="manual");var e=window.location.protocol+"//"+window.location.host,t=window.location.href.replace(e,""),n=fu({},window.history.state);return n.key=bo(),window.history.replaceState(n,"",t),window.addEventListener("popstate",Ao),function(){window.removeEventListener("popstate",Ao)}}function wo(e,t,n,a){if(e.app){var s=e.options.scrollBehavior;s&&e.app.$nextTick((function(){var i=function(){var e=bo();if(e)return To[e]}(),r=s.call(e,t,n,a?i:null);r&&("function"==typeof r.then?r.then((function(e){Mo(e,i)})).catch((function(e){})):Mo(r,i))}))}}function Ro(){var e=bo();e&&(To[e]={x:window.pageXOffset,y:window.pageYOffset})}function Ao(e){Ro(),e.state&&e.state.key&&vo(e.state.key)}function ko(e){return _o(e.x)||_o(e.y)}function xo(e){return{x:_o(e.x)?e.x:window.pageXOffset,y:_o(e.y)?e.y:window.pageYOffset}}function _o(e){return"number"==typeof e}var So=/^#\d/;function Mo(e,t){var n,a="object"==typeof e;if(a&&"string"==typeof e.selector){var s=So.test(e.selector)?document.getElementById(e.selector.slice(1)):document.querySelector(e.selector);if(s){var i=e.offset&&"object"==typeof e.offset?e.offset:{};t=function(e,t){var n=document.documentElement.getBoundingClientRect(),a=e.getBoundingClientRect();return{x:a.left-n.left-t.x,y:a.top-n.top-t.y}}(s,i={x:_o((n=i).x)?n.x:0,y:_o(n.y)?n.y:0})}else ko(e)&&(t=xo(e))}else a&&ko(e)&&(t=xo(e));t&&("scrollBehavior"in document.documentElement.style?window.scrollTo({left:t.x,top:t.y,behavior:e.behavior}):window.scrollTo(t.x,t.y))}var Oo,Io=uo&&(-1===(Oo=window.navigator.userAgent).indexOf("Android 2.")&&-1===Oo.indexOf("Android 4.0")||-1===Oo.indexOf("Mobile Safari")||-1!==Oo.indexOf("Chrome")||-1!==Oo.indexOf("Windows Phone"))&&window.history&&"function"==typeof window.history.pushState;function Co(e,t){Ro();var n=window.history;try{if(t){var a=fu({},n.state);a.key=bo(),n.replaceState(a,"",e)}else n.pushState({key:vo(ho())},"",e)}catch(n){window.location[t?"replace":"assign"](e)}}function Uo(e){Co(e,!0)}function Eo(e,t,n){var a=function(s){s>=e.length?n():e[s]?t(e[s],(function(){a(s+1)})):a(s+1)};a(0)}var Po={redirected:2,aborted:4,cancelled:8,duplicated:16};function Lo(e,t){return Do(e,t,Po.cancelled,'Navigation cancelled from "'+e.fullPath+'" to "'+t.fullPath+'" with a new navigation.')}function Do(e,t,n,a){var s=new Error(a);return s._isRouter=!0,s.from=e,s.to=t,s.type=n,s}var $o=["params","query","hash"];function Bo(e){return Object.prototype.toString.call(e).indexOf("Error")>-1}function No(e,t){return Bo(e)&&e._isRouter&&(null==t||e.type===t)}function jo(e,t){return Fo(e.map((function(e){return Object.keys(e.components).map((function(n){return t(e.components[n],e.instances[n],e,n)}))})))}function Fo(e){return Array.prototype.concat.apply([],e)}var Wo="function"==typeof Symbol&&"symbol"==typeof Symbol.toStringTag;function zo(e){var t=!1;return function(){for(var n=[],a=arguments.length;a--;)n[a]=arguments[a];if(!t)return t=!0,e.apply(this,n)}}var Go=function(e,t){this.router=e,this.base=function(e){if(!e)if(uo){var t=document.querySelector("base");e=(e=t&&t.getAttribute("href")||"/").replace(/^https?:\/\/[^\/]+/,"")}else e="/";return"/"!==e.charAt(0)&&(e="/"+e),e.replace(/\/$/,"")}(t),this.current=Mu,this.pending=null,this.ready=!1,this.readyCbs=[],this.readyErrorCbs=[],this.errorCbs=[],this.listeners=[]};function qo(e,t,n,a){var s=jo(e,(function(e,a,s,i){var r=function(e,t){return"function"!=typeof e&&(e=no.extend(e)),e.options[t]}(e,t);if(r)return Array.isArray(r)?r.map((function(e){return n(e,a,s,i)})):n(r,a,s,i)}));return Fo(a?s.reverse():s)}function Vo(e,t){if(t)return function(){return e.apply(t,arguments)}}Go.prototype.listen=function(e){this.cb=e},Go.prototype.onReady=function(e,t){this.ready?e():(this.readyCbs.push(e),t&&this.readyErrorCbs.push(t))},Go.prototype.onError=function(e){this.errorCbs.push(e)},Go.prototype.transitionTo=function(e,t,n){var a,s=this;try{a=this.router.match(e,this.current)}catch(e){throw this.errorCbs.forEach((function(t){t(e)})),e}var i=this.current;this.confirmTransition(a,(function(){s.updateRoute(a),t&&t(a),s.ensureURL(),s.router.afterHooks.forEach((function(e){e&&e(a,i)})),s.ready||(s.ready=!0,s.readyCbs.forEach((function(e){e(a)})))}),(function(e){n&&n(e),e&&!s.ready&&(No(e,Po.redirected)&&i===Mu||(s.ready=!0,s.readyErrorCbs.forEach((function(t){t(e)}))))}))},Go.prototype.confirmTransition=function(e,t,n){var a=this,s=this.current;this.pending=e;var i,r,u=function(e){!No(e)&&Bo(e)&&(a.errorCbs.length?a.errorCbs.forEach((function(t){t(e)})):console.error(e)),n&&n(e)},o=e.matched.length-1,d=s.matched.length-1;if(Cu(e,s)&&o===d&&e.matched[o]===s.matched[d])return this.ensureURL(),e.hash&&wo(this.router,s,e,!1),u(((r=Do(i=s,e,Po.duplicated,'Avoided redundant navigation to current location: "'+i.fullPath+'".')).name="NavigationDuplicated",r));var p,l=function(e,t){var n,a=Math.max(e.length,t.length);for(n=0;n<a&&e[n]===t[n];n++);return{updated:t.slice(0,n),activated:t.slice(n),deactivated:e.slice(n)}}(this.current.matched,e.matched),m=l.updated,y=l.deactivated,c=l.activated,h=[].concat(function(e){return qo(e,"beforeRouteLeave",Vo,!0)}(y),this.router.beforeHooks,function(e){return qo(e,"beforeRouteUpdate",Vo)}(m),c.map((function(e){return e.beforeEnter})),(p=c,function(e,t,n){var a=!1,s=0,i=null;jo(p,(function(e,t,r,u){if("function"==typeof e&&void 0===e.cid){a=!0,s++;var o,d=zo((function(t){var a;((a=t).__esModule||Wo&&"Module"===a[Symbol.toStringTag])&&(t=t.default),e.resolved="function"==typeof t?t:no.extend(t),r.components[u]=t,--s<=0&&n()})),p=zo((function(e){var t="Failed to resolve async component "+u+": "+e;i||(i=Bo(e)?e:new Error(t),n(i))}));try{o=e(d,p)}catch(e){p(e)}if(o)if("function"==typeof o.then)o.then(d,p);else{var l=o.component;l&&"function"==typeof l.then&&l.then(d,p)}}})),a||n()})),f=function(t,n){if(a.pending!==e)return u(Lo(s,e));try{t(e,s,(function(t){!1===t?(a.ensureURL(!0),u(function(e,t){return Do(e,t,Po.aborted,'Navigation aborted from "'+e.fullPath+'" to "'+t.fullPath+'" via a navigation guard.')}(s,e))):Bo(t)?(a.ensureURL(!0),u(t)):"string"==typeof t||"object"==typeof t&&("string"==typeof t.path||"string"==typeof t.name)?(u(function(e,t){return Do(e,t,Po.redirected,'Redirected when going from "'+e.fullPath+'" to "'+function(e){if("string"==typeof e)return e;if("path"in e)return e.path;var t={};return $o.forEach((function(n){n in e&&(t[n]=e[n])})),JSON.stringify(t,null,2)}(t)+'" via a navigation guard.')}(s,e)),"object"==typeof t&&t.replace?a.replace(t):a.push(t)):n(t)}))}catch(e){u(e)}};Eo(h,f,(function(){var n=function(e){return qo(e,"beforeRouteEnter",(function(e,t,n,a){return function(e,t,n){return function(a,s,i){return e(a,s,(function(e){"function"==typeof e&&(t.enteredCbs[n]||(t.enteredCbs[n]=[]),t.enteredCbs[n].push(e)),i(e)}))}}(e,n,a)}))}(c);Eo(n.concat(a.router.resolveHooks),f,(function(){if(a.pending!==e)return u(Lo(s,e));a.pending=null,t(e),a.router.app&&a.router.app.$nextTick((function(){Eu(e)}))}))}))},Go.prototype.updateRoute=function(e){this.current=e,this.cb&&this.cb(e)},Go.prototype.setupListeners=function(){},Go.prototype.teardown=function(){this.listeners.forEach((function(e){e()})),this.listeners=[],this.current=Mu,this.pending=null};var Jo=function(e){function t(t,n){e.call(this,t,n),this._startLocation=Ho(this.base)}return e&&(t.__proto__=e),t.prototype=Object.create(e&&e.prototype),t.prototype.constructor=t,t.prototype.setupListeners=function(){var e=this;if(!(this.listeners.length>0)){var t=this.router,n=t.options.scrollBehavior,a=Io&&n;a&&this.listeners.push(go());var s=function(){var n=e.current,s=Ho(e.base);e.current===Mu&&s===e._startLocation||e.transitionTo(s,(function(e){a&&wo(t,e,n,!0)}))};window.addEventListener("popstate",s),this.listeners.push((function(){window.removeEventListener("popstate",s)}))}},t.prototype.go=function(e){window.history.go(e)},t.prototype.push=function(e,t,n){var a=this,s=this.current;this.transitionTo(e,(function(e){Co($u(a.base+e.fullPath)),wo(a.router,e,s,!1),t&&t(e)}),n)},t.prototype.replace=function(e,t,n){var a=this,s=this.current;this.transitionTo(e,(function(e){Uo($u(a.base+e.fullPath)),wo(a.router,e,s,!1),t&&t(e)}),n)},t.prototype.ensureURL=function(e){if(Ho(this.base)!==this.current.fullPath){var t=$u(this.base+this.current.fullPath);e?Co(t):Uo(t)}},t.prototype.getCurrentLocation=function(){return Ho(this.base)},t}(Go);function Ho(e){var t=window.location.pathname,n=t.toLowerCase(),a=e.toLowerCase();return!e||n!==a&&0!==n.indexOf($u(a+"/"))||(t=t.slice(e.length)),(t||"/")+window.location.search+window.location.hash}var Yo=function(e){function t(t,n,a){e.call(this,t,n),a&&function(e){var t=Ho(e);if(!/^\/#/.test(t))return window.location.replace($u(e+"/#"+t)),!0}(this.base)||Ko()}return e&&(t.__proto__=e),t.prototype=Object.create(e&&e.prototype),t.prototype.constructor=t,t.prototype.setupListeners=function(){var e=this;if(!(this.listeners.length>0)){var t=this.router.options.scrollBehavior,n=Io&&t;n&&this.listeners.push(go());var a=function(){var t=e.current;Ko()&&e.transitionTo(Zo(),(function(a){n&&wo(e.router,a,t,!0),Io||ed(a.fullPath)}))},s=Io?"popstate":"hashchange";window.addEventListener(s,a),this.listeners.push((function(){window.removeEventListener(s,a)}))}},t.prototype.push=function(e,t,n){var a=this,s=this.current;this.transitionTo(e,(function(e){Qo(e.fullPath),wo(a.router,e,s,!1),t&&t(e)}),n)},t.prototype.replace=function(e,t,n){var a=this,s=this.current;this.transitionTo(e,(function(e){ed(e.fullPath),wo(a.router,e,s,!1),t&&t(e)}),n)},t.prototype.go=function(e){window.history.go(e)},t.prototype.ensureURL=function(e){var t=this.current.fullPath;Zo()!==t&&(e?Qo(t):ed(t))},t.prototype.getCurrentLocation=function(){return Zo()},t}(Go);function Ko(){var e=Zo();return"/"===e.charAt(0)||(ed("/"+e),!1)}function Zo(){var e=window.location.href,t=e.indexOf("#");return t<0?"":e=e.slice(t+1)}function Xo(e){var t=window.location.href,n=t.indexOf("#");return(n>=0?t.slice(0,n):t)+"#"+e}function Qo(e){Io?Co(Xo(e)):window.location.hash=e}function ed(e){Io?Uo(Xo(e)):window.location.replace(Xo(e))}var td=function(e){function t(t,n){e.call(this,t,n),this.stack=[],this.index=-1}return e&&(t.__proto__=e),t.prototype=Object.create(e&&e.prototype),t.prototype.constructor=t,t.prototype.push=function(e,t,n){var a=this;this.transitionTo(e,(function(e){a.stack=a.stack.slice(0,a.index+1).concat(e),a.index++,t&&t(e)}),n)},t.prototype.replace=function(e,t,n){var a=this;this.transitionTo(e,(function(e){a.stack=a.stack.slice(0,a.index).concat(e),t&&t(e)}),n)},t.prototype.go=function(e){var t=this,n=this.index+e;if(!(n<0||n>=this.stack.length)){var a=this.stack[n];this.confirmTransition(a,(function(){var e=t.current;t.index=n,t.updateRoute(a),t.router.afterHooks.forEach((function(t){t&&t(a,e)}))}),(function(e){No(e,Po.duplicated)&&(t.index=n)}))}},t.prototype.getCurrentLocation=function(){var e=this.stack[this.stack.length-1];return e?e.fullPath:"/"},t.prototype.ensureURL=function(){},t}(Go),nd=function(e){void 0===e&&(e={}),this.app=null,this.apps=[],this.options=e,this.beforeHooks=[],this.resolveHooks=[],this.afterHooks=[],this.matcher=mo(e.routes||[],this);var t=e.mode||"hash";switch(this.fallback="history"===t&&!Io&&!1!==e.fallback,this.fallback&&(t="hash"),uo||(t="abstract"),this.mode=t,t){case"history":this.history=new Jo(this,e.base);break;case"hash":this.history=new Yo(this,e.base,this.fallback);break;case"abstract":this.history=new td(this,e.base)}},ad={currentRoute:{configurable:!0}};function sd(e,t){return e.push(t),function(){var n=e.indexOf(t);n>-1&&e.splice(n,1)}}nd.prototype.match=function(e,t,n){return this.matcher.match(e,t,n)},ad.currentRoute.get=function(){return this.history&&this.history.current},nd.prototype.init=function(e){var t=this;if(this.apps.push(e),e.$once("hook:destroyed",(function(){var n=t.apps.indexOf(e);n>-1&&t.apps.splice(n,1),t.app===e&&(t.app=t.apps[0]||null),t.app||t.history.teardown()})),!this.app){this.app=e;var n=this.history;if(n instanceof Jo||n instanceof Yo){var a=function(e){n.setupListeners(),function(e){var a=n.current,s=t.options.scrollBehavior;Io&&s&&"fullPath"in e&&wo(t,e,a,!1)}(e)};n.transitionTo(n.getCurrentLocation(),a,a)}n.listen((function(e){t.apps.forEach((function(t){t._route=e}))}))}},nd.prototype.beforeEach=function(e){return sd(this.beforeHooks,e)},nd.prototype.beforeResolve=function(e){return sd(this.resolveHooks,e)},nd.prototype.afterEach=function(e){return sd(this.afterHooks,e)},nd.prototype.onReady=function(e,t){this.history.onReady(e,t)},nd.prototype.onError=function(e){this.history.onError(e)},nd.prototype.push=function(e,t,n){var a=this;if(!t&&!n&&"undefined"!=typeof Promise)return new Promise((function(t,n){a.history.push(e,t,n)}));this.history.push(e,t,n)},nd.prototype.replace=function(e,t,n){var a=this;if(!t&&!n&&"undefined"!=typeof Promise)return new Promise((function(t,n){a.history.replace(e,t,n)}));this.history.replace(e,t,n)},nd.prototype.go=function(e){this.history.go(e)},nd.prototype.back=function(){this.go(-1)},nd.prototype.forward=function(){this.go(1)},nd.prototype.getMatchedComponents=function(e){var t=e?e.matched?e:this.resolve(e).route:this.currentRoute;return t?[].concat.apply([],t.matched.map((function(e){return Object.keys(e.components).map((function(t){return e.components[t]}))}))):[]},nd.prototype.resolve=function(e,t,n){var a=to(e,t=t||this.history.current,n,this),s=this.match(a,t),i=s.redirectedFrom||s.fullPath,r=function(e,t,n){var a="hash"===n?"#"+t:t;return e?$u(e+"/"+a):a}(this.history.base,i,this.mode);return{location:a,route:s,href:r,normalizedTo:a,resolved:s}},nd.prototype.getRoutes=function(){return this.matcher.getRoutes()},nd.prototype.addRoute=function(e,t){this.matcher.addRoute(e,t),this.history.current!==Mu&&this.history.transitionTo(this.history.getCurrentLocation())},nd.prototype.addRoutes=function(e){this.matcher.addRoutes(e),this.history.current!==Mu&&this.history.transitionTo(this.history.getCurrentLocation())},Object.defineProperties(nd.prototype,ad),nd.install=function e(t){if(!e.installed||no!==t){e.installed=!0,no=t;var n=function(e){return void 0!==e},a=function(e,t){var a=e.$options._parentVnode;n(a)&&n(a=a.data)&&n(a=a.registerRouteInstance)&&a(e,t)};t.mixin({beforeCreate:function(){n(this.$options.router)?(this._routerRoot=this,this._router=this.$options.router,this._router.init(this),t.util.defineReactive(this,"_route",this._router.history.current)):this._routerRoot=this.$parent&&this.$parent._routerRoot||this,a(this,this)},destroyed:function(){a(this)}}),Object.defineProperty(t.prototype,"$router",{get:function(){return this._routerRoot._router}}),Object.defineProperty(t.prototype,"$route",{get:function(){return this._routerRoot._route}}),t.component("RouterView",Pu),t.component("RouterLink",so);var s=t.config.optionMergeStrategies;s.beforeRouteEnter=s.beforeRouteLeave=s.beforeRouteUpdate=s.created}},nd.version="3.5.3",nd.isNavigationFailure=No,nd.NavigationFailureType=Po,nd.START_LOCATION=Mu,uo&&window.Vue&&window.Vue.use(nd);const id=nd;var rd=function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"min-h-screen bg-gray-100 px-4 pt-6"},[t("router-view")],1)};function ud(e,t,n,a,s,i,r,u){var o,d="function"==typeof e?e.options:e;if(t&&(d.render=t,d.staticRenderFns=n,d._compiled=!0),a&&(d.functional=!0),i&&(d._scopeId="data-v-"+i),r?(o=function(e){(e=e||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext)||"undefined"==typeof __VUE_SSR_CONTEXT__||(e=__VUE_SSR_CONTEXT__),s&&s.call(this,e),e&&e._registeredComponents&&e._registeredComponents.add(r)},d._ssrRegister=o):s&&(o=u?function(){s.call(this,(d.functional?this.parent:this).$root.$options.shadowRoot)}:s),o)if(d.functional){d._injectStyles=o;var p=d.render;d.render=function(e,t){return o.call(t),p(e,t)}}else{var l=d.beforeCreate;d.beforeCreate=l?[].concat(l,o):[o]}return{exports:e,options:d}}rd._withStripped=!0,n(387);var od=ud({},rd,[],!1,null,null,null);od.options.__file="node_modules/hardhat-docgen/src/App.vue";const dd=od.exports;var pd=function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("div",{staticClass:"w-full space-y-10 md:max-w-screen-sm lg:max-w-screen-md mx-auto"},[n("HeaderBar"),e._v(" "),n("div",{staticClass:"pb-32"},[n("div",{staticClass:"space-y-4"},[n("span",{staticClass:"text-lg"},[e._v("\n        "+e._s(e.json.source)+"\n      ")]),e._v(" "),n("h1",{staticClass:"text-xl"},[e._v("\n        "+e._s(e.json.name)+"\n      ")]),e._v(" "),n("h2",{staticClass:"text-lg"},[e._v("\n        "+e._s(e.json.title)+"\n      ")]),e._v(" "),n("h2",{staticClass:"text-lg"},[e._v("\n        "+e._s(e.json.author)+"\n      ")]),e._v(" "),n("p",[e._v(e._s(e.json.notice))]),e._v(" "),n("p",[e._v(e._s(e.json.details))])]),e._v(" "),n("div",{staticClass:"mt-8"},[e.json.hasOwnProperty("constructor")?n("Member",{attrs:{json:e.json.constructor}}):e._e()],1),e._v(" "),n("div",{staticClass:"mt-8"},[e.json.receive?n("Member",{attrs:{json:e.json.receive}}):e._e()],1),e._v(" "),n("div",{staticClass:"mt-8"},[e.json.fallback?n("Member",{attrs:{json:e.json.fallback}}):e._e()],1),e._v(" "),e.json.events?n("MemberSet",{attrs:{title:"Events",json:e.json.events}}):e._e(),e._v(" "),e.json.stateVariables?n("MemberSet",{attrs:{title:"State Variables",json:e.json.stateVariables}}):e._e(),e._v(" "),e.json.methods?n("MemberSet",{attrs:{title:"Methods",json:e.json.methods}}):e._e()],1),e._v(" "),n("FooterBar")],1)};pd._withStripped=!0;var ld=function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("div",{staticClass:"bg-gray-100 fixed bottom-0 right-0 w-full border-t border-dashed border-gray-300"},[n("div",{staticClass:"w-full text-center py-2 md:max-w-screen-sm lg:max-w-screen-md mx-auto"},[n("button",{staticClass:"py-1 px-2 text-gray-500",on:{click:function(t){return e.openLink(e.repository)}}},[e._v("\n      built with "+e._s(e.name)+"\n    ")])])])};ld._withStripped=!0;const md=JSON.parse('{"u2":"hardhat-docgen","cj":"https://github.com/ItsNickBarry/hardhat-docgen"}');var yd=ud({data:function(){return{repository:md.cj,name:md.u2}},methods:{openLink(e){window.open(e,"_blank")}}},ld,[],!1,null,null,null);yd.options.__file="node_modules/hardhat-docgen/src/components/FooterBar.vue";const cd=yd.exports;var hd=function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("div",{staticClass:"w-full border-b border-dashed py-2 border-gray-300"},[n("router-link",{staticClass:"py-2 text-gray-500",attrs:{to:"/"}},[e._v("\n    <- Go back\n  ")])],1)};hd._withStripped=!0;var fd=ud({},hd,[],!1,null,null,null);fd.options.__file="node_modules/hardhat-docgen/src/components/HeaderBar.vue";const bd=fd.exports;var vd=function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("div",{staticClass:"border-2 border-gray-400 border-dashed w-full p-2"},[n("h3",{staticClass:"text-lg pb-2 mb-2 border-b-2 border-gray-400 border-dashed"},[e._v("\n    "+e._s(e.name)+" "+e._s(e.keywords)+" "+e._s(e.inputSignature)+"\n  ")]),e._v(" "),n("div",{staticClass:"space-y-3"},[n("p",[e._v(e._s(e.json.notice))]),e._v(" "),n("p",[e._v(e._s(e.json.details))]),e._v(" "),n("MemberSection",{attrs:{name:"Parameters",items:e.inputs}}),e._v(" "),n("MemberSection",{attrs:{name:"Return Values",items:e.outputs}})],1)])};vd._withStripped=!0;var Td=function(){var e=this,t=e.$createElement,n=e._self._c||t;return e.items.length>0?n("ul",[n("h4",{staticClass:"text-lg"},[e._v("\n    "+e._s(e.name)+"\n  ")]),e._v(" "),e._l(e.items,(function(t,a){return n("li",{key:a},[n("span",{staticClass:"bg-gray-300"},[e._v(e._s(t.type))]),e._v(" "),n("b",[e._v(e._s(t.name||"_"+a))]),t.desc?n("span",[e._v(": "),n("i",[e._v(e._s(t.desc))])]):e._e()])}))],2):e._e()};Td._withStripped=!0;var gd=ud({props:{name:{type:String,default:""},items:{type:Array,default:()=>new Array}}},Td,[],!1,null,null,null);gd.options.__file="node_modules/hardhat-docgen/src/components/MemberSection.vue";const wd={components:{MemberSection:gd.exports},props:{json:{type:Object,default:()=>new Object}},computed:{name:function(){return this.json.name||this.json.type},keywords:function(){let e=[];return this.json.stateMutability&&e.push(this.json.stateMutability),"true"===this.json.anonymous&&e.push("anonymous"),e.join(" ")},params:function(){return this.json.params||{}},returns:function(){return this.json.returns||{}},inputs:function(){return(this.json.inputs||[]).map((e=>({...e,desc:this.params[e.name]})))},inputSignature:function(){return`(${this.inputs.map((e=>e.type)).join(",")})`},outputs:function(){return(this.json.outputs||[]).map(((e,t)=>({...e,desc:this.returns[e.name||`_${t}`]})))},outputSignature:function(){return`(${this.outputs.map((e=>e.type)).join(",")})`}}};var Rd=ud(wd,vd,[],!1,null,null,null);Rd.options.__file="node_modules/hardhat-docgen/src/components/Member.vue";const Ad=Rd.exports;var kd=function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("div",{staticClass:"w-full mt-8"},[n("h2",{staticClass:"text-lg"},[e._v(e._s(e.title))]),e._v(" "),e._l(Object.keys(e.json),(function(t){return n("Member",{key:t,staticClass:"mt-3",attrs:{json:e.json[t]}})}))],2)};kd._withStripped=!0;var xd=ud({components:{Member:Ad},props:{title:{type:String,default:""},json:{type:Object,default:()=>new Object}}},kd,[],!1,null,null,null);xd.options.__file="node_modules/hardhat-docgen/src/components/MemberSet.vue";var _d=ud({components:{Member:Ad,MemberSet:xd.exports,HeaderBar:bd,FooterBar:cd},props:{json:{type:Object,default:()=>new Object}}},pd,[],!1,null,null,null);_d.options.__file="node_modules/hardhat-docgen/src/components/Contract.vue";const Sd=_d.exports;var Md=function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("div",{staticClass:"w-full space-y-10 md:max-w-screen-sm lg:max-w-screen-md mx-auto pb-32"},[n("Branch",{attrs:{json:e.trees,name:"Sources:"}}),e._v(" "),n("FooterBar",{staticClass:"mt-20"})],1)};Md._withStripped=!0;var Od=function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("div",[e._v("\n  "+e._s(e.name)+"\n  "),Array.isArray(e.json)?n("div",{staticClass:"pl-5"},e._l(e.json,(function(t,a){return n("div",{key:a},[n("router-link",{attrs:{to:t.source+":"+t.name}},[e._v("\n        "+e._s(t.name)+"\n      ")])],1)})),0):n("div",{staticClass:"pl-5"},e._l(Object.keys(e.json),(function(t){return n("div",{key:t},[n("Branch",{attrs:{json:e.json[t],name:t}})],1)})),0)])};Od._withStripped=!0;var Id=ud({name:"Branch",props:{name:{type:String,default:null},json:{type:[Object,Array],default:()=>new Object}}},Od,[],!1,null,null,null);Id.options.__file="node_modules/hardhat-docgen/src/components/Branch.vue";var Cd=ud({components:{Branch:Id.exports,FooterBar:cd},props:{json:{type:Object,default:()=>new Object}},computed:{trees:function(){let e={};for(let t in this.json)t.replace("/","//").split(/\/(?=[^\/])/).reduce(function(e,n){if(!n.includes(":"))return e[n]=e[n]||{},e[n];{let[a]=n.split(":");e[a]=e[a]||[],e[a].push(this.json[t])}}.bind(this),e);return e}}},Md,[],!1,null,null,null);Cd.options.__file="node_modules/hardhat-docgen/src/components/Index.vue";const Ud=Cd.exports;hu.use(id);const Ed={"contracts/AdminControlled.sol:AdminControlled":{source:"contracts/AdminControlled.sol",name:"AdminControlled",title:"AdminControlled",author:"Aurora Team",details:"Implementation of Admin controlled contract      This contract implements inherits access control upgradeable contract,      in which provides a role based access control (RBAC) for admin priveleges.      It also provides other privileges such as:      - Pausing the contract      - Delegating contract calls to trusted targets (only managed by the default admin role)      - Changing state variable value using its storage slot      - Role management using AccessControlled ABIs",events:{"AdminChanged(address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"previousAdmin",type:"address"},{indexed:!1,internalType:"address",name:"newAdmin",type:"address"}],name:"AdminChanged",type:"event"},"BeaconUpgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"beacon",type:"address"}],name:"BeaconUpgraded",type:"event"},"RoleAdminChanged(bytes32,bytes32,bytes32)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"previousAdminRole",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"newAdminRole",type:"bytes32"}],name:"RoleAdminChanged",type:"event"},"RoleGranted(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleGranted",type:"event"},"RoleRevoked(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleRevoked",type:"event"},"Upgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"implementation",type:"address"}],name:"Upgraded",type:"event"}},methods:{"DEFAULT_ADMIN_ROLE()":{inputs:[],name:"DEFAULT_ADMIN_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"PAUSE_ROLE()":{inputs:[],name:"PAUSE_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"adminDelegatecall(address,bytes)":{inputs:[{internalType:"address",name:"target",type:"address"},{internalType:"bytes",name:"data",type:"bytes"}],name:"adminDelegatecall",outputs:[{internalType:"bytes",name:"",type:"bytes"}],stateMutability:"payable",type:"function","custom:oz-upgrades-unsafe-allow":"delegatecall",details:"adminDelegatecall allows this contract to delegate calls to a target contract and execute it in the context of this contract. Only default admin role can call this function.",params:{data:"is the ABI encoded function signature and its values.",target:"the target contract address"}},"adminPause(uint256)":{inputs:[{internalType:"uint256",name:"flags",type:"uint256"}],name:"adminPause",outputs:[],stateMutability:"nonpayable",type:"function",details:"adminPause pauses this contract. Only pause role or default admin role can access this function.",params:{flags:"flags variable is used for pausing this contract."}},"adminSstore(uint256,uint256)":{inputs:[{internalType:"uint256",name:"key",type:"uint256"},{internalType:"uint256",name:"value",type:"uint256"}],name:"adminSstore",outputs:[],stateMutability:"nonpayable",type:"function",details:"adminSstore updates the state variable value. only default admin role can call this function.",params:{key:"is the storage slot of the state variable",value:"is the state variable value"}},"adminSstoreWithMask(uint256,uint256,uint256)":{inputs:[{internalType:"uint256",name:"key",type:"uint256"},{internalType:"uint256",name:"value",type:"uint256"},{internalType:"uint256",name:"mask",type:"uint256"}],name:"adminSstoreWithMask",outputs:[],stateMutability:"nonpayable",type:"function",details:"adminSstoreWithMask similar to adminSstore except it updates the state variable value after xor-ing this value with the old value and the mask, so the new value should be a result of xor(and(xor(value, oldval), mask), oldval). Only default admin role can call this function.",params:{key:"is the storage slot of the state variable",mask:"this value is used in calculating the new value",value:"is the state variable value"}},"c_0x7e37e874(bytes32)":{inputs:[{internalType:"bytes32",name:"c__0x7e37e874",type:"bytes32"}],name:"c_0x7e37e874",outputs:[],stateMutability:"pure",type:"function"},"getRoleAdmin(bytes32)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"}],name:"getRoleAdmin",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}."},"grantRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"grantRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role."},"hasRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"hasRole",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns `true` if `account` has been granted `role`."},"paused()":{inputs:[],name:"paused",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"renounceRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"renounceRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been revoked `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`."},"revokeRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"revokeRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role."},"supportsInterface(bytes4)":{inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"See {IERC165-supportsInterface}."},"upgradeTo(address)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"}],name:"upgradeTo",outputs:[],stateMutability:"nonpayable",type:"function",details:"Upgrade the implementation of the proxy to `newImplementation`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."},"upgradeToAndCall(address,bytes)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"},{internalType:"bytes",name:"data",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable",type:"function",details:"Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call encoded in `data`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."}}},"contracts/ITreasury.sol:ITreasury":{source:"contracts/ITreasury.sol",name:"ITreasury",methods:{"isSupportedToken(address)":{inputs:[{internalType:"address",name:"token",type:"address"}],name:"isSupportedToken",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"payRewards(address,address,uint256)":{inputs:[{internalType:"address",name:"_user",type:"address"},{internalType:"address",name:"_token",type:"address"},{internalType:"uint256",name:"_deposit",type:"uint256"}],name:"payRewards",outputs:[],stateMutability:"nonpayable",type:"function"}}},"contracts/JetStaking/JetStakingV1.sol:JetStakingV1":{source:"contracts/JetStaking/JetStakingV1.sol",name:"JetStakingV1",title:"JetStakingV1",author:"Aurora Team",details:"Implementation of Jet staking contract      This contract implements the staking mechanics for AURORA ERC20 token.      A user can stake any amount of AURORA tokens, and get rewarded in both      AURORA and other stream tokens based on the rewards schedules.      Stream rewards can be claimed any time however AURORA can't be claimed      unless the user unstakes his full/partial amount of shares.      This contract is AdminControlled which has a tremendous power. However      hopfully it be governed by a community wallet.",constructor:{inputs:[],stateMutability:"nonpayable",type:"constructor"},events:{"AdminChanged(address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"previousAdmin",type:"address"},{indexed:!1,internalType:"address",name:"newAdmin",type:"address"}],name:"AdminChanged",type:"event"},"BeaconUpgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"beacon",type:"address"}],name:"BeaconUpgraded",type:"event"},"Pending(uint256,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"streamId",type:"uint256"},{indexed:!0,internalType:"address",name:"user",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"}],name:"Pending",type:"event"},"Released(uint256,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"streamId",type:"uint256"},{indexed:!0,internalType:"address",name:"user",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"}],name:"Released",type:"event"},"RoleAdminChanged(bytes32,bytes32,bytes32)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"previousAdminRole",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"newAdminRole",type:"bytes32"}],name:"RoleAdminChanged",type:"event"},"RoleGranted(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleGranted",type:"event"},"RoleRevoked(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleRevoked",type:"event"},"Staked(address,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"user",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"},{indexed:!1,internalType:"uint256",name:"shares",type:"uint256"}],name:"Staked",type:"event"},"StreamCreated(uint256,address,address,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"streamId",type:"uint256"},{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"token",type:"address"},{indexed:!1,internalType:"uint256",name:"tokenAmount",type:"uint256"},{indexed:!1,internalType:"uint256",name:"auroraAmount",type:"uint256"}],name:"StreamCreated",type:"event"},"StreamOwnerRewardReleased(uint256,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"streamId",type:"uint256"},{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"}],name:"StreamOwnerRewardReleased",type:"event"},"StreamProposalCancelled(uint256,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"streamId",type:"uint256"},{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"token",type:"address"}],name:"StreamProposalCancelled",type:"event"},"StreamProposed(uint256,address,address,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"streamId",type:"uint256"},{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"token",type:"address"},{indexed:!1,internalType:"uint256",name:"maxDepositAmount",type:"uint256"},{indexed:!1,internalType:"uint256",name:"auroraDepositAmount",type:"uint256"}],name:"StreamProposed",type:"event"},"StreamRemoved(uint256,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"streamId",type:"uint256"},{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"token",type:"address"}],name:"StreamRemoved",type:"event"},"Unstaked(address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"user",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"}],name:"Unstaked",type:"event"},"Upgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"implementation",type:"address"}],name:"Upgraded",type:"event"}},methods:{"AIRDROP_ROLE()":{inputs:[],name:"AIRDROP_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"CLAIM_ROLE()":{inputs:[],name:"CLAIM_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"DEFAULT_ADMIN_ROLE()":{inputs:[],name:"DEFAULT_ADMIN_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"FOUR_YEARS()":{inputs:[],name:"FOUR_YEARS",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"ONE_MONTH()":{inputs:[],name:"ONE_MONTH",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"PAUSE_ROLE()":{inputs:[],name:"PAUSE_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"STREAM_MANAGER_ROLE()":{inputs:[],name:"STREAM_MANAGER_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"adminDelegatecall(address,bytes)":{inputs:[{internalType:"address",name:"target",type:"address"},{internalType:"bytes",name:"data",type:"bytes"}],name:"adminDelegatecall",outputs:[{internalType:"bytes",name:"",type:"bytes"}],stateMutability:"payable",type:"function","custom:oz-upgrades-unsafe-allow":"delegatecall",details:"adminDelegatecall allows this contract to delegate calls to a target contract and execute it in the context of this contract. Only default admin role can call this function.",params:{data:"is the ABI encoded function signature and its values.",target:"the target contract address"}},"adminPause(uint256)":{inputs:[{internalType:"uint256",name:"flags",type:"uint256"}],name:"adminPause",outputs:[],stateMutability:"nonpayable",type:"function",details:"adminPause pauses this contract. Only pause role or default admin role can access this function.",params:{flags:"flags variable is used for pausing this contract."}},"adminSstore(uint256,uint256)":{inputs:[{internalType:"uint256",name:"key",type:"uint256"},{internalType:"uint256",name:"value",type:"uint256"}],name:"adminSstore",outputs:[],stateMutability:"nonpayable",type:"function",details:"adminSstore updates the state variable value. only default admin role can call this function.",params:{key:"is the storage slot of the state variable",value:"is the state variable value"}},"adminSstoreWithMask(uint256,uint256,uint256)":{inputs:[{internalType:"uint256",name:"key",type:"uint256"},{internalType:"uint256",name:"value",type:"uint256"},{internalType:"uint256",name:"mask",type:"uint256"}],name:"adminSstoreWithMask",outputs:[],stateMutability:"nonpayable",type:"function",details:"adminSstoreWithMask similar to adminSstore except it updates the state variable value after xor-ing this value with the old value and the mask, so the new value should be a result of xor(and(xor(value, oldval), mask), oldval). Only default admin role can call this function.",params:{key:"is the storage slot of the state variable",mask:"this value is used in calculating the new value",value:"is the state variable value"}},"auroraToken()":{inputs:[],name:"auroraToken",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"batchClaimOnBehalfOfAnotherUser(address,uint256[])":{inputs:[{internalType:"address",name:"account",type:"address"},{internalType:"uint256[]",name:"streamIds",type:"uint256[]"}],name:"batchClaimOnBehalfOfAnotherUser",outputs:[],stateMutability:"nonpayable",type:"function",details:"batchClaimOnBehalfOfAnotherUser when gas limits prevent users from claiming all.",params:{account:"the user account address.",streamIds:"to claim."}},"batchClaimOnBehalfOfOtherUsers(address[],uint256[])":{inputs:[{internalType:"address[]",name:"accounts",type:"address[]"},{internalType:"uint256[]",name:"streamIds",type:"uint256[]"}],name:"batchClaimOnBehalfOfOtherUsers",outputs:[],stateMutability:"nonpayable",type:"function",details:"Claim all stream rewards on behalf of other users.",params:{accounts:"the user account addresses."}},"batchMoveRewardsToPending(uint256[])":{inputs:[{internalType:"uint256[]",name:"streamIds",type:"uint256[]"}],name:"batchMoveRewardsToPending",outputs:[],stateMutability:"nonpayable",type:"function",details:"moves a set of stream Id rewards to pending. Allows user to select stream ids to claim from UI.",params:{streamIds:"stream indexes"}},"batchWithdraw(uint256[])":{inputs:[{internalType:"uint256[]",name:"streamIds",type:"uint256[]"}],name:"batchWithdraw",outputs:[],stateMutability:"nonpayable",type:"function",details:"withdraw a set of stream Ids. Allows user to select stream ids to withdraw from UI.",params:{streamIds:"to withdraw."}},"c_0x7e37e874(bytes32)":{inputs:[{internalType:"bytes32",name:"c__0x7e37e874",type:"bytes32"}],name:"c_0x7e37e874",outputs:[],stateMutability:"pure",type:"function"},"c_0xc1dd3536(bytes32)":{inputs:[{internalType:"bytes32",name:"c__0xc1dd3536",type:"bytes32"}],name:"c_0xc1dd3536",outputs:[],stateMutability:"pure",type:"function"},"cancelStreamProposal(uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"}],name:"cancelStreamProposal",outputs:[],stateMutability:"nonpayable",type:"function",details:"cancelStreamProposal cancels a proposal any time before the stream becomes active (created).",params:{streamId:"the stream index"}},"claimAllOnBehalfOfAnotherUser(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"claimAllOnBehalfOfAnotherUser",outputs:[],stateMutability:"nonpayable",type:"function",details:"Claim all stream rewards on behalf of another user.",params:{account:"the user account address."}},"claimAllOnBehalfOfOtherUsers(address[])":{inputs:[{internalType:"address[]",name:"accounts",type:"address[]"}],name:"claimAllOnBehalfOfOtherUsers",outputs:[],stateMutability:"nonpayable",type:"function",details:"Claim all stream rewards on behalf of other users.",params:{accounts:"the user account addresses."}},"claimOnBehalfOfAnotherUser(address,uint256)":{inputs:[{internalType:"address",name:"account",type:"address"},{internalType:"uint256",name:"streamId",type:"uint256"}],name:"claimOnBehalfOfAnotherUser",outputs:[],stateMutability:"nonpayable",type:"function",details:"Claim a stream's rewards on behalf of another user.",params:{account:"the user account address.",streamId:"to claim."}},"createStream(uint256,uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"},{internalType:"uint256",name:"rewardTokenAmount",type:"uint256"}],name:"createStream",outputs:[],stateMutability:"nonpayable",type:"function",details:"create new stream (only stream owner) stream owner must approve reward tokens to this contract.",params:{streamId:"stream id"}},"getAmountOfShares(uint256,address)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"},{internalType:"address",name:"account",type:"address"}],name:"getAmountOfShares",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"gets a user stream shares",params:{account:"the user address",streamId:"stream index"},returns:{_0:"user stream shares"}},"getLatestRewardPerShare(uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"}],name:"getLatestRewardPerShare",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"calculates and gets the latest reward per share (RPS) for a stream",params:{streamId:"stream index"},returns:{_0:"streams[streamId].rps + scheduled reward up till now"}},"getPending(uint256,address)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"},{internalType:"address",name:"account",type:"address"}],name:"getPending",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"gets the user's stream pending reward",params:{account:"user account",streamId:"stream index"},returns:{_0:"user.pendings[streamId]"}},"getReleaseTime(uint256,address)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"},{internalType:"address",name:"account",type:"address"}],name:"getReleaseTime",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"gets the user's stream reward release time",params:{account:"user account",streamId:"stream index"},returns:{_0:"user.releaseTime[streamId]"}},"getRewardPerShare(uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"}],name:"getRewardPerShare",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"gets reward per share (RPS) for a stream",params:{streamId:"stream index"},returns:{_0:"streams[streamId].rps"}},"getRewardPerShareForUser(uint256,address)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"},{internalType:"address",name:"account",type:"address"}],name:"getRewardPerShareForUser",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"gets the user's reward per share (RPS) for a stream",params:{streamId:"stream index"},returns:{_0:"user.rpsDuringLastClaim[streamId]"}},"getRewardsAmount(uint256,uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"},{internalType:"uint256",name:"lastUpdate",type:"uint256"}],name:"getRewardsAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"calculates and gets the latest released rewards.",params:{streamId:"stream index"},returns:{_0:"rewards released since last update."}},"getRoleAdmin(bytes32)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"}],name:"getRoleAdmin",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}."},"getStream(uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"}],name:"getStream",outputs:[{internalType:"address",name:"streamOwner",type:"address"},{internalType:"address",name:"rewardToken",type:"address"},{internalType:"uint256",name:"auroraDepositAmount",type:"uint256"},{internalType:"uint256",name:"auroraClaimedAmount",type:"uint256"},{internalType:"uint256",name:"rewardDepositAmount",type:"uint256"},{internalType:"uint256",name:"rewardClaimedAmount",type:"uint256"},{internalType:"uint256",name:"maxDepositAmount",type:"uint256"},{internalType:"uint256",name:"lastTimeOwnerClaimed",type:"uint256"},{internalType:"uint256",name:"rps",type:"uint256"},{internalType:"uint256",name:"tau",type:"uint256"},{internalType:"enum JetStakingV1.StreamStatus",name:"status",type:"uint8"}],stateMutability:"view",type:"function",details:"get the stream data",params:{streamId:"the stream index"},notice:"this function doesn't return the stream schedule due to some stake slots limitations. To get the stream schedule, refer to getStreamSchedule"},"getStreamClaimableAmount(uint256,address)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"},{internalType:"address",name:"account",type:"address"}],name:"getStreamClaimableAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"gets the user's stream claimable amount",params:{streamId:"stream index"},returns:{_0:"(latesRPS - user.rpsDuringLastClaim) * user.shares"}},"getStreamOwnerClaimableAmount(uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"}],name:"getStreamOwnerClaimableAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Stream owner claimable AURORA.",params:{streamId:"the stream index"}},"getStreamSchedule(uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"}],name:"getStreamSchedule",outputs:[{internalType:"uint256[]",name:"scheduleTimes",type:"uint256[]"},{internalType:"uint256[]",name:"scheduleRewards",type:"uint256[]"}],stateMutability:"view",type:"function",details:"get the stream schedule data",params:{streamId:"the stream index"}},"getStreamsCount()":{inputs:[],name:"getStreamsCount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"get the streams count",returns:{_0:"streams.length"}},"getTotalAmountOfStakedAurora()":{inputs:[],name:"getTotalAmountOfStakedAurora",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"gets the total amount of staked aurora",returns:{_0:"totalAmountOfStakedAurora + latest reward schedule"}},"getTreasuryBalance(address)":{inputs:[{internalType:"address",name:"token",type:"address"}],name:"getTreasuryBalance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Get the treasury balance",params:{token:"the token address"}},"getUserShares(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"getUserShares",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"gets the user shares",params:{account:"the user address"},returns:{_0:"user shares"}},"getUserTotalDeposit(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"getUserTotalDeposit",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"gets the total user deposit",params:{account:"the user address"},returns:{_0:"user total deposit in (AURORA)"}},"grantRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"grantRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role."},"hasRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"hasRole",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns `true` if `account` has been granted `role`."},"initialize(address,address,uint256[],uint256[],uint256,uint256,address,uint256,uint256)":{inputs:[{internalType:"address",name:"aurora",type:"address"},{internalType:"address",name:"streamOwner",type:"address"},{internalType:"uint256[]",name:"scheduleTimes",type:"uint256[]"},{internalType:"uint256[]",name:"scheduleRewards",type:"uint256[]"},{internalType:"uint256",name:"tauAuroraStream",type:"uint256"},{internalType:"uint256",name:"_flags",type:"uint256"},{internalType:"address",name:"_treasury",type:"address"},{internalType:"uint256",name:"_maxWeight",type:"uint256"},{internalType:"uint256",name:"_minWeight",type:"uint256"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function",details:"initialize the contract and deploys the first stream (AURORA)",params:{_flags:"admin controlled contract flags",_maxWeight:"max stream reward weighting coefficient",_minWeight:"min stream reward weighting coefficient",_treasury:"the Aurora treasury contract address",aurora:"token contract address",scheduleRewards:"init the schedule amounts",scheduleTimes:"init the schedule time",tauAuroraStream:"release time constant per stream (e.g AURORA stream)"},notice:"By calling this function, the deployer of this contract must make sure that the AURORA reward amount was deposited to the treasury contract before initializing of the default AURORA stream."},"maxWeight()":{inputs:[],name:"maxWeight",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"minWeight()":{inputs:[],name:"minWeight",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"moveAllRewardsToPending()":{inputs:[],name:"moveAllRewardsToPending",outputs:[],stateMutability:"nonpayable",type:"function",details:"moves all the user rewards to pending reward."},"moveRewardsToPending(uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"}],name:"moveRewardsToPending",outputs:[],stateMutability:"nonpayable",type:"function",details:"moves the reward for specific stream Id to pending rewards. It will require a waiting time untill it get released. Users call this in function in order to claim rewards.",params:{streamId:"stream index"}},"paused()":{inputs:[],name:"paused",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"proposeStream(address,address,uint256,uint256,uint256,uint256[],uint256[],uint256)":{inputs:[{internalType:"address",name:"streamOwner",type:"address"},{internalType:"address",name:"rewardToken",type:"address"},{internalType:"uint256",name:"auroraDepositAmount",type:"uint256"},{internalType:"uint256",name:"maxDepositAmount",type:"uint256"},{internalType:"uint256",name:"minDepositAmount",type:"uint256"},{internalType:"uint256[]",name:"scheduleTimes",type:"uint256[]"},{internalType:"uint256[]",name:"scheduleRewards",type:"uint256[]"},{internalType:"uint256",name:"tau",type:"uint256"}],name:"proposeStream",outputs:[],stateMutability:"nonpayable",type:"function",details:"An admin of the staking contract can whitelist (propose) a stream. Whitelisting of the stream provides the option for the stream owner (presumably the issuing party of a specific token) to deposit some ERC-20 tokens on the staking contract and potentially get in return some AURORA tokens. Deposited ERC-20 tokens will be distributed to the stakers over some period of time.",params:{auroraDepositAmount:"Amount of the AURORA deposited by the Admin.",maxDepositAmount:"The upper amount of the tokens that should be deposited by the stream owner",rewardToken:"the address of the ERC-20 tokens to be deposited in the stream",scheduleRewards:"remaining rewards to be delivered at the beginning of each scheduled interval. Last element is always zero. First value (in scheduleRewards) from array is supposed to be a total amount of rewards for stream.",scheduleTimes:"timestamp denoting the start of each scheduled interval. Last element is the end of the stream.",streamOwner:"only this account would be able to create a stream",tau:"the tau is (pending release period) for this stream (e.g one day)"},notice:"treasury manager must call"},"releaseAuroraRewardsToStreamOwner(uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"}],name:"releaseAuroraRewardsToStreamOwner",outputs:[],stateMutability:"nonpayable",type:"function",details:"the release of AURORA tokens to the stream owner is subjected to the same schedule as rewards. Thus if for a specific moment in time 30% of the rewards are distributed, then it means that 30% of the AURORA deposit can be withdrawn by the stream owner too. called by the stream owner",params:{streamId:"the stream index"}},"removeStream(uint256,address)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"},{internalType:"address",name:"streamFundReceiver",type:"address"}],name:"removeStream",outputs:[],stateMutability:"nonpayable",type:"function",details:"removes a stream (only default admin role)",params:{streamFundReceiver:"receives the rest of the reward tokens in the stream",streamId:"stream index"}},"renounceRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"renounceRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been revoked `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`."},"revokeRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"revokeRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role."},"rewardsSchedule(uint256,uint256,uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"},{internalType:"uint256",name:"start",type:"uint256"},{internalType:"uint256",name:"end",type:"uint256"}],name:"rewardsSchedule",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"calculate the total amount of the released tokens within a period (start & end)",params:{end:"is the end timestamp (e.g block.timestamp .. now)",start:"is the start timestamp within the schedule",streamId:"the stream index"},returns:{_0:"amount of the released tokens for that period"}},"stake(uint256)":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"}],name:"stake",outputs:[],stateMutability:"nonpayable",type:"function",details:"a user stakes amount of AURORA tokens The user should approve these tokens to the treasury contract in order to complete the stake.",params:{amount:"is the AURORA amount."}},"stakeOnBehalfOfAnotherUser(address,uint256)":{inputs:[{internalType:"address",name:"account",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"stakeOnBehalfOfAnotherUser",outputs:[],stateMutability:"nonpayable",type:"function",details:"stakeOnBehalfOfAnotherUser is called for airdropping Aurora users",params:{account:"the account address",amount:"in AURORA tokens WARNING: rewards are not claimed during stake. Airdrop script must claim or only distribute to accounts without stake"}},"stakeOnBehalfOfOtherUsers(address[],uint256[],uint256)":{inputs:[{internalType:"address[]",name:"accounts",type:"address[]"},{internalType:"uint256[]",name:"amounts",type:"uint256[]"},{internalType:"uint256",name:"batchAmount",type:"uint256"}],name:"stakeOnBehalfOfOtherUsers",outputs:[],stateMutability:"nonpayable",type:"function",details:"stakeOnBehalfOfOtherUsers called for airdropping Aurora users",params:{accounts:"the account address",amounts:"in AURORA tokens",batchAmount:"equals to the sum of amounts WARNING: rewards are not claimed during stake. Airdrop script must claim or only distribute to accounts without stake"}},"startEndScheduleIndex(uint256,uint256,uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"},{internalType:"uint256",name:"start",type:"uint256"},{internalType:"uint256",name:"end",type:"uint256"}],name:"startEndScheduleIndex",outputs:[{internalType:"uint256",name:"startIndex",type:"uint256"},{internalType:"uint256",name:"endIndex",type:"uint256"}],stateMutability:"view",type:"function",details:"gets start index and end index in a stream schedule",params:{end:"end time (in seconds)",start:"start time (in seconds)",streamId:"stream index"}},"supportsInterface(bytes4)":{inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"See {IERC165-supportsInterface}."},"totalAmountOfStakedAurora()":{inputs:[],name:"totalAmountOfStakedAurora",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"totalAuroraShares()":{inputs:[],name:"totalAuroraShares",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"totalStreamShares()":{inputs:[],name:"totalStreamShares",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"touchedAt()":{inputs:[],name:"touchedAt",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"treasury()":{inputs:[],name:"treasury",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"unstake(uint256)":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"}],name:"unstake",outputs:[],stateMutability:"nonpayable",type:"function",details:"unstake amount from user shares value. The rest is re-staked",params:{amount:"to unstake"}},"unstakeAll()":{inputs:[],name:"unstakeAll",outputs:[],stateMutability:"nonpayable",type:"function",details:"unstake all the user's shares"},"updateTreasury(address)":{inputs:[{internalType:"address",name:"_treasury",type:"address"}],name:"updateTreasury",outputs:[],stateMutability:"nonpayable",type:"function",details:"restricted for the admin only. Admin should pause this contract before changing the treasury address by setting the pause =1 (for changing this variable, call adminPause(1))",params:{_treasury:"treasury contract address for the reward tokens"},notice:"updates treasury account"},"upgradeTo(address)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"}],name:"upgradeTo",outputs:[],stateMutability:"nonpayable",type:"function",details:"Upgrade the implementation of the proxy to `newImplementation`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."},"upgradeToAndCall(address,bytes)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"},{internalType:"bytes",name:"data",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable",type:"function",details:"Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call encoded in `data`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."},"users(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"users",outputs:[{internalType:"uint256",name:"deposit",type:"uint256"},{internalType:"uint256",name:"auroraShares",type:"uint256"},{internalType:"uint256",name:"streamShares",type:"uint256"}],stateMutability:"view",type:"function"},"withdraw(uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"}],name:"withdraw",outputs:[],stateMutability:"nonpayable",type:"function",details:"withdraw amount in the pending pool. User should wait for pending time (tau constant) in order to be able to withdraw.",params:{streamId:"stream index"}},"withdrawAll()":{inputs:[],name:"withdrawAll",outputs:[],stateMutability:"nonpayable",type:"function",details:"withdraw all claimed balances which have passed pending periode. This function will reach gas limit with too many streams, so the frontend will allow individual stream withdrawals and disable withdrawAll."}}},"contracts/JetStaking/JetStakingV2.sol:JetStakingV2":{source:"contracts/JetStaking/JetStakingV2.sol",name:"JetStakingV2",title:"JetStakingV2",author:"Aurora Team",details:"Implementation of Jet staking contract      This contract implements the staking mechanics for AURORA ERC20 token.      A user can stake any amount of AURORA tokens, and get rewarded in both      AURORA and other stream tokens based on the rewards schedules.      Stream rewards can be claimed any time however AURORA can't be claimed      unless the user unstakes his full/partial amount of shares.      This contract is AdminControlled which has a tremendous power. However      hopfully it be governed by a community wallet.",constructor:{inputs:[],stateMutability:"nonpayable",type:"constructor"},events:{"AdminChanged(address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"previousAdmin",type:"address"},{indexed:!1,internalType:"address",name:"newAdmin",type:"address"}],name:"AdminChanged",type:"event"},"BeaconUpgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"beacon",type:"address"}],name:"BeaconUpgraded",type:"event"},"Pending(uint256,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"streamId",type:"uint256"},{indexed:!0,internalType:"address",name:"user",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"}],name:"Pending",type:"event"},"Released(uint256,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"streamId",type:"uint256"},{indexed:!0,internalType:"address",name:"user",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"}],name:"Released",type:"event"},"RoleAdminChanged(bytes32,bytes32,bytes32)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"previousAdminRole",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"newAdminRole",type:"bytes32"}],name:"RoleAdminChanged",type:"event"},"RoleGranted(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleGranted",type:"event"},"RoleRevoked(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleRevoked",type:"event"},"Staked(address,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"user",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"},{indexed:!1,internalType:"uint256",name:"shares",type:"uint256"}],name:"Staked",type:"event"},"StreamCreated(uint256,address,address,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"streamId",type:"uint256"},{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"token",type:"address"},{indexed:!1,internalType:"uint256",name:"tokenAmount",type:"uint256"},{indexed:!1,internalType:"uint256",name:"auroraAmount",type:"uint256"}],name:"StreamCreated",type:"event"},"StreamOwnerRewardReleased(uint256,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"streamId",type:"uint256"},{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"}],name:"StreamOwnerRewardReleased",type:"event"},"StreamProposalCancelled(uint256,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"streamId",type:"uint256"},{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"token",type:"address"}],name:"StreamProposalCancelled",type:"event"},"StreamProposed(uint256,address,address,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"streamId",type:"uint256"},{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"token",type:"address"},{indexed:!1,internalType:"uint256",name:"maxDepositAmount",type:"uint256"},{indexed:!1,internalType:"uint256",name:"auroraDepositAmount",type:"uint256"}],name:"StreamProposed",type:"event"},"StreamRemoved(uint256,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"streamId",type:"uint256"},{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"token",type:"address"}],name:"StreamRemoved",type:"event"},"Unstaked(address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"user",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"}],name:"Unstaked",type:"event"},"Upgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"implementation",type:"address"}],name:"Upgraded",type:"event"}},methods:{"AIRDROP_ROLE()":{inputs:[],name:"AIRDROP_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"CLAIM_ROLE()":{inputs:[],name:"CLAIM_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"DEFAULT_ADMIN_ROLE()":{inputs:[],name:"DEFAULT_ADMIN_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"FOUR_YEARS()":{inputs:[],name:"FOUR_YEARS",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"ONE_MONTH()":{inputs:[],name:"ONE_MONTH",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"PAUSE_ROLE()":{inputs:[],name:"PAUSE_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"STREAM_MANAGER_ROLE()":{inputs:[],name:"STREAM_MANAGER_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"adminDelegatecall(address,bytes)":{inputs:[{internalType:"address",name:"target",type:"address"},{internalType:"bytes",name:"data",type:"bytes"}],name:"adminDelegatecall",outputs:[{internalType:"bytes",name:"",type:"bytes"}],stateMutability:"payable",type:"function","custom:oz-upgrades-unsafe-allow":"delegatecall",details:"adminDelegatecall allows this contract to delegate calls to a target contract and execute it in the context of this contract. Only default admin role can call this function.",params:{data:"is the ABI encoded function signature and its values.",target:"the target contract address"}},"adminPause(uint256)":{inputs:[{internalType:"uint256",name:"flags",type:"uint256"}],name:"adminPause",outputs:[],stateMutability:"nonpayable",type:"function",details:"adminPause pauses this contract. Only pause role or default admin role can access this function.",params:{flags:"flags variable is used for pausing this contract."}},"adminSstore(uint256,uint256)":{inputs:[{internalType:"uint256",name:"key",type:"uint256"},{internalType:"uint256",name:"value",type:"uint256"}],name:"adminSstore",outputs:[],stateMutability:"nonpayable",type:"function",details:"adminSstore updates the state variable value. only default admin role can call this function.",params:{key:"is the storage slot of the state variable",value:"is the state variable value"}},"adminSstoreWithMask(uint256,uint256,uint256)":{inputs:[{internalType:"uint256",name:"key",type:"uint256"},{internalType:"uint256",name:"value",type:"uint256"},{internalType:"uint256",name:"mask",type:"uint256"}],name:"adminSstoreWithMask",outputs:[],stateMutability:"nonpayable",type:"function",details:"adminSstoreWithMask similar to adminSstore except it updates the state variable value after xor-ing this value with the old value and the mask, so the new value should be a result of xor(and(xor(value, oldval), mask), oldval). Only default admin role can call this function.",params:{key:"is the storage slot of the state variable",mask:"this value is used in calculating the new value",value:"is the state variable value"}},"auroraToken()":{inputs:[],name:"auroraToken",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"batchClaimOnBehalfOfAnotherUser(address,uint256[])":{inputs:[{internalType:"address",name:"account",type:"address"},{internalType:"uint256[]",name:"streamIds",type:"uint256[]"}],name:"batchClaimOnBehalfOfAnotherUser",outputs:[],stateMutability:"nonpayable",type:"function",details:"batchClaimOnBehalfOfAnotherUser when gas limits prevent users from claiming all.",params:{account:"the user account address.",streamIds:"to claim."}},"batchMoveRewardsToPending(uint256[])":{inputs:[{internalType:"uint256[]",name:"streamIds",type:"uint256[]"}],name:"batchMoveRewardsToPending",outputs:[],stateMutability:"nonpayable",type:"function",details:"moves a set of stream Id rewards to pending. Allows user to select stream ids to claim from UI.",params:{streamIds:"stream indexes"}},"batchWithdraw(uint256[])":{inputs:[{internalType:"uint256[]",name:"streamIds",type:"uint256[]"}],name:"batchWithdraw",outputs:[],stateMutability:"nonpayable",type:"function",details:"withdraw a set of stream Ids. Allows user to select stream ids to withdraw from UI.",params:{streamIds:"to withdraw."}},"c_0x022bfb71(bytes32)":{inputs:[{internalType:"bytes32",name:"c__0x022bfb71",type:"bytes32"}],name:"c_0x022bfb71",outputs:[],stateMutability:"pure",type:"function"},"c_0x7e37e874(bytes32)":{inputs:[{internalType:"bytes32",name:"c__0x7e37e874",type:"bytes32"}],name:"c_0x7e37e874",outputs:[],stateMutability:"pure",type:"function"},"cancelStreamProposal(uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"}],name:"cancelStreamProposal",outputs:[],stateMutability:"nonpayable",type:"function",details:"cancelStreamProposal cancels a proposal any time before the stream becomes active (created).",params:{streamId:"the stream index"}},"claimAllOnBehalfOfAnotherUser(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"claimAllOnBehalfOfAnotherUser",outputs:[],stateMutability:"nonpayable",type:"function",details:"Claim all stream rewards on behalf of another user.",params:{account:"the user account address."}},"createStream(uint256,uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"},{internalType:"uint256",name:"rewardTokenAmount",type:"uint256"}],name:"createStream",outputs:[],stateMutability:"nonpayable",type:"function",details:"create new stream (only stream owner) stream owner must approve reward tokens to this contract.",params:{streamId:"stream id"}},"extendAuroraStreamSchedule(uint256[],uint256[])":{inputs:[{internalType:"uint256[]",name:"scheduleTimes",type:"uint256[]"},{internalType:"uint256[]",name:"scheduleRewards",type:"uint256[]"}],name:"extendAuroraStreamSchedule",outputs:[],stateMutability:"nonpayable",type:"function",details:"extend Aurora stream reward schedule. It can be only called by the default contract admin. It can accept extending the schedule if the new schedule is not overlapping with the current schedule. Also, it requires to pause the contract before calling it.",params:{scheduleRewards:"remaining rewards to be delivered at the beginning of each scheduled interval. Last element is always zero.",scheduleTimes:"timestamp denoting the start of each scheduled interval. Last element is the end of the stream."}},"getAmountOfShares(uint256,address)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"},{internalType:"address",name:"account",type:"address"}],name:"getAmountOfShares",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"gets a user stream shares",params:{account:"the user address",streamId:"stream index"},returns:{_0:"user stream shares"}},"getLatestRewardPerShare(uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"}],name:"getLatestRewardPerShare",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"calculates and gets the latest reward per share (RPS) for a stream",params:{streamId:"stream index"},returns:{_0:"streams[streamId].rps + scheduled reward up till now"}},"getPending(uint256,address)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"},{internalType:"address",name:"account",type:"address"}],name:"getPending",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"gets the user's stream pending reward",params:{account:"user account",streamId:"stream index"},returns:{_0:"user.pendings[streamId]"}},"getReleaseTime(uint256,address)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"},{internalType:"address",name:"account",type:"address"}],name:"getReleaseTime",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"gets the user's stream reward release time",params:{account:"user account",streamId:"stream index"},returns:{_0:"user.releaseTime[streamId]"}},"getRewardPerShare(uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"}],name:"getRewardPerShare",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"gets reward per share (RPS) for a stream",params:{streamId:"stream index"},returns:{_0:"streams[streamId].rps"}},"getRewardPerShareForUser(uint256,address)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"},{internalType:"address",name:"account",type:"address"}],name:"getRewardPerShareForUser",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"gets the user's reward per share (RPS) for a stream",params:{streamId:"stream index"},returns:{_0:"user.rpsDuringLastClaim[streamId]"}},"getRewardsAmount(uint256,uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"},{internalType:"uint256",name:"lastUpdate",type:"uint256"}],name:"getRewardsAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"calculates and gets the latest released rewards.",params:{streamId:"stream index"},returns:{_0:"rewards released since last update."}},"getRoleAdmin(bytes32)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"}],name:"getRoleAdmin",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}."},"getStream(uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"}],name:"getStream",outputs:[{internalType:"address",name:"streamOwner",type:"address"},{internalType:"address",name:"rewardToken",type:"address"},{internalType:"uint256",name:"auroraDepositAmount",type:"uint256"},{internalType:"uint256",name:"auroraClaimedAmount",type:"uint256"},{internalType:"uint256",name:"rewardDepositAmount",type:"uint256"},{internalType:"uint256",name:"rewardClaimedAmount",type:"uint256"},{internalType:"uint256",name:"maxDepositAmount",type:"uint256"},{internalType:"uint256",name:"lastTimeOwnerClaimed",type:"uint256"},{internalType:"uint256",name:"rps",type:"uint256"},{internalType:"uint256",name:"tau",type:"uint256"},{internalType:"enum JetStakingV2.StreamStatus",name:"status",type:"uint8"}],stateMutability:"view",type:"function",details:"get the stream data",params:{streamId:"the stream index"},notice:"this function doesn't return the stream schedule due to some stake slots limitations. To get the stream schedule, refer to getStreamSchedule"},"getStreamClaimableAmount(uint256,address)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"},{internalType:"address",name:"account",type:"address"}],name:"getStreamClaimableAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"gets the user's stream claimable amount",params:{streamId:"stream index"},returns:{_0:"(latesRPS - user.rpsDuringLastClaim) * user.shares"}},"getStreamOwnerClaimableAmount(uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"}],name:"getStreamOwnerClaimableAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Stream owner claimable AURORA.",params:{streamId:"the stream index"}},"getStreamSchedule(uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"}],name:"getStreamSchedule",outputs:[{internalType:"uint256[]",name:"scheduleTimes",type:"uint256[]"},{internalType:"uint256[]",name:"scheduleRewards",type:"uint256[]"}],stateMutability:"view",type:"function",details:"get the stream schedule data",params:{streamId:"the stream index"}},"getStreamsCount()":{inputs:[],name:"getStreamsCount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"get the streams count",returns:{_0:"streams.length"}},"getTotalAmountOfStakedAurora()":{inputs:[],name:"getTotalAmountOfStakedAurora",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"gets the total amount of staked aurora",returns:{_0:"totalAmountOfStakedAurora + latest reward schedule"}},"getTreasuryBalance(address)":{inputs:[{internalType:"address",name:"token",type:"address"}],name:"getTreasuryBalance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Get the treasury balance",params:{token:"the token address"}},"getUserShares(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"getUserShares",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"gets the user shares",params:{account:"the user address"},returns:{_0:"user shares"}},"getUserTotalDeposit(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"getUserTotalDeposit",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"gets the total user deposit",params:{account:"the user address"},returns:{_0:"user total deposit in (AURORA)"}},"grantRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"grantRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role."},"hasRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"hasRole",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns `true` if `account` has been granted `role`."},"initialize(address,address,uint256[],uint256[],uint256,uint256,address,uint256,uint256)":{inputs:[{internalType:"address",name:"aurora",type:"address"},{internalType:"address",name:"streamOwner",type:"address"},{internalType:"uint256[]",name:"scheduleTimes",type:"uint256[]"},{internalType:"uint256[]",name:"scheduleRewards",type:"uint256[]"},{internalType:"uint256",name:"tauAuroraStream",type:"uint256"},{internalType:"uint256",name:"_flags",type:"uint256"},{internalType:"address",name:"_treasury",type:"address"},{internalType:"uint256",name:"_maxWeight",type:"uint256"},{internalType:"uint256",name:"_minWeight",type:"uint256"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function",details:"initialize the contract and deploys the first stream (AURORA)",params:{_flags:"admin controlled contract flags",_maxWeight:"max stream reward weighting coefficient",_minWeight:"min stream reward weighting coefficient",_treasury:"the Aurora treasury contract address",aurora:"token contract address",scheduleRewards:"init the schedule amounts",scheduleTimes:"init the schedule time",tauAuroraStream:"release time constant per stream (e.g AURORA stream)"},notice:"By calling this function, the deployer of this contract must make sure that the AURORA reward amount was deposited to the treasury contract before initializing of the default AURORA stream."},"maxWeight()":{inputs:[],name:"maxWeight",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"minWeight()":{inputs:[],name:"minWeight",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"moveAllRewardsToPending()":{inputs:[],name:"moveAllRewardsToPending",outputs:[],stateMutability:"nonpayable",type:"function",details:"moves all the user rewards to pending reward."},"moveRewardsToPending(uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"}],name:"moveRewardsToPending",outputs:[],stateMutability:"nonpayable",type:"function",details:"moves the reward for specific stream Id to pending rewards. It will require a waiting time untill it get released. Users call this in function in order to claim rewards.",params:{streamId:"stream index"}},"paused()":{inputs:[],name:"paused",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"proposeStream(address,address,uint256,uint256,uint256,uint256[],uint256[],uint256)":{inputs:[{internalType:"address",name:"streamOwner",type:"address"},{internalType:"address",name:"rewardToken",type:"address"},{internalType:"uint256",name:"auroraDepositAmount",type:"uint256"},{internalType:"uint256",name:"maxDepositAmount",type:"uint256"},{internalType:"uint256",name:"minDepositAmount",type:"uint256"},{internalType:"uint256[]",name:"scheduleTimes",type:"uint256[]"},{internalType:"uint256[]",name:"scheduleRewards",type:"uint256[]"},{internalType:"uint256",name:"tau",type:"uint256"}],name:"proposeStream",outputs:[],stateMutability:"nonpayable",type:"function",details:"An admin of the staking contract can whitelist (propose) a stream. Whitelisting of the stream provides the option for the stream owner (presumably the issuing party of a specific token) to deposit some ERC-20 tokens on the staking contract and potentially get in return some AURORA tokens. Deposited ERC-20 tokens will be distributed to the stakers over some period of time.",params:{auroraDepositAmount:"Amount of the AURORA deposited by the Admin.",maxDepositAmount:"The upper amount of the tokens that should be deposited by the stream owner",rewardToken:"the address of the ERC-20 tokens to be deposited in the stream",scheduleRewards:"remaining rewards to be delivered at the beginning of each scheduled interval. Last element is always zero. First value (in scheduleRewards) from array is supposed to be a total amount of rewards for stream.",scheduleTimes:"timestamp denoting the start of each scheduled interval. Last element is the end of the stream.",streamOwner:"only this account would be able to create a stream",tau:"the tau is (pending release period) for this stream (e.g one day)"},notice:"treasury manager must call"},"releaseAuroraRewardsToStreamOwner(uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"}],name:"releaseAuroraRewardsToStreamOwner",outputs:[],stateMutability:"nonpayable",type:"function",details:"the release of AURORA tokens to the stream owner is subjected to the same schedule as rewards. Thus if for a specific moment in time 30% of the rewards are distributed, then it means that 30% of the AURORA deposit can be withdrawn by the stream owner too. called by the stream owner",params:{streamId:"the stream index"}},"removeStream(uint256,address)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"},{internalType:"address",name:"streamFundReceiver",type:"address"}],name:"removeStream",outputs:[],stateMutability:"nonpayable",type:"function",details:"removes a stream (only default admin role)",params:{streamFundReceiver:"receives the rest of the reward tokens in the stream",streamId:"stream index"}},"renounceRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"renounceRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been revoked `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`."},"revokeRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"revokeRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role."},"rewardsSchedule(uint256,uint256,uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"},{internalType:"uint256",name:"start",type:"uint256"},{internalType:"uint256",name:"end",type:"uint256"}],name:"rewardsSchedule",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"calculate the total amount of the released tokens within a period (start & end)",params:{end:"is the end timestamp (e.g block.timestamp .. now)",start:"is the start timestamp within the schedule",streamId:"the stream index"},returns:{_0:"amount of the released tokens for that period"}},"stake(uint256)":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"}],name:"stake",outputs:[],stateMutability:"nonpayable",type:"function",details:"a user stakes amount of AURORA tokens The user should approve these tokens to the treasury contract in order to complete the stake.",params:{amount:"is the AURORA amount."}},"stakeOnBehalfOfAnotherUser(address,uint256)":{inputs:[{internalType:"address",name:"account",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"stakeOnBehalfOfAnotherUser",outputs:[],stateMutability:"nonpayable",type:"function",details:"stakeOnBehalfOfAnotherUser is called for airdropping Aurora users",params:{account:"the account address",amount:"in AURORA tokens WARNING: rewards are not claimed during stake. Airdrop script must claim or only distribute to accounts without stake"}},"startEndScheduleIndex(uint256,uint256,uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"},{internalType:"uint256",name:"start",type:"uint256"},{internalType:"uint256",name:"end",type:"uint256"}],name:"startEndScheduleIndex",outputs:[{internalType:"uint256",name:"startIndex",type:"uint256"},{internalType:"uint256",name:"endIndex",type:"uint256"}],stateMutability:"view",type:"function",details:"gets start index and end index in a stream schedule",params:{end:"end time (in seconds)",start:"start time (in seconds)",streamId:"stream index"}},"supportsInterface(bytes4)":{inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"See {IERC165-supportsInterface}."},"totalAmountOfStakedAurora()":{inputs:[],name:"totalAmountOfStakedAurora",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"totalAuroraShares()":{inputs:[],name:"totalAuroraShares",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"totalStreamShares()":{inputs:[],name:"totalStreamShares",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"touchedAt()":{inputs:[],name:"touchedAt",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"treasury()":{inputs:[],name:"treasury",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"unstake(uint256)":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"}],name:"unstake",outputs:[],stateMutability:"nonpayable",type:"function",details:"unstake amount from user shares value. The rest is re-staked",params:{amount:"to unstake"}},"unstakeAll()":{inputs:[],name:"unstakeAll",outputs:[],stateMutability:"nonpayable",type:"function",details:"unstake all the user's shares"},"updateTreasury(address)":{inputs:[{internalType:"address",name:"_treasury",type:"address"}],name:"updateTreasury",outputs:[],stateMutability:"nonpayable",type:"function",details:"restricted for the admin only. Admin should pause this contract before changing the treasury address by setting the pause =1 (for changing this variable, call adminPause(1))",params:{_treasury:"treasury contract address for the reward tokens"},notice:"updates treasury account"},"upgradeTo(address)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"}],name:"upgradeTo",outputs:[],stateMutability:"nonpayable",type:"function",details:"Upgrade the implementation of the proxy to `newImplementation`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."},"upgradeToAndCall(address,bytes)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"},{internalType:"bytes",name:"data",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable",type:"function",details:"Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call encoded in `data`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."},"users(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"users",outputs:[{internalType:"uint256",name:"deposit",type:"uint256"},{internalType:"uint256",name:"auroraShares",type:"uint256"},{internalType:"uint256",name:"streamShares",type:"uint256"}],stateMutability:"view",type:"function"},"withdraw(uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"}],name:"withdraw",outputs:[],stateMutability:"nonpayable",type:"function",details:"withdraw amount in the pending pool. User should wait for pending time (tau constant) in order to be able to withdraw.",params:{streamId:"stream index"}},"withdrawAll()":{inputs:[],name:"withdrawAll",outputs:[],stateMutability:"nonpayable",type:"function",details:"withdraw all claimed balances which have passed pending periode. This function will reach gas limit with too many streams, so the frontend will allow individual stream withdrawals and disable withdrawAll."}}},"contracts/JetStaking/JetStakingV3.sol:JetStakingV3":{source:"contracts/JetStaking/JetStakingV3.sol",name:"JetStakingV3",title:"JetStakingV3",author:"Aurora Team",details:"Implementation of Jet staking contract      This contract implements the staking mechanics for AURORA ERC20 token.      A user can stake any amount of AURORA tokens, and get rewarded in both      AURORA and other stream tokens based on the rewards schedules.      Stream rewards can be claimed any time however AURORA can't be claimed      unless the user unstakes his full/partial amount of shares.      This contract is AdminControlled which has a tremendous power. However      hopfully it be governed by a community wallet.",events:{"AdminChanged(address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"previousAdmin",type:"address"},{indexed:!1,internalType:"address",name:"newAdmin",type:"address"}],name:"AdminChanged",type:"event"},"BeaconUpgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"beacon",type:"address"}],name:"BeaconUpgraded",type:"event"},"Pending(uint256,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"streamId",type:"uint256"},{indexed:!0,internalType:"address",name:"user",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"}],name:"Pending",type:"event"},"Released(uint256,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"streamId",type:"uint256"},{indexed:!0,internalType:"address",name:"user",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"}],name:"Released",type:"event"},"RoleAdminChanged(bytes32,bytes32,bytes32)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"previousAdminRole",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"newAdminRole",type:"bytes32"}],name:"RoleAdminChanged",type:"event"},"RoleGranted(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleGranted",type:"event"},"RoleRevoked(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleRevoked",type:"event"},"Staked(address,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"user",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"},{indexed:!1,internalType:"uint256",name:"shares",type:"uint256"}],name:"Staked",type:"event"},"StreamCreated(uint256,address,address,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"streamId",type:"uint256"},{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"token",type:"address"},{indexed:!1,internalType:"uint256",name:"tokenAmount",type:"uint256"},{indexed:!1,internalType:"uint256",name:"auroraAmount",type:"uint256"}],name:"StreamCreated",type:"event"},"StreamOwnerRewardReleased(uint256,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"streamId",type:"uint256"},{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"}],name:"StreamOwnerRewardReleased",type:"event"},"StreamProposalCancelled(uint256,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"streamId",type:"uint256"},{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"token",type:"address"}],name:"StreamProposalCancelled",type:"event"},"StreamProposed(uint256,address,address,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"streamId",type:"uint256"},{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"token",type:"address"},{indexed:!1,internalType:"uint256",name:"maxDepositAmount",type:"uint256"},{indexed:!1,internalType:"uint256",name:"auroraDepositAmount",type:"uint256"}],name:"StreamProposed",type:"event"},"StreamRemoved(uint256,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"streamId",type:"uint256"},{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"token",type:"address"}],name:"StreamRemoved",type:"event"},"Unstaked(address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"user",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"}],name:"Unstaked",type:"event"},"Upgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"implementation",type:"address"}],name:"Upgraded",type:"event"}},methods:{"AIRDROP_ROLE()":{inputs:[],name:"AIRDROP_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"CLAIM_ROLE()":{inputs:[],name:"CLAIM_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"DEFAULT_ADMIN_ROLE()":{inputs:[],name:"DEFAULT_ADMIN_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"FOUR_YEARS()":{inputs:[],name:"FOUR_YEARS",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"ONE_MONTH()":{inputs:[],name:"ONE_MONTH",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"PAUSE_ROLE()":{inputs:[],name:"PAUSE_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"RPS_MULTIPLIER()":{inputs:[],name:"RPS_MULTIPLIER",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"STREAM_MANAGER_ROLE()":{inputs:[],name:"STREAM_MANAGER_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"adminDelegatecall(address,bytes)":{inputs:[{internalType:"address",name:"target",type:"address"},{internalType:"bytes",name:"data",type:"bytes"}],name:"adminDelegatecall",outputs:[{internalType:"bytes",name:"",type:"bytes"}],stateMutability:"payable",type:"function","custom:oz-upgrades-unsafe-allow":"delegatecall",details:"adminDelegatecall allows this contract to delegate calls to a target contract and execute it in the context of this contract. Only default admin role can call this function.",params:{data:"is the ABI encoded function signature and its values.",target:"the target contract address"}},"adminPause(uint256)":{inputs:[{internalType:"uint256",name:"flags",type:"uint256"}],name:"adminPause",outputs:[],stateMutability:"nonpayable",type:"function",details:"adminPause pauses this contract. Only pause role or default admin role can access this function.",params:{flags:"flags variable is used for pausing this contract."}},"adminSstore(uint256,uint256)":{inputs:[{internalType:"uint256",name:"key",type:"uint256"},{internalType:"uint256",name:"value",type:"uint256"}],name:"adminSstore",outputs:[],stateMutability:"nonpayable",type:"function",details:"adminSstore updates the state variable value. only default admin role can call this function.",params:{key:"is the storage slot of the state variable",value:"is the state variable value"}},"adminSstoreWithMask(uint256,uint256,uint256)":{inputs:[{internalType:"uint256",name:"key",type:"uint256"},{internalType:"uint256",name:"value",type:"uint256"},{internalType:"uint256",name:"mask",type:"uint256"}],name:"adminSstoreWithMask",outputs:[],stateMutability:"nonpayable",type:"function",details:"adminSstoreWithMask similar to adminSstore except it updates the state variable value after xor-ing this value with the old value and the mask, so the new value should be a result of xor(and(xor(value, oldval), mask), oldval). Only default admin role can call this function.",params:{key:"is the storage slot of the state variable",mask:"this value is used in calculating the new value",value:"is the state variable value"}},"auroraToken()":{inputs:[],name:"auroraToken",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"batchClaimOnBehalfOfAnotherUser(address,uint256[])":{inputs:[{internalType:"address",name:"account",type:"address"},{internalType:"uint256[]",name:"streamIds",type:"uint256[]"}],name:"batchClaimOnBehalfOfAnotherUser",outputs:[],stateMutability:"nonpayable",type:"function",details:"batchClaimOnBehalfOfAnotherUser when gas limits prevent users from claiming all.",params:{account:"the user account address.",streamIds:"to claim."}},"batchMoveRewardsToPending(uint256[])":{inputs:[{internalType:"uint256[]",name:"streamIds",type:"uint256[]"}],name:"batchMoveRewardsToPending",outputs:[],stateMutability:"nonpayable",type:"function",details:"moves a set of stream Id rewards to pending. Allows user to select stream ids to claim from UI.",params:{streamIds:"stream indexes"}},"batchWithdraw(uint256[])":{inputs:[{internalType:"uint256[]",name:"streamIds",type:"uint256[]"}],name:"batchWithdraw",outputs:[],stateMutability:"nonpayable",type:"function",details:"withdraw a set of stream Ids. Allows user to select stream ids to withdraw from UI.",params:{streamIds:"to withdraw."}},"c_0x022bfb71(bytes32)":{inputs:[{internalType:"bytes32",name:"c__0x022bfb71",type:"bytes32"}],name:"c_0x022bfb71",outputs:[],stateMutability:"pure",type:"function"},"c_0x7e37e874(bytes32)":{inputs:[{internalType:"bytes32",name:"c__0x7e37e874",type:"bytes32"}],name:"c_0x7e37e874",outputs:[],stateMutability:"pure",type:"function"},"c_0xafbda90b(bytes32)":{inputs:[{internalType:"bytes32",name:"c__0xafbda90b",type:"bytes32"}],name:"c_0xafbda90b",outputs:[],stateMutability:"pure",type:"function"},"cancelStreamProposal(uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"}],name:"cancelStreamProposal",outputs:[],stateMutability:"nonpayable",type:"function",details:"cancelStreamProposal cancels a proposal any time before the stream becomes active (created).",params:{streamId:"the stream index"}},"claimAllOnBehalfOfAnotherUser(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"claimAllOnBehalfOfAnotherUser",outputs:[],stateMutability:"nonpayable",type:"function",details:"Claim all stream rewards on behalf of another user.",params:{account:"the user account address."}},"createStream(uint256,uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"},{internalType:"uint256",name:"rewardTokenAmount",type:"uint256"}],name:"createStream",outputs:[],stateMutability:"nonpayable",type:"function",details:"create new stream (only stream owner) stream owner must approve reward tokens to this contract.",params:{streamId:"stream id"}},"extendAuroraStreamSchedule(uint256[],uint256[])":{inputs:[{internalType:"uint256[]",name:"scheduleTimes",type:"uint256[]"},{internalType:"uint256[]",name:"scheduleRewards",type:"uint256[]"}],name:"extendAuroraStreamSchedule",outputs:[],stateMutability:"nonpayable",type:"function",details:"extend Aurora stream reward schedule. It can be only called by the default contract admin. It can accept extending the schedule if the new schedule is not overlapping with the current schedule. Also, it requires to pause the contract before calling it.",params:{scheduleRewards:"remaining rewards to be delivered at the beginning of each scheduled interval. Last element is always zero.",scheduleTimes:"timestamp denoting the start of each scheduled interval. Last element is the end of the stream."}},"getAmountOfShares(uint256,address)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"},{internalType:"address",name:"account",type:"address"}],name:"getAmountOfShares",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"gets a user stream shares",params:{account:"the user address",streamId:"stream index"},returns:{_0:"user stream shares"}},"getLatestRewardPerShare(uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"}],name:"getLatestRewardPerShare",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"calculates and gets the latest reward per share (RPS) for a stream",params:{streamId:"stream index"},returns:{_0:"streams[streamId].rps + scheduled reward up till now"}},"getPending(uint256,address)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"},{internalType:"address",name:"account",type:"address"}],name:"getPending",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"gets the user's stream pending reward",params:{account:"user account",streamId:"stream index"},returns:{_0:"user.pendings[streamId]"}},"getReleaseTime(uint256,address)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"},{internalType:"address",name:"account",type:"address"}],name:"getReleaseTime",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"gets the user's stream reward release time",params:{account:"user account",streamId:"stream index"},returns:{_0:"user.releaseTime[streamId]"}},"getRewardPerShare(uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"}],name:"getRewardPerShare",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"gets reward per share (RPS) for a stream",params:{streamId:"stream index"},returns:{_0:"streams[streamId].rps"}},"getRewardPerShareForUser(uint256,address)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"},{internalType:"address",name:"account",type:"address"}],name:"getRewardPerShareForUser",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"gets the user's reward per share (RPS) for a stream",params:{streamId:"stream index"},returns:{_0:"user.rpsDuringLastClaim[streamId]"}},"getRewardsAmount(uint256,uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"},{internalType:"uint256",name:"lastUpdate",type:"uint256"}],name:"getRewardsAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"calculates and gets the latest released rewards.",params:{streamId:"stream index"},returns:{_0:"rewards released since last update."}},"getRoleAdmin(bytes32)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"}],name:"getRoleAdmin",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}."},"getStream(uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"}],name:"getStream",outputs:[{internalType:"address",name:"streamOwner",type:"address"},{internalType:"address",name:"rewardToken",type:"address"},{internalType:"uint256",name:"auroraDepositAmount",type:"uint256"},{internalType:"uint256",name:"auroraClaimedAmount",type:"uint256"},{internalType:"uint256",name:"rewardDepositAmount",type:"uint256"},{internalType:"uint256",name:"rewardClaimedAmount",type:"uint256"},{internalType:"uint256",name:"maxDepositAmount",type:"uint256"},{internalType:"uint256",name:"lastTimeOwnerClaimed",type:"uint256"},{internalType:"uint256",name:"rps",type:"uint256"},{internalType:"uint256",name:"tau",type:"uint256"},{internalType:"enum JetStakingV2.StreamStatus",name:"status",type:"uint8"}],stateMutability:"view",type:"function",details:"get the stream data",params:{streamId:"the stream index"},notice:"this function doesn't return the stream schedule due to some stake slots limitations. To get the stream schedule, refer to getStreamSchedule"},"getStreamClaimableAmount(uint256,address)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"},{internalType:"address",name:"account",type:"address"}],name:"getStreamClaimableAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"gets the user's stream claimable amount",params:{streamId:"stream index"},returns:{_0:"(latesRPS - user.rpsDuringLastClaim) * user.shares"}},"getStreamOwnerClaimableAmount(uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"}],name:"getStreamOwnerClaimableAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Stream owner claimable AURORA.",params:{streamId:"the stream index"}},"getStreamSchedule(uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"}],name:"getStreamSchedule",outputs:[{internalType:"uint256[]",name:"scheduleTimes",type:"uint256[]"},{internalType:"uint256[]",name:"scheduleRewards",type:"uint256[]"}],stateMutability:"view",type:"function",details:"get the stream schedule data",params:{streamId:"the stream index"}},"getStreamsCount()":{inputs:[],name:"getStreamsCount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"get the streams count",returns:{_0:"streams.length"}},"getTotalAmountOfStakedAurora()":{inputs:[],name:"getTotalAmountOfStakedAurora",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"gets the total amount of staked aurora",returns:{_0:"totalAmountOfStakedAurora + latest reward schedule"}},"getTreasuryBalance(address)":{inputs:[{internalType:"address",name:"token",type:"address"}],name:"getTreasuryBalance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Get the treasury balance",params:{token:"the token address"}},"getUserShares(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"getUserShares",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"gets the user shares",params:{account:"the user address"},returns:{_0:"user shares"}},"getUserTotalDeposit(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"getUserTotalDeposit",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"gets the total user deposit",params:{account:"the user address"},returns:{_0:"user total deposit in (AURORA)"}},"grantRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"grantRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role."},"hasRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"hasRole",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns `true` if `account` has been granted `role`."},"initialize(address,address,uint256[],uint256[],uint256,uint256,address,uint256,uint256)":{inputs:[{internalType:"address",name:"aurora",type:"address"},{internalType:"address",name:"streamOwner",type:"address"},{internalType:"uint256[]",name:"scheduleTimes",type:"uint256[]"},{internalType:"uint256[]",name:"scheduleRewards",type:"uint256[]"},{internalType:"uint256",name:"tauAuroraStream",type:"uint256"},{internalType:"uint256",name:"_flags",type:"uint256"},{internalType:"address",name:"_treasury",type:"address"},{internalType:"uint256",name:"_maxWeight",type:"uint256"},{internalType:"uint256",name:"_minWeight",type:"uint256"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function",details:"initialize the contract and deploys the first stream (AURORA)",params:{_flags:"admin controlled contract flags",_maxWeight:"max stream reward weighting coefficient",_minWeight:"min stream reward weighting coefficient",_treasury:"the Aurora treasury contract address",aurora:"token contract address",scheduleRewards:"init the schedule amounts",scheduleTimes:"init the schedule time",tauAuroraStream:"release time constant per stream (e.g AURORA stream)"},notice:"By calling this function, the deployer of this contract must make sure that the AURORA reward amount was deposited to the treasury contract before initializing of the default AURORA stream."},"initializeOldWeightedStreams()":{inputs:[],name:"initializeOldWeightedStreams",outputs:[],stateMutability:"nonpayable",type:"function",details:"set the old weighted share streams",notice:"This function must be called prior upgrading the contract. And the contract must be paused before initializing it."},"maxWeight()":{inputs:[],name:"maxWeight",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"minWeight()":{inputs:[],name:"minWeight",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"moveAllRewardsToPending()":{inputs:[],name:"moveAllRewardsToPending",outputs:[],stateMutability:"nonpayable",type:"function",details:"moves all the user rewards to pending reward."},"moveRewardsToPending(uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"}],name:"moveRewardsToPending",outputs:[],stateMutability:"nonpayable",type:"function",details:"moves the reward for specific stream Id to pending rewards. It will require a waiting time untill it get released. Users call this in function in order to claim rewards.",params:{streamId:"stream index"}},"oldWeightedShareStreams(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"oldWeightedShareStreams",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"paused()":{inputs:[],name:"paused",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"proposeStream(address,address,uint256,uint256,uint256,uint256[],uint256[],uint256)":{inputs:[{internalType:"address",name:"streamOwner",type:"address"},{internalType:"address",name:"rewardToken",type:"address"},{internalType:"uint256",name:"auroraDepositAmount",type:"uint256"},{internalType:"uint256",name:"maxDepositAmount",type:"uint256"},{internalType:"uint256",name:"minDepositAmount",type:"uint256"},{internalType:"uint256[]",name:"scheduleTimes",type:"uint256[]"},{internalType:"uint256[]",name:"scheduleRewards",type:"uint256[]"},{internalType:"uint256",name:"tau",type:"uint256"}],name:"proposeStream",outputs:[],stateMutability:"nonpayable",type:"function",details:"An admin of the staking contract can whitelist (propose) a stream. Whitelisting of the stream provides the option for the stream owner (presumably the issuing party of a specific token) to deposit some ERC-20 tokens on the staking contract and potentially get in return some AURORA tokens. Deposited ERC-20 tokens will be distributed to the stakers over some period of time.",params:{auroraDepositAmount:"Amount of the AURORA deposited by the Admin.",maxDepositAmount:"The upper amount of the tokens that should be deposited by the stream owner",rewardToken:"the address of the ERC-20 tokens to be deposited in the stream",scheduleRewards:"remaining rewards to be delivered at the beginning of each scheduled interval. Last element is always zero. First value (in scheduleRewards) from array is supposed to be a total amount of rewards for stream.",scheduleTimes:"timestamp denoting the start of each scheduled interval. Last element is the end of the stream.",streamOwner:"only this account would be able to create a stream",tau:"the tau is (pending release period) for this stream (e.g one day)"},notice:"treasury manager must call"},"releaseAuroraRewardsToStreamOwner(uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"}],name:"releaseAuroraRewardsToStreamOwner",outputs:[],stateMutability:"nonpayable",type:"function",details:"the release of AURORA tokens to the stream owner is subjected to the same schedule as rewards. Thus if for a specific moment in time 30% of the rewards are distributed, then it means that 30% of the AURORA deposit can be withdrawn by the stream owner too. called by the stream owner",params:{streamId:"the stream index"}},"removeStream(uint256,address)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"},{internalType:"address",name:"streamFundReceiver",type:"address"}],name:"removeStream",outputs:[],stateMutability:"nonpayable",type:"function",details:"removes a stream (only default admin role)",params:{streamFundReceiver:"receives the rest of the reward tokens in the stream",streamId:"stream index"}},"renounceRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"renounceRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been revoked `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`."},"revokeRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"revokeRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role."},"rewardsSchedule(uint256,uint256,uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"},{internalType:"uint256",name:"start",type:"uint256"},{internalType:"uint256",name:"end",type:"uint256"}],name:"rewardsSchedule",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"calculate the total amount of the released tokens within a period (start & end)",params:{end:"is the end timestamp (e.g block.timestamp .. now)",start:"is the start timestamp within the schedule",streamId:"the stream index"},returns:{_0:"amount of the released tokens for that period"}},"stake(uint256)":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"}],name:"stake",outputs:[],stateMutability:"nonpayable",type:"function",details:"a user stakes amount of AURORA tokens The user should approve these tokens to the treasury contract in order to complete the stake.",params:{amount:"is the AURORA amount."}},"stakeOnBehalfOfAnotherUser(address,uint256)":{inputs:[{internalType:"address",name:"account",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"stakeOnBehalfOfAnotherUser",outputs:[],stateMutability:"nonpayable",type:"function",details:"stakeOnBehalfOfAnotherUser is called for airdropping Aurora users",params:{account:"the account address",amount:"in AURORA tokens WARNING: rewards are not claimed during stake. Airdrop script must claim or only distribute to accounts without stake"}},"startEndScheduleIndex(uint256,uint256,uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"},{internalType:"uint256",name:"start",type:"uint256"},{internalType:"uint256",name:"end",type:"uint256"}],name:"startEndScheduleIndex",outputs:[{internalType:"uint256",name:"startIndex",type:"uint256"},{internalType:"uint256",name:"endIndex",type:"uint256"}],stateMutability:"view",type:"function",details:"gets start index and end index in a stream schedule",params:{end:"end time (in seconds)",start:"start time (in seconds)",streamId:"stream index"}},"supportsInterface(bytes4)":{inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"See {IERC165-supportsInterface}."},"totalAmountOfStakedAurora()":{inputs:[],name:"totalAmountOfStakedAurora",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"totalAuroraShares()":{inputs:[],name:"totalAuroraShares",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"totalStreamShares()":{inputs:[],name:"totalStreamShares",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"touchedAt()":{inputs:[],name:"touchedAt",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"treasury()":{inputs:[],name:"treasury",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"unstake(uint256)":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"}],name:"unstake",outputs:[],stateMutability:"nonpayable",type:"function",details:"unstake amount from user shares value. The rest is re-staked",params:{amount:"to unstake"}},"unstakeAll()":{inputs:[],name:"unstakeAll",outputs:[],stateMutability:"nonpayable",type:"function",details:"unstake all the user's shares"},"updateTreasury(address)":{inputs:[{internalType:"address",name:"_treasury",type:"address"}],name:"updateTreasury",outputs:[],stateMutability:"nonpayable",type:"function",details:"restricted for the admin only. Admin should pause this contract before changing the treasury address by setting the pause =1 (for changing this variable, call adminPause(1))",params:{_treasury:"treasury contract address for the reward tokens"},notice:"updates treasury account"},"upgradeTo(address)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"}],name:"upgradeTo",outputs:[],stateMutability:"nonpayable",type:"function",details:"Upgrade the implementation of the proxy to `newImplementation`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."},"upgradeToAndCall(address,bytes)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"},{internalType:"bytes",name:"data",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable",type:"function",details:"Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call encoded in `data`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."},"users(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"users",outputs:[{internalType:"uint256",name:"deposit",type:"uint256"},{internalType:"uint256",name:"auroraShares",type:"uint256"},{internalType:"uint256",name:"streamShares",type:"uint256"}],stateMutability:"view",type:"function"},"withdraw(uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"}],name:"withdraw",outputs:[],stateMutability:"nonpayable",type:"function",details:"withdraw amount in the pending pool. User should wait for pending time (tau constant) in order to be able to withdraw.",params:{streamId:"stream index"}},"withdrawAll()":{inputs:[],name:"withdrawAll",outputs:[],stateMutability:"nonpayable",type:"function",details:"withdraw all claimed balances which have passed pending periode. This function will reach gas limit with too many streams, so the frontend will allow individual stream withdrawals and disable withdrawAll."}}},"contracts/Treasury.sol:Treasury":{source:"contracts/Treasury.sol",name:"Treasury",title:"Treasury",author:"Aurora Team",details:"Implementation of the treasury contract      This contract is holding all the aurora staking and streams funds.      It inherits adminControlled which gives admin more privilegs over this      this contract.",constructor:{inputs:[],stateMutability:"nonpayable",type:"constructor"},events:{"AdminChanged(address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"previousAdmin",type:"address"},{indexed:!1,internalType:"address",name:"newAdmin",type:"address"}],name:"AdminChanged",type:"event"},"BeaconUpgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"beacon",type:"address"}],name:"BeaconUpgraded",type:"event"},"RoleAdminChanged(bytes32,bytes32,bytes32)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"previousAdminRole",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"newAdminRole",type:"bytes32"}],name:"RoleAdminChanged",type:"event"},"RoleGranted(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleGranted",type:"event"},"RoleRevoked(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleRevoked",type:"event"},"TokenAdded(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"token",type:"address"},{indexed:!0,internalType:"address",name:"addedBy",type:"address"},{indexed:!1,internalType:"uint256",name:"timestamp",type:"uint256"}],name:"TokenAdded",type:"event"},"TokenRemoved(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"token",type:"address"},{indexed:!0,internalType:"address",name:"addedBy",type:"address"},{indexed:!1,internalType:"uint256",name:"timestamp",type:"uint256"}],name:"TokenRemoved",type:"event"},"Upgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"implementation",type:"address"}],name:"Upgraded",type:"event"}},methods:{"DEFAULT_ADMIN_ROLE()":{inputs:[],name:"DEFAULT_ADMIN_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"PAUSE_ROLE()":{inputs:[],name:"PAUSE_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"TREASURY_MANAGER_ROLE()":{inputs:[],name:"TREASURY_MANAGER_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"addSupportedToken(address)":{inputs:[{internalType:"address",name:"_token",type:"address"}],name:"addSupportedToken",outputs:[],stateMutability:"nonpayable",type:"function",params:{_token:"stream ERC20 token address"},notice:"adds token as a supproted rewards token by Treasury supported tokens means any future stream token should be whitelisted here"},"adminDelegatecall(address,bytes)":{inputs:[{internalType:"address",name:"target",type:"address"},{internalType:"bytes",name:"data",type:"bytes"}],name:"adminDelegatecall",outputs:[{internalType:"bytes",name:"",type:"bytes"}],stateMutability:"payable",type:"function","custom:oz-upgrades-unsafe-allow":"delegatecall",details:"adminDelegatecall allows this contract to delegate calls to a target contract and execute it in the context of this contract. Only default admin role can call this function.",params:{data:"is the ABI encoded function signature and its values.",target:"the target contract address"}},"adminPause(uint256)":{inputs:[{internalType:"uint256",name:"flags",type:"uint256"}],name:"adminPause",outputs:[],stateMutability:"nonpayable",type:"function",details:"adminPause pauses this contract. Only pause role or default admin role can access this function.",params:{flags:"flags variable is used for pausing this contract."}},"adminSstore(uint256,uint256)":{inputs:[{internalType:"uint256",name:"key",type:"uint256"},{internalType:"uint256",name:"value",type:"uint256"}],name:"adminSstore",outputs:[],stateMutability:"nonpayable",type:"function",details:"adminSstore updates the state variable value. only default admin role can call this function.",params:{key:"is the storage slot of the state variable",value:"is the state variable value"}},"adminSstoreWithMask(uint256,uint256,uint256)":{inputs:[{internalType:"uint256",name:"key",type:"uint256"},{internalType:"uint256",name:"value",type:"uint256"},{internalType:"uint256",name:"mask",type:"uint256"}],name:"adminSstoreWithMask",outputs:[],stateMutability:"nonpayable",type:"function",details:"adminSstoreWithMask similar to adminSstore except it updates the state variable value after xor-ing this value with the old value and the mask, so the new value should be a result of xor(and(xor(value, oldval), mask), oldval). Only default admin role can call this function.",params:{key:"is the storage slot of the state variable",mask:"this value is used in calculating the new value",value:"is the state variable value"}},"c_0x47b6ea16(bytes32)":{inputs:[{internalType:"bytes32",name:"c__0x47b6ea16",type:"bytes32"}],name:"c_0x47b6ea16",outputs:[],stateMutability:"pure",type:"function"},"c_0x7e37e874(bytes32)":{inputs:[{internalType:"bytes32",name:"c__0x7e37e874",type:"bytes32"}],name:"c_0x7e37e874",outputs:[],stateMutability:"pure",type:"function"},"getRoleAdmin(bytes32)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"}],name:"getRoleAdmin",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}."},"grantRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"grantRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role."},"hasRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"hasRole",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns `true` if `account` has been granted `role`."},"initialize(address[],uint256)":{inputs:[{internalType:"address[]",name:"_supportedTokens",type:"address[]"},{internalType:"uint256",name:"_flags",type:"uint256"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function",params:{_supportedTokens:"list of supported tokens"},notice:"initializes ownable Treasury with list of managers and supported tokens"},"isSupportedToken(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"isSupportedToken",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"paused()":{inputs:[],name:"paused",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"payRewards(address,address,uint256)":{inputs:[{internalType:"address",name:"_user",type:"address"},{internalType:"address",name:"_token",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"}],name:"payRewards",outputs:[],stateMutability:"nonpayable",type:"function",details:"Used by jet staking contracts",params:{_amount:"token to transfer to user",_token:"token to transfer to user",_user:"user to transfer tokens to"},notice:"transfers token amount from Treasury balance to user."},"removeSupportedToken(address)":{inputs:[{internalType:"address",name:"_token",type:"address"}],name:"removeSupportedToken",outputs:[],stateMutability:"nonpayable",type:"function",params:{_token:"stream ERC20 token address"},notice:"removed token as a supproted rewards token by Treasury"},"renounceRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"renounceRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been revoked `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`."},"revokeRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"revokeRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role."},"supportsInterface(bytes4)":{inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"See {IERC165-supportsInterface}."},"upgradeTo(address)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"}],name:"upgradeTo",outputs:[],stateMutability:"nonpayable",type:"function",details:"Upgrade the implementation of the proxy to `newImplementation`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."},"upgradeToAndCall(address,bytes)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"},{internalType:"bytes",name:"data",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable",type:"function",details:"Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call encoded in `data`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."}}},"contracts/testing/AdminControlledTesting.sol:AdminControlledTesting":{source:"contracts/testing/AdminControlledTesting.sol",name:"AdminControlledTesting",events:{"AdminChanged(address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"previousAdmin",type:"address"},{indexed:!1,internalType:"address",name:"newAdmin",type:"address"}],name:"AdminChanged",type:"event"},"BeaconUpgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"beacon",type:"address"}],name:"BeaconUpgraded",type:"event"},"RoleAdminChanged(bytes32,bytes32,bytes32)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"previousAdminRole",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"newAdminRole",type:"bytes32"}],name:"RoleAdminChanged",type:"event"},"RoleGranted(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleGranted",type:"event"},"RoleRevoked(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleRevoked",type:"event"},"Upgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"implementation",type:"address"}],name:"Upgraded",type:"event"}},methods:{"DEFAULT_ADMIN_ROLE()":{inputs:[],name:"DEFAULT_ADMIN_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"PAUSE_ROLE()":{inputs:[],name:"PAUSE_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"adminDelegatecall(address,bytes)":{inputs:[{internalType:"address",name:"target",type:"address"},{internalType:"bytes",name:"data",type:"bytes"}],name:"adminDelegatecall",outputs:[{internalType:"bytes",name:"",type:"bytes"}],stateMutability:"payable",type:"function","custom:oz-upgrades-unsafe-allow":"delegatecall",details:"adminDelegatecall allows this contract to delegate calls to a target contract and execute it in the context of this contract. Only default admin role can call this function.",params:{data:"is the ABI encoded function signature and its values.",target:"the target contract address"}},"adminPause(uint256)":{inputs:[{internalType:"uint256",name:"flags",type:"uint256"}],name:"adminPause",outputs:[],stateMutability:"nonpayable",type:"function",details:"adminPause pauses this contract. Only pause role or default admin role can access this function.",params:{flags:"flags variable is used for pausing this contract."}},"adminSstore(uint256,uint256)":{inputs:[{internalType:"uint256",name:"key",type:"uint256"},{internalType:"uint256",name:"value",type:"uint256"}],name:"adminSstore",outputs:[],stateMutability:"nonpayable",type:"function",details:"adminSstore updates the state variable value. only default admin role can call this function.",params:{key:"is the storage slot of the state variable",value:"is the state variable value"}},"adminSstoreWithMask(uint256,uint256,uint256)":{inputs:[{internalType:"uint256",name:"key",type:"uint256"},{internalType:"uint256",name:"value",type:"uint256"},{internalType:"uint256",name:"mask",type:"uint256"}],name:"adminSstoreWithMask",outputs:[],stateMutability:"nonpayable",type:"function",details:"adminSstoreWithMask similar to adminSstore except it updates the state variable value after xor-ing this value with the old value and the mask, so the new value should be a result of xor(and(xor(value, oldval), mask), oldval). Only default admin role can call this function.",params:{key:"is the storage slot of the state variable",mask:"this value is used in calculating the new value",value:"is the state variable value"}},"c_0x7e37e874(bytes32)":{inputs:[{internalType:"bytes32",name:"c__0x7e37e874",type:"bytes32"}],name:"c_0x7e37e874",outputs:[],stateMutability:"pure",type:"function"},"c_0xf34392a1(bytes32)":{inputs:[{internalType:"bytes32",name:"c__0xf34392a1",type:"bytes32"}],name:"c_0xf34392a1",outputs:[],stateMutability:"pure",type:"function"},"changeMe()":{inputs:[],name:"changeMe",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"getRoleAdmin(bytes32)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"}],name:"getRoleAdmin",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}."},"getSignatureForTokenMinting()":{inputs:[],name:"getSignatureForTokenMinting",outputs:[{internalType:"bytes",name:"",type:"bytes"}],stateMutability:"nonpayable",type:"function"},"grantRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"grantRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role."},"hasRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"hasRole",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns `true` if `account` has been granted `role`."},"initialize(uint256)":{inputs:[{internalType:"uint256",name:"flags",type:"uint256"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function"},"pauseMe()":{inputs:[],name:"pauseMe",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function"},"paused()":{inputs:[],name:"paused",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"renounceRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"renounceRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been revoked `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`."},"revokeRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"revokeRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role."},"supportsInterface(bytes4)":{inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"See {IERC165-supportsInterface}."},"upgradeTo(address)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"}],name:"upgradeTo",outputs:[],stateMutability:"nonpayable",type:"function",details:"Upgrade the implementation of the proxy to `newImplementation`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."},"upgradeToAndCall(address,bytes)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"},{internalType:"bytes",name:"data",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable",type:"function",details:"Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call encoded in `data`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."}}},"contracts/testing/AdminControlledTesting.sol:TargetContract":{source:"contracts/testing/AdminControlledTesting.sol",name:"TargetContract",methods:{"c_0x6b699700(bytes32)":{inputs:[{internalType:"bytes32",name:"c__0x6b699700",type:"bytes32"}],name:"c_0x6b699700",outputs:[],stateMutability:"pure",type:"function"},"name()":{inputs:[],name:"name",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function"},"sender()":{inputs:[],name:"sender",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"targetFunction(string)":{inputs:[{internalType:"string",name:"_nameTarget",type:"string"}],name:"targetFunction",outputs:[],stateMutability:"payable",type:"function"},"value()":{inputs:[],name:"value",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"}}},"contracts/testing/JetStakingTestingV1.sol:JetStakingTestingV1":{source:"contracts/testing/JetStakingTestingV1.sol",name:"JetStakingTestingV1",events:{"AdminChanged(address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"previousAdmin",type:"address"},{indexed:!1,internalType:"address",name:"newAdmin",type:"address"}],name:"AdminChanged",type:"event"},"BeaconUpgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"beacon",type:"address"}],name:"BeaconUpgraded",type:"event"},"Pending(uint256,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"streamId",type:"uint256"},{indexed:!0,internalType:"address",name:"user",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"}],name:"Pending",type:"event"},"Released(uint256,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"streamId",type:"uint256"},{indexed:!0,internalType:"address",name:"user",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"}],name:"Released",type:"event"},"RoleAdminChanged(bytes32,bytes32,bytes32)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"previousAdminRole",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"newAdminRole",type:"bytes32"}],name:"RoleAdminChanged",type:"event"},"RoleGranted(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleGranted",type:"event"},"RoleRevoked(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleRevoked",type:"event"},"Staked(address,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"user",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"},{indexed:!1,internalType:"uint256",name:"shares",type:"uint256"}],name:"Staked",type:"event"},"StreamCreated(uint256,address,address,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"streamId",type:"uint256"},{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"token",type:"address"},{indexed:!1,internalType:"uint256",name:"tokenAmount",type:"uint256"},{indexed:!1,internalType:"uint256",name:"auroraAmount",type:"uint256"}],name:"StreamCreated",type:"event"},"StreamOwnerRewardReleased(uint256,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"streamId",type:"uint256"},{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"}],name:"StreamOwnerRewardReleased",type:"event"},"StreamProposalCancelled(uint256,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"streamId",type:"uint256"},{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"token",type:"address"}],name:"StreamProposalCancelled",type:"event"},"StreamProposed(uint256,address,address,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"streamId",type:"uint256"},{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"token",type:"address"},{indexed:!1,internalType:"uint256",name:"maxDepositAmount",type:"uint256"},{indexed:!1,internalType:"uint256",name:"auroraDepositAmount",type:"uint256"}],name:"StreamProposed",type:"event"},"StreamRemoved(uint256,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"streamId",type:"uint256"},{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"token",type:"address"}],name:"StreamRemoved",type:"event"},"Unstaked(address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"user",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"}],name:"Unstaked",type:"event"},"Upgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"implementation",type:"address"}],name:"Upgraded",type:"event"}},methods:{"AIRDROP_ROLE()":{inputs:[],name:"AIRDROP_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"CLAIM_ROLE()":{inputs:[],name:"CLAIM_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"DEFAULT_ADMIN_ROLE()":{inputs:[],name:"DEFAULT_ADMIN_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"FOUR_YEARS()":{inputs:[],name:"FOUR_YEARS",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"ONE_MONTH()":{inputs:[],name:"ONE_MONTH",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"PAUSE_ROLE()":{inputs:[],name:"PAUSE_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"STREAM_MANAGER_ROLE()":{inputs:[],name:"STREAM_MANAGER_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"adminDelegatecall(address,bytes)":{inputs:[{internalType:"address",name:"target",type:"address"},{internalType:"bytes",name:"data",type:"bytes"}],name:"adminDelegatecall",outputs:[{internalType:"bytes",name:"",type:"bytes"}],stateMutability:"payable",type:"function","custom:oz-upgrades-unsafe-allow":"delegatecall",details:"adminDelegatecall allows this contract to delegate calls to a target contract and execute it in the context of this contract. Only default admin role can call this function.",params:{data:"is the ABI encoded function signature and its values.",target:"the target contract address"}},"adminPause(uint256)":{inputs:[{internalType:"uint256",name:"flags",type:"uint256"}],name:"adminPause",outputs:[],stateMutability:"nonpayable",type:"function",details:"adminPause pauses this contract. Only pause role or default admin role can access this function.",params:{flags:"flags variable is used for pausing this contract."}},"adminSstore(uint256,uint256)":{inputs:[{internalType:"uint256",name:"key",type:"uint256"},{internalType:"uint256",name:"value",type:"uint256"}],name:"adminSstore",outputs:[],stateMutability:"nonpayable",type:"function",details:"adminSstore updates the state variable value. only default admin role can call this function.",params:{key:"is the storage slot of the state variable",value:"is the state variable value"}},"adminSstoreWithMask(uint256,uint256,uint256)":{inputs:[{internalType:"uint256",name:"key",type:"uint256"},{internalType:"uint256",name:"value",type:"uint256"},{internalType:"uint256",name:"mask",type:"uint256"}],name:"adminSstoreWithMask",outputs:[],stateMutability:"nonpayable",type:"function",details:"adminSstoreWithMask similar to adminSstore except it updates the state variable value after xor-ing this value with the old value and the mask, so the new value should be a result of xor(and(xor(value, oldval), mask), oldval). Only default admin role can call this function.",params:{key:"is the storage slot of the state variable",mask:"this value is used in calculating the new value",value:"is the state variable value"}},"auroraToken()":{inputs:[],name:"auroraToken",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"batchClaimOnBehalfOfAnotherUser(address,uint256[])":{inputs:[{internalType:"address",name:"account",type:"address"},{internalType:"uint256[]",name:"streamIds",type:"uint256[]"}],name:"batchClaimOnBehalfOfAnotherUser",outputs:[],stateMutability:"nonpayable",type:"function",details:"batchClaimOnBehalfOfAnotherUser when gas limits prevent users from claiming all.",params:{account:"the user account address.",streamIds:"to claim."}},"batchClaimOnBehalfOfOtherUsers(address[],uint256[])":{inputs:[{internalType:"address[]",name:"accounts",type:"address[]"},{internalType:"uint256[]",name:"streamIds",type:"uint256[]"}],name:"batchClaimOnBehalfOfOtherUsers",outputs:[],stateMutability:"nonpayable",type:"function",details:"Claim all stream rewards on behalf of other users.",params:{accounts:"the user account addresses."}},"batchMoveRewardsToPending(uint256[])":{inputs:[{internalType:"uint256[]",name:"streamIds",type:"uint256[]"}],name:"batchMoveRewardsToPending",outputs:[],stateMutability:"nonpayable",type:"function",details:"moves a set of stream Id rewards to pending. Allows user to select stream ids to claim from UI.",params:{streamIds:"stream indexes"}},"batchWithdraw(uint256[])":{inputs:[{internalType:"uint256[]",name:"streamIds",type:"uint256[]"}],name:"batchWithdraw",outputs:[],stateMutability:"nonpayable",type:"function",details:"withdraw a set of stream Ids. Allows user to select stream ids to withdraw from UI.",params:{streamIds:"to withdraw."}},"before(uint256,uint256)":{inputs:[{internalType:"uint256",name:"startTime",type:"uint256"},{internalType:"uint256",name:"endTime",type:"uint256"}],name:"before",outputs:[{internalType:"uint256",name:"total",type:"uint256"},{internalType:"uint256",name:"rewardPerShareAurora",type:"uint256"},{internalType:"uint256",name:"scheduleCalculated",type:"uint256"}],stateMutability:"view",type:"function"},"c_0x7e37e874(bytes32)":{inputs:[{internalType:"bytes32",name:"c__0x7e37e874",type:"bytes32"}],name:"c_0x7e37e874",outputs:[],stateMutability:"pure",type:"function"},"c_0xc1dd3536(bytes32)":{inputs:[{internalType:"bytes32",name:"c__0xc1dd3536",type:"bytes32"}],name:"c_0xc1dd3536",outputs:[],stateMutability:"pure",type:"function"},"c_0xdf09e261(bytes32)":{inputs:[{internalType:"bytes32",name:"c__0xdf09e261",type:"bytes32"}],name:"c_0xdf09e261",outputs:[],stateMutability:"pure",type:"function"},"calculateWeightedShares(uint256,uint256)":{inputs:[{internalType:"uint256",name:"shares",type:"uint256"},{internalType:"uint256",name:"timestamp",type:"uint256"}],name:"calculateWeightedShares",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"callBeforeTwice()":{inputs:[],name:"callBeforeTwice",outputs:[],stateMutability:"nonpayable",type:"function"},"cancelStreamProposal(uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"}],name:"cancelStreamProposal",outputs:[],stateMutability:"nonpayable",type:"function",details:"cancelStreamProposal cancels a proposal any time before the stream becomes active (created).",params:{streamId:"the stream index"}},"claimAllOnBehalfOfAnotherUser(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"claimAllOnBehalfOfAnotherUser",outputs:[],stateMutability:"nonpayable",type:"function",details:"Claim all stream rewards on behalf of another user.",params:{account:"the user account address."}},"claimAllOnBehalfOfOtherUsers(address[])":{inputs:[{internalType:"address[]",name:"accounts",type:"address[]"}],name:"claimAllOnBehalfOfOtherUsers",outputs:[],stateMutability:"nonpayable",type:"function",details:"Claim all stream rewards on behalf of other users.",params:{accounts:"the user account addresses."}},"claimOnBehalfOfAnotherUser(address,uint256)":{inputs:[{internalType:"address",name:"account",type:"address"},{internalType:"uint256",name:"streamId",type:"uint256"}],name:"claimOnBehalfOfAnotherUser",outputs:[],stateMutability:"nonpayable",type:"function",details:"Claim a stream's rewards on behalf of another user.",params:{account:"the user account address.",streamId:"to claim."}},"createStream(uint256,uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"},{internalType:"uint256",name:"rewardTokenAmount",type:"uint256"}],name:"createStream",outputs:[],stateMutability:"nonpayable",type:"function",details:"create new stream (only stream owner) stream owner must approve reward tokens to this contract.",params:{streamId:"stream id"}},"getAmountOfShares(uint256,address)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"},{internalType:"address",name:"account",type:"address"}],name:"getAmountOfShares",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"gets a user stream shares",params:{account:"the user address",streamId:"stream index"},returns:{_0:"user stream shares"}},"getLatestRewardPerShare(uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"}],name:"getLatestRewardPerShare",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"calculates and gets the latest reward per share (RPS) for a stream",params:{streamId:"stream index"},returns:{_0:"streams[streamId].rps + scheduled reward up till now"}},"getPending(uint256,address)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"},{internalType:"address",name:"account",type:"address"}],name:"getPending",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"gets the user's stream pending reward",params:{account:"user account",streamId:"stream index"},returns:{_0:"user.pendings[streamId]"}},"getReleaseTime(uint256,address)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"},{internalType:"address",name:"account",type:"address"}],name:"getReleaseTime",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"gets the user's stream reward release time",params:{account:"user account",streamId:"stream index"},returns:{_0:"user.releaseTime[streamId]"}},"getRewardPerShare(uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"}],name:"getRewardPerShare",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"gets reward per share (RPS) for a stream",params:{streamId:"stream index"},returns:{_0:"streams[streamId].rps"}},"getRewardPerShareForUser(uint256,address)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"},{internalType:"address",name:"account",type:"address"}],name:"getRewardPerShareForUser",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"gets the user's reward per share (RPS) for a stream",params:{streamId:"stream index"},returns:{_0:"user.rpsDuringLastClaim[streamId]"}},"getRewardsAmount(uint256,uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"},{internalType:"uint256",name:"lastUpdate",type:"uint256"}],name:"getRewardsAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"calculates and gets the latest released rewards.",params:{streamId:"stream index"},returns:{_0:"rewards released since last update."}},"getRoleAdmin(bytes32)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"}],name:"getRoleAdmin",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}."},"getStream(uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"}],name:"getStream",outputs:[{internalType:"address",name:"streamOwner",type:"address"},{internalType:"address",name:"rewardToken",type:"address"},{internalType:"uint256",name:"auroraDepositAmount",type:"uint256"},{internalType:"uint256",name:"auroraClaimedAmount",type:"uint256"},{internalType:"uint256",name:"rewardDepositAmount",type:"uint256"},{internalType:"uint256",name:"rewardClaimedAmount",type:"uint256"},{internalType:"uint256",name:"maxDepositAmount",type:"uint256"},{internalType:"uint256",name:"lastTimeOwnerClaimed",type:"uint256"},{internalType:"uint256",name:"rps",type:"uint256"},{internalType:"uint256",name:"tau",type:"uint256"},{internalType:"enum JetStakingV1.StreamStatus",name:"status",type:"uint8"}],stateMutability:"view",type:"function",details:"get the stream data",params:{streamId:"the stream index"},notice:"this function doesn't return the stream schedule due to some stake slots limitations. To get the stream schedule, refer to getStreamSchedule"},"getStreamClaimableAmount(uint256,address)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"},{internalType:"address",name:"account",type:"address"}],name:"getStreamClaimableAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"gets the user's stream claimable amount",params:{streamId:"stream index"},returns:{_0:"(latesRPS - user.rpsDuringLastClaim) * user.shares"}},"getStreamOwnerClaimableAmount(uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"}],name:"getStreamOwnerClaimableAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Stream owner claimable AURORA.",params:{streamId:"the stream index"}},"getStreamSchedule(uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"}],name:"getStreamSchedule",outputs:[{internalType:"uint256[]",name:"scheduleTimes",type:"uint256[]"},{internalType:"uint256[]",name:"scheduleRewards",type:"uint256[]"}],stateMutability:"view",type:"function",details:"get the stream schedule data",params:{streamId:"the stream index"}},"getStreamsCount()":{inputs:[],name:"getStreamsCount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"get the streams count",returns:{_0:"streams.length"}},"getTotalAmountOfStakedAurora()":{inputs:[],name:"getTotalAmountOfStakedAurora",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"gets the total amount of staked aurora",returns:{_0:"totalAmountOfStakedAurora + latest reward schedule"}},"getTreasuryBalance(address)":{inputs:[{internalType:"address",name:"token",type:"address"}],name:"getTreasuryBalance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Get the treasury balance",params:{token:"the token address"}},"getUserShares(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"getUserShares",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"gets the user shares",params:{account:"the user address"},returns:{_0:"user shares"}},"getUserTotalDeposit(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"getUserTotalDeposit",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"gets the total user deposit",params:{account:"the user address"},returns:{_0:"user total deposit in (AURORA)"}},"grantRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"grantRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role."},"hasRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"hasRole",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns `true` if `account` has been granted `role`."},"initialize(address,address,uint256[],uint256[],uint256,uint256,address,uint256,uint256)":{inputs:[{internalType:"address",name:"aurora",type:"address"},{internalType:"address",name:"streamOwner",type:"address"},{internalType:"uint256[]",name:"scheduleTimes",type:"uint256[]"},{internalType:"uint256[]",name:"scheduleRewards",type:"uint256[]"},{internalType:"uint256",name:"tauAuroraStream",type:"uint256"},{internalType:"uint256",name:"_flags",type:"uint256"},{internalType:"address",name:"_treasury",type:"address"},{internalType:"uint256",name:"_maxWeight",type:"uint256"},{internalType:"uint256",name:"_minWeight",type:"uint256"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function",details:"initialize the contract and deploys the first stream (AURORA)",params:{_flags:"admin controlled contract flags",_maxWeight:"max stream reward weighting coefficient",_minWeight:"min stream reward weighting coefficient",_treasury:"the Aurora treasury contract address",aurora:"token contract address",scheduleRewards:"init the schedule amounts",scheduleTimes:"init the schedule time",tauAuroraStream:"release time constant per stream (e.g AURORA stream)"},notice:"By calling this function, the deployer of this contract must make sure that the AURORA reward amount was deposited to the treasury contract before initializing of the default AURORA stream."},"maxWeight()":{inputs:[],name:"maxWeight",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"minWeight()":{inputs:[],name:"minWeight",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"moveAllRewardsToPending()":{inputs:[],name:"moveAllRewardsToPending",outputs:[],stateMutability:"nonpayable",type:"function",details:"moves all the user rewards to pending reward."},"moveRewardsToPending(uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"}],name:"moveRewardsToPending",outputs:[],stateMutability:"nonpayable",type:"function",details:"moves the reward for specific stream Id to pending rewards. It will require a waiting time untill it get released. Users call this in function in order to claim rewards.",params:{streamId:"stream index"}},"paused()":{inputs:[],name:"paused",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"proposeStream(address,address,uint256,uint256,uint256,uint256[],uint256[],uint256)":{inputs:[{internalType:"address",name:"streamOwner",type:"address"},{internalType:"address",name:"rewardToken",type:"address"},{internalType:"uint256",name:"auroraDepositAmount",type:"uint256"},{internalType:"uint256",name:"maxDepositAmount",type:"uint256"},{internalType:"uint256",name:"minDepositAmount",type:"uint256"},{internalType:"uint256[]",name:"scheduleTimes",type:"uint256[]"},{internalType:"uint256[]",name:"scheduleRewards",type:"uint256[]"},{internalType:"uint256",name:"tau",type:"uint256"}],name:"proposeStream",outputs:[],stateMutability:"nonpayable",type:"function",details:"An admin of the staking contract can whitelist (propose) a stream. Whitelisting of the stream provides the option for the stream owner (presumably the issuing party of a specific token) to deposit some ERC-20 tokens on the staking contract and potentially get in return some AURORA tokens. Deposited ERC-20 tokens will be distributed to the stakers over some period of time.",params:{auroraDepositAmount:"Amount of the AURORA deposited by the Admin.",maxDepositAmount:"The upper amount of the tokens that should be deposited by the stream owner",rewardToken:"the address of the ERC-20 tokens to be deposited in the stream",scheduleRewards:"remaining rewards to be delivered at the beginning of each scheduled interval. Last element is always zero. First value (in scheduleRewards) from array is supposed to be a total amount of rewards for stream.",scheduleTimes:"timestamp denoting the start of each scheduled interval. Last element is the end of the stream.",streamOwner:"only this account would be able to create a stream",tau:"the tau is (pending release period) for this stream (e.g one day)"},notice:"treasury manager must call"},"releaseAuroraRewardsToStreamOwner(uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"}],name:"releaseAuroraRewardsToStreamOwner",outputs:[],stateMutability:"nonpayable",type:"function",details:"the release of AURORA tokens to the stream owner is subjected to the same schedule as rewards. Thus if for a specific moment in time 30% of the rewards are distributed, then it means that 30% of the AURORA deposit can be withdrawn by the stream owner too. called by the stream owner",params:{streamId:"the stream index"}},"removeStream(uint256,address)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"},{internalType:"address",name:"streamFundReceiver",type:"address"}],name:"removeStream",outputs:[],stateMutability:"nonpayable",type:"function",details:"removes a stream (only default admin role)",params:{streamFundReceiver:"receives the rest of the reward tokens in the stream",streamId:"stream index"}},"renounceRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"renounceRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been revoked `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`."},"revokeRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"revokeRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role."},"rewardsSchedule(uint256,uint256,uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"},{internalType:"uint256",name:"start",type:"uint256"},{internalType:"uint256",name:"end",type:"uint256"}],name:"rewardsSchedule",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"calculate the total amount of the released tokens within a period (start & end)",params:{end:"is the end timestamp (e.g block.timestamp .. now)",start:"is the start timestamp within the schedule",streamId:"the stream index"},returns:{_0:"amount of the released tokens for that period"}},"stake(uint256)":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"}],name:"stake",outputs:[],stateMutability:"nonpayable",type:"function",details:"a user stakes amount of AURORA tokens The user should approve these tokens to the treasury contract in order to complete the stake.",params:{amount:"is the AURORA amount."}},"stakeOnBehalfOfAnotherUser(address,uint256)":{inputs:[{internalType:"address",name:"account",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"stakeOnBehalfOfAnotherUser",outputs:[],stateMutability:"nonpayable",type:"function",details:"stakeOnBehalfOfAnotherUser is called for airdropping Aurora users",params:{account:"the account address",amount:"in AURORA tokens WARNING: rewards are not claimed during stake. Airdrop script must claim or only distribute to accounts without stake"}},"stakeOnBehalfOfOtherUsers(address[],uint256[],uint256)":{inputs:[{internalType:"address[]",name:"accounts",type:"address[]"},{internalType:"uint256[]",name:"amounts",type:"uint256[]"},{internalType:"uint256",name:"batchAmount",type:"uint256"}],name:"stakeOnBehalfOfOtherUsers",outputs:[],stateMutability:"nonpayable",type:"function",details:"stakeOnBehalfOfOtherUsers called for airdropping Aurora users",params:{accounts:"the account address",amounts:"in AURORA tokens",batchAmount:"equals to the sum of amounts WARNING: rewards are not claimed during stake. Airdrop script must claim or only distribute to accounts without stake"}},"startEndScheduleIndex(uint256,uint256,uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"},{internalType:"uint256",name:"start",type:"uint256"},{internalType:"uint256",name:"end",type:"uint256"}],name:"startEndScheduleIndex",outputs:[{internalType:"uint256",name:"startIndex",type:"uint256"},{internalType:"uint256",name:"endIndex",type:"uint256"}],stateMutability:"view",type:"function",details:"gets start index and end index in a stream schedule",params:{end:"end time (in seconds)",start:"start time (in seconds)",streamId:"stream index"}},"supportsInterface(bytes4)":{inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"See {IERC165-supportsInterface}."},"tempMoveRewardsToPending(address,uint256)":{inputs:[{internalType:"address",name:"account",type:"address"},{internalType:"uint256",name:"streamId",type:"uint256"}],name:"tempMoveRewardsToPending",outputs:[],stateMutability:"nonpayable",type:"function"},"totalAmountOfStakedAurora()":{inputs:[],name:"totalAmountOfStakedAurora",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"totalAuroraShares()":{inputs:[],name:"totalAuroraShares",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"totalStreamShares()":{inputs:[],name:"totalStreamShares",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"touchedAt()":{inputs:[],name:"touchedAt",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"treasury()":{inputs:[],name:"treasury",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"unstake(uint256)":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"}],name:"unstake",outputs:[],stateMutability:"nonpayable",type:"function",details:"unstake amount from user shares value. The rest is re-staked",params:{amount:"to unstake"}},"unstakeAll()":{inputs:[],name:"unstakeAll",outputs:[],stateMutability:"nonpayable",type:"function",details:"unstake all the user's shares"},"unstakeAllOnBehalfOfOthers(address[])":{inputs:[{internalType:"address[]",name:"accounts",type:"address[]"}],name:"unstakeAllOnBehalfOfOthers",outputs:[],stateMutability:"nonpayable",type:"function"},"updateTreasury(address)":{inputs:[{internalType:"address",name:"_treasury",type:"address"}],name:"updateTreasury",outputs:[],stateMutability:"nonpayable",type:"function",details:"restricted for the admin only. Admin should pause this contract before changing the treasury address by setting the pause =1 (for changing this variable, call adminPause(1))",params:{_treasury:"treasury contract address for the reward tokens"},notice:"updates treasury account"},"updateUserCalculation()":{inputs:[],name:"updateUserCalculation",outputs:[],stateMutability:"nonpayable",type:"function"},"upgradeTo(address)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"}],name:"upgradeTo",outputs:[],stateMutability:"nonpayable",type:"function",details:"Upgrade the implementation of the proxy to `newImplementation`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."},"upgradeToAndCall(address,bytes)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"},{internalType:"bytes",name:"data",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable",type:"function",details:"Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call encoded in `data`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."},"users(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"users",outputs:[{internalType:"uint256",name:"deposit",type:"uint256"},{internalType:"uint256",name:"auroraShares",type:"uint256"},{internalType:"uint256",name:"streamShares",type:"uint256"}],stateMutability:"view",type:"function"},"withdraw(uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"}],name:"withdraw",outputs:[],stateMutability:"nonpayable",type:"function",details:"withdraw amount in the pending pool. User should wait for pending time (tau constant) in order to be able to withdraw.",params:{streamId:"stream index"}},"withdrawAll()":{inputs:[],name:"withdrawAll",outputs:[],stateMutability:"nonpayable",type:"function",details:"withdraw all claimed balances which have passed pending periode. This function will reach gas limit with too many streams, so the frontend will allow individual stream withdrawals and disable withdrawAll."}}},"contracts/testing/JetStakingTestingV2.sol:JetStakingTestingV2":{source:"contracts/testing/JetStakingTestingV2.sol",name:"JetStakingTestingV2",events:{"AdminChanged(address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"previousAdmin",type:"address"},{indexed:!1,internalType:"address",name:"newAdmin",type:"address"}],name:"AdminChanged",type:"event"},"BeaconUpgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"beacon",type:"address"}],name:"BeaconUpgraded",type:"event"},"Pending(uint256,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"streamId",type:"uint256"},{indexed:!0,internalType:"address",name:"user",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"}],name:"Pending",type:"event"},"Released(uint256,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"streamId",type:"uint256"},{indexed:!0,internalType:"address",name:"user",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"}],name:"Released",type:"event"},"RoleAdminChanged(bytes32,bytes32,bytes32)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"previousAdminRole",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"newAdminRole",type:"bytes32"}],name:"RoleAdminChanged",type:"event"},"RoleGranted(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleGranted",type:"event"},"RoleRevoked(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleRevoked",type:"event"},"Staked(address,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"user",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"},{indexed:!1,internalType:"uint256",name:"shares",type:"uint256"}],name:"Staked",type:"event"},"StreamCreated(uint256,address,address,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"streamId",type:"uint256"},{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"token",type:"address"},{indexed:!1,internalType:"uint256",name:"tokenAmount",type:"uint256"},{indexed:!1,internalType:"uint256",name:"auroraAmount",type:"uint256"}],name:"StreamCreated",type:"event"},"StreamOwnerRewardReleased(uint256,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"streamId",type:"uint256"},{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"}],name:"StreamOwnerRewardReleased",type:"event"},"StreamProposalCancelled(uint256,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"streamId",type:"uint256"},{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"token",type:"address"}],name:"StreamProposalCancelled",type:"event"},"StreamProposed(uint256,address,address,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"streamId",type:"uint256"},{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"token",type:"address"},{indexed:!1,internalType:"uint256",name:"maxDepositAmount",type:"uint256"},{indexed:!1,internalType:"uint256",name:"auroraDepositAmount",type:"uint256"}],name:"StreamProposed",type:"event"},"StreamRemoved(uint256,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"streamId",type:"uint256"},{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"token",type:"address"}],name:"StreamRemoved",type:"event"},"Unstaked(address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"user",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"}],name:"Unstaked",type:"event"},"Upgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"implementation",type:"address"}],name:"Upgraded",type:"event"}},methods:{"AIRDROP_ROLE()":{inputs:[],name:"AIRDROP_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"CLAIM_ROLE()":{inputs:[],name:"CLAIM_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"DEFAULT_ADMIN_ROLE()":{inputs:[],name:"DEFAULT_ADMIN_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"FOUR_YEARS()":{inputs:[],name:"FOUR_YEARS",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"ONE_MONTH()":{inputs:[],name:"ONE_MONTH",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"PAUSE_ROLE()":{inputs:[],name:"PAUSE_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"STREAM_MANAGER_ROLE()":{inputs:[],name:"STREAM_MANAGER_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"adminDelegatecall(address,bytes)":{inputs:[{internalType:"address",name:"target",type:"address"},{internalType:"bytes",name:"data",type:"bytes"}],name:"adminDelegatecall",outputs:[{internalType:"bytes",name:"",type:"bytes"}],stateMutability:"payable",type:"function","custom:oz-upgrades-unsafe-allow":"delegatecall",details:"adminDelegatecall allows this contract to delegate calls to a target contract and execute it in the context of this contract. Only default admin role can call this function.",params:{data:"is the ABI encoded function signature and its values.",target:"the target contract address"}},"adminPause(uint256)":{inputs:[{internalType:"uint256",name:"flags",type:"uint256"}],name:"adminPause",outputs:[],stateMutability:"nonpayable",type:"function",details:"adminPause pauses this contract. Only pause role or default admin role can access this function.",params:{flags:"flags variable is used for pausing this contract."}},"adminSstore(uint256,uint256)":{inputs:[{internalType:"uint256",name:"key",type:"uint256"},{internalType:"uint256",name:"value",type:"uint256"}],name:"adminSstore",outputs:[],stateMutability:"nonpayable",type:"function",details:"adminSstore updates the state variable value. only default admin role can call this function.",params:{key:"is the storage slot of the state variable",value:"is the state variable value"}},"adminSstoreWithMask(uint256,uint256,uint256)":{inputs:[{internalType:"uint256",name:"key",type:"uint256"},{internalType:"uint256",name:"value",type:"uint256"},{internalType:"uint256",name:"mask",type:"uint256"}],name:"adminSstoreWithMask",outputs:[],stateMutability:"nonpayable",type:"function",details:"adminSstoreWithMask similar to adminSstore except it updates the state variable value after xor-ing this value with the old value and the mask, so the new value should be a result of xor(and(xor(value, oldval), mask), oldval). Only default admin role can call this function.",params:{key:"is the storage slot of the state variable",mask:"this value is used in calculating the new value",value:"is the state variable value"}},"auroraToken()":{inputs:[],name:"auroraToken",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"batchClaimOnBehalfOfAnotherUser(address,uint256[])":{inputs:[{internalType:"address",name:"account",type:"address"},{internalType:"uint256[]",name:"streamIds",type:"uint256[]"}],name:"batchClaimOnBehalfOfAnotherUser",outputs:[],stateMutability:"nonpayable",type:"function",details:"batchClaimOnBehalfOfAnotherUser when gas limits prevent users from claiming all.",params:{account:"the user account address.",streamIds:"to claim."}},"batchMoveRewardsToPending(uint256[])":{inputs:[{internalType:"uint256[]",name:"streamIds",type:"uint256[]"}],name:"batchMoveRewardsToPending",outputs:[],stateMutability:"nonpayable",type:"function",details:"moves a set of stream Id rewards to pending. Allows user to select stream ids to claim from UI.",params:{streamIds:"stream indexes"}},"batchWithdraw(uint256[])":{inputs:[{internalType:"uint256[]",name:"streamIds",type:"uint256[]"}],name:"batchWithdraw",outputs:[],stateMutability:"nonpayable",type:"function",details:"withdraw a set of stream Ids. Allows user to select stream ids to withdraw from UI.",params:{streamIds:"to withdraw."}},"before(uint256,uint256)":{inputs:[{internalType:"uint256",name:"startTime",type:"uint256"},{internalType:"uint256",name:"endTime",type:"uint256"}],name:"before",outputs:[{internalType:"uint256",name:"total",type:"uint256"},{internalType:"uint256",name:"rewardPerShareAurora",type:"uint256"},{internalType:"uint256",name:"scheduleCalculated",type:"uint256"}],stateMutability:"view",type:"function"},"c_0x022bfb71(bytes32)":{inputs:[{internalType:"bytes32",name:"c__0x022bfb71",type:"bytes32"}],name:"c_0x022bfb71",outputs:[],stateMutability:"pure",type:"function"},"c_0x7e37e874(bytes32)":{inputs:[{internalType:"bytes32",name:"c__0x7e37e874",type:"bytes32"}],name:"c_0x7e37e874",outputs:[],stateMutability:"pure",type:"function"},"c_0xeafb4a08(bytes32)":{inputs:[{internalType:"bytes32",name:"c__0xeafb4a08",type:"bytes32"}],name:"c_0xeafb4a08",outputs:[],stateMutability:"pure",type:"function"},"calculateWeightedShares(uint256,uint256)":{inputs:[{internalType:"uint256",name:"shares",type:"uint256"},{internalType:"uint256",name:"timestamp",type:"uint256"}],name:"calculateWeightedShares",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"callBeforeTwice()":{inputs:[],name:"callBeforeTwice",outputs:[],stateMutability:"nonpayable",type:"function"},"cancelStreamProposal(uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"}],name:"cancelStreamProposal",outputs:[],stateMutability:"nonpayable",type:"function",details:"cancelStreamProposal cancels a proposal any time before the stream becomes active (created).",params:{streamId:"the stream index"}},"claimAllOnBehalfOfAnotherUser(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"claimAllOnBehalfOfAnotherUser",outputs:[],stateMutability:"nonpayable",type:"function",details:"Claim all stream rewards on behalf of another user.",params:{account:"the user account address."}},"createStream(uint256,uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"},{internalType:"uint256",name:"rewardTokenAmount",type:"uint256"}],name:"createStream",outputs:[],stateMutability:"nonpayable",type:"function",details:"create new stream (only stream owner) stream owner must approve reward tokens to this contract.",params:{streamId:"stream id"}},"extendAuroraStreamSchedule(uint256[],uint256[])":{inputs:[{internalType:"uint256[]",name:"scheduleTimes",type:"uint256[]"},{internalType:"uint256[]",name:"scheduleRewards",type:"uint256[]"}],name:"extendAuroraStreamSchedule",outputs:[],stateMutability:"nonpayable",type:"function",details:"extend Aurora stream reward schedule. It can be only called by the default contract admin. It can accept extending the schedule if the new schedule is not overlapping with the current schedule. Also, it requires to pause the contract before calling it.",params:{scheduleRewards:"remaining rewards to be delivered at the beginning of each scheduled interval. Last element is always zero.",scheduleTimes:"timestamp denoting the start of each scheduled interval. Last element is the end of the stream."}},"getAmountOfShares(uint256,address)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"},{internalType:"address",name:"account",type:"address"}],name:"getAmountOfShares",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"gets a user stream shares",params:{account:"the user address",streamId:"stream index"},returns:{_0:"user stream shares"}},"getLatestRewardPerShare(uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"}],name:"getLatestRewardPerShare",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"calculates and gets the latest reward per share (RPS) for a stream",params:{streamId:"stream index"},returns:{_0:"streams[streamId].rps + scheduled reward up till now"}},"getPending(uint256,address)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"},{internalType:"address",name:"account",type:"address"}],name:"getPending",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"gets the user's stream pending reward",params:{account:"user account",streamId:"stream index"},returns:{_0:"user.pendings[streamId]"}},"getReleaseTime(uint256,address)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"},{internalType:"address",name:"account",type:"address"}],name:"getReleaseTime",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"gets the user's stream reward release time",params:{account:"user account",streamId:"stream index"},returns:{_0:"user.releaseTime[streamId]"}},"getRewardPerShare(uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"}],name:"getRewardPerShare",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"gets reward per share (RPS) for a stream",params:{streamId:"stream index"},returns:{_0:"streams[streamId].rps"}},"getRewardPerShareForUser(uint256,address)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"},{internalType:"address",name:"account",type:"address"}],name:"getRewardPerShareForUser",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"gets the user's reward per share (RPS) for a stream",params:{streamId:"stream index"},returns:{_0:"user.rpsDuringLastClaim[streamId]"}},"getRewardsAmount(uint256,uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"},{internalType:"uint256",name:"lastUpdate",type:"uint256"}],name:"getRewardsAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"calculates and gets the latest released rewards.",params:{streamId:"stream index"},returns:{_0:"rewards released since last update."}},"getRoleAdmin(bytes32)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"}],name:"getRoleAdmin",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}."},"getStream(uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"}],name:"getStream",outputs:[{internalType:"address",name:"streamOwner",type:"address"},{internalType:"address",name:"rewardToken",type:"address"},{internalType:"uint256",name:"auroraDepositAmount",type:"uint256"},{internalType:"uint256",name:"auroraClaimedAmount",type:"uint256"},{internalType:"uint256",name:"rewardDepositAmount",type:"uint256"},{internalType:"uint256",name:"rewardClaimedAmount",type:"uint256"},{internalType:"uint256",name:"maxDepositAmount",type:"uint256"},{internalType:"uint256",name:"lastTimeOwnerClaimed",type:"uint256"},{internalType:"uint256",name:"rps",type:"uint256"},{internalType:"uint256",name:"tau",type:"uint256"},{internalType:"enum JetStakingV2.StreamStatus",name:"status",type:"uint8"}],stateMutability:"view",type:"function",details:"get the stream data",params:{streamId:"the stream index"},notice:"this function doesn't return the stream schedule due to some stake slots limitations. To get the stream schedule, refer to getStreamSchedule"},"getStreamClaimableAmount(uint256,address)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"},{internalType:"address",name:"account",type:"address"}],name:"getStreamClaimableAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"gets the user's stream claimable amount",params:{streamId:"stream index"},returns:{_0:"(latesRPS - user.rpsDuringLastClaim) * user.shares"}},"getStreamOwnerClaimableAmount(uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"}],name:"getStreamOwnerClaimableAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Stream owner claimable AURORA.",params:{streamId:"the stream index"}},"getStreamSchedule(uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"}],name:"getStreamSchedule",outputs:[{internalType:"uint256[]",name:"scheduleTimes",type:"uint256[]"},{internalType:"uint256[]",name:"scheduleRewards",type:"uint256[]"}],stateMutability:"view",type:"function",details:"get the stream schedule data",params:{streamId:"the stream index"}},"getStreamsCount()":{inputs:[],name:"getStreamsCount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"get the streams count",returns:{_0:"streams.length"}},"getTotalAmountOfStakedAurora()":{inputs:[],name:"getTotalAmountOfStakedAurora",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"gets the total amount of staked aurora",returns:{_0:"totalAmountOfStakedAurora + latest reward schedule"}},"getTreasuryBalance(address)":{inputs:[{internalType:"address",name:"token",type:"address"}],name:"getTreasuryBalance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Get the treasury balance",params:{token:"the token address"}},"getUserShares(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"getUserShares",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"gets the user shares",params:{account:"the user address"},returns:{_0:"user shares"}},"getUserTotalDeposit(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"getUserTotalDeposit",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"gets the total user deposit",params:{account:"the user address"},returns:{_0:"user total deposit in (AURORA)"}},"grantRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"grantRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role."},"hasRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"hasRole",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns `true` if `account` has been granted `role`."},"initialize(address,address,uint256[],uint256[],uint256,uint256,address,uint256,uint256)":{inputs:[{internalType:"address",name:"aurora",type:"address"},{internalType:"address",name:"streamOwner",type:"address"},{internalType:"uint256[]",name:"scheduleTimes",type:"uint256[]"},{internalType:"uint256[]",name:"scheduleRewards",type:"uint256[]"},{internalType:"uint256",name:"tauAuroraStream",type:"uint256"},{internalType:"uint256",name:"_flags",type:"uint256"},{internalType:"address",name:"_treasury",type:"address"},{internalType:"uint256",name:"_maxWeight",type:"uint256"},{internalType:"uint256",name:"_minWeight",type:"uint256"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function",details:"initialize the contract and deploys the first stream (AURORA)",params:{_flags:"admin controlled contract flags",_maxWeight:"max stream reward weighting coefficient",_minWeight:"min stream reward weighting coefficient",_treasury:"the Aurora treasury contract address",aurora:"token contract address",scheduleRewards:"init the schedule amounts",scheduleTimes:"init the schedule time",tauAuroraStream:"release time constant per stream (e.g AURORA stream)"},notice:"By calling this function, the deployer of this contract must make sure that the AURORA reward amount was deposited to the treasury contract before initializing of the default AURORA stream."},"maxWeight()":{inputs:[],name:"maxWeight",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"minWeight()":{inputs:[],name:"minWeight",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"moveAllRewardsToPending()":{inputs:[],name:"moveAllRewardsToPending",outputs:[],stateMutability:"nonpayable",type:"function",details:"moves all the user rewards to pending reward."},"moveRewardsToPending(uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"}],name:"moveRewardsToPending",outputs:[],stateMutability:"nonpayable",type:"function",details:"moves the reward for specific stream Id to pending rewards. It will require a waiting time untill it get released. Users call this in function in order to claim rewards.",params:{streamId:"stream index"}},"paused()":{inputs:[],name:"paused",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"proposeStream(address,address,uint256,uint256,uint256,uint256[],uint256[],uint256)":{inputs:[{internalType:"address",name:"streamOwner",type:"address"},{internalType:"address",name:"rewardToken",type:"address"},{internalType:"uint256",name:"auroraDepositAmount",type:"uint256"},{internalType:"uint256",name:"maxDepositAmount",type:"uint256"},{internalType:"uint256",name:"minDepositAmount",type:"uint256"},{internalType:"uint256[]",name:"scheduleTimes",type:"uint256[]"},{internalType:"uint256[]",name:"scheduleRewards",type:"uint256[]"},{internalType:"uint256",name:"tau",type:"uint256"}],name:"proposeStream",outputs:[],stateMutability:"nonpayable",type:"function",details:"An admin of the staking contract can whitelist (propose) a stream. Whitelisting of the stream provides the option for the stream owner (presumably the issuing party of a specific token) to deposit some ERC-20 tokens on the staking contract and potentially get in return some AURORA tokens. Deposited ERC-20 tokens will be distributed to the stakers over some period of time.",params:{auroraDepositAmount:"Amount of the AURORA deposited by the Admin.",maxDepositAmount:"The upper amount of the tokens that should be deposited by the stream owner",rewardToken:"the address of the ERC-20 tokens to be deposited in the stream",scheduleRewards:"remaining rewards to be delivered at the beginning of each scheduled interval. Last element is always zero. First value (in scheduleRewards) from array is supposed to be a total amount of rewards for stream.",scheduleTimes:"timestamp denoting the start of each scheduled interval. Last element is the end of the stream.",streamOwner:"only this account would be able to create a stream",tau:"the tau is (pending release period) for this stream (e.g one day)"},notice:"treasury manager must call"},"releaseAuroraRewardsToStreamOwner(uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"}],name:"releaseAuroraRewardsToStreamOwner",outputs:[],stateMutability:"nonpayable",type:"function",details:"the release of AURORA tokens to the stream owner is subjected to the same schedule as rewards. Thus if for a specific moment in time 30% of the rewards are distributed, then it means that 30% of the AURORA deposit can be withdrawn by the stream owner too. called by the stream owner",params:{streamId:"the stream index"}},"removeStream(uint256,address)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"},{internalType:"address",name:"streamFundReceiver",type:"address"}],name:"removeStream",outputs:[],stateMutability:"nonpayable",type:"function",details:"removes a stream (only default admin role)",params:{streamFundReceiver:"receives the rest of the reward tokens in the stream",streamId:"stream index"}},"renounceRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"renounceRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been revoked `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`."},"revokeRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"revokeRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role."},"rewardsSchedule(uint256,uint256,uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"},{internalType:"uint256",name:"start",type:"uint256"},{internalType:"uint256",name:"end",type:"uint256"}],name:"rewardsSchedule",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"calculate the total amount of the released tokens within a period (start & end)",params:{end:"is the end timestamp (e.g block.timestamp .. now)",start:"is the start timestamp within the schedule",streamId:"the stream index"},returns:{_0:"amount of the released tokens for that period"}},"stake(uint256)":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"}],name:"stake",outputs:[],stateMutability:"nonpayable",type:"function",details:"a user stakes amount of AURORA tokens The user should approve these tokens to the treasury contract in order to complete the stake.",params:{amount:"is the AURORA amount."}},"stakeOnBehalfOfAnotherUser(address,uint256)":{inputs:[{internalType:"address",name:"account",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"stakeOnBehalfOfAnotherUser",outputs:[],stateMutability:"nonpayable",type:"function",details:"stakeOnBehalfOfAnotherUser is called for airdropping Aurora users",params:{account:"the account address",amount:"in AURORA tokens WARNING: rewards are not claimed during stake. Airdrop script must claim or only distribute to accounts without stake"}},"startEndScheduleIndex(uint256,uint256,uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"},{internalType:"uint256",name:"start",type:"uint256"},{internalType:"uint256",name:"end",type:"uint256"}],name:"startEndScheduleIndex",outputs:[{internalType:"uint256",name:"startIndex",type:"uint256"},{internalType:"uint256",name:"endIndex",type:"uint256"}],stateMutability:"view",type:"function",details:"gets start index and end index in a stream schedule",params:{end:"end time (in seconds)",start:"start time (in seconds)",streamId:"stream index"}},"supportsInterface(bytes4)":{inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"See {IERC165-supportsInterface}."},"tempMoveRewardsToPending(address,uint256)":{inputs:[{internalType:"address",name:"account",type:"address"},{internalType:"uint256",name:"streamId",type:"uint256"}],name:"tempMoveRewardsToPending",outputs:[],stateMutability:"nonpayable",type:"function"},"totalAmountOfStakedAurora()":{inputs:[],name:"totalAmountOfStakedAurora",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"totalAuroraShares()":{inputs:[],name:"totalAuroraShares",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"totalStreamShares()":{inputs:[],name:"totalStreamShares",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"touchedAt()":{inputs:[],name:"touchedAt",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"treasury()":{inputs:[],name:"treasury",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"unstake(uint256)":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"}],name:"unstake",outputs:[],stateMutability:"nonpayable",type:"function",details:"unstake amount from user shares value. The rest is re-staked",params:{amount:"to unstake"}},"unstakeAll()":{inputs:[],name:"unstakeAll",outputs:[],stateMutability:"nonpayable",type:"function",details:"unstake all the user's shares"},"unstakeAllOnBehalfOfOthers(address[])":{inputs:[{internalType:"address[]",name:"accounts",type:"address[]"}],name:"unstakeAllOnBehalfOfOthers",outputs:[],stateMutability:"nonpayable",type:"function"},"updateTreasury(address)":{inputs:[{internalType:"address",name:"_treasury",type:"address"}],name:"updateTreasury",outputs:[],stateMutability:"nonpayable",type:"function",details:"restricted for the admin only. Admin should pause this contract before changing the treasury address by setting the pause =1 (for changing this variable, call adminPause(1))",params:{_treasury:"treasury contract address for the reward tokens"},notice:"updates treasury account"},"updateUserCalculation()":{inputs:[],name:"updateUserCalculation",outputs:[],stateMutability:"nonpayable",type:"function"},"upgradeTo(address)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"}],name:"upgradeTo",outputs:[],stateMutability:"nonpayable",type:"function",details:"Upgrade the implementation of the proxy to `newImplementation`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."},"upgradeToAndCall(address,bytes)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"},{internalType:"bytes",name:"data",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable",type:"function",details:"Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call encoded in `data`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."},"users(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"users",outputs:[{internalType:"uint256",name:"deposit",type:"uint256"},{internalType:"uint256",name:"auroraShares",type:"uint256"},{internalType:"uint256",name:"streamShares",type:"uint256"}],stateMutability:"view",type:"function"},"withdraw(uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"}],name:"withdraw",outputs:[],stateMutability:"nonpayable",type:"function",details:"withdraw amount in the pending pool. User should wait for pending time (tau constant) in order to be able to withdraw.",params:{streamId:"stream index"}},"withdrawAll()":{inputs:[],name:"withdrawAll",outputs:[],stateMutability:"nonpayable",type:"function",details:"withdraw all claimed balances which have passed pending periode. This function will reach gas limit with too many streams, so the frontend will allow individual stream withdrawals and disable withdrawAll."}}},"contracts/testing/JetStakingTestingV3.sol:JetStakingTestingV3":{source:"contracts/testing/JetStakingTestingV3.sol",name:"JetStakingTestingV3",events:{"AdminChanged(address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"previousAdmin",type:"address"},{indexed:!1,internalType:"address",name:"newAdmin",type:"address"}],name:"AdminChanged",type:"event"},"BeaconUpgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"beacon",type:"address"}],name:"BeaconUpgraded",type:"event"},"Pending(uint256,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"streamId",type:"uint256"},{indexed:!0,internalType:"address",name:"user",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"}],name:"Pending",type:"event"},"Released(uint256,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"streamId",type:"uint256"},{indexed:!0,internalType:"address",name:"user",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"}],name:"Released",type:"event"},"RoleAdminChanged(bytes32,bytes32,bytes32)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"previousAdminRole",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"newAdminRole",type:"bytes32"}],name:"RoleAdminChanged",type:"event"},"RoleGranted(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleGranted",type:"event"},"RoleRevoked(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleRevoked",type:"event"},"Staked(address,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"user",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"},{indexed:!1,internalType:"uint256",name:"shares",type:"uint256"}],name:"Staked",type:"event"},"StreamCreated(uint256,address,address,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"streamId",type:"uint256"},{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"token",type:"address"},{indexed:!1,internalType:"uint256",name:"tokenAmount",type:"uint256"},{indexed:!1,internalType:"uint256",name:"auroraAmount",type:"uint256"}],name:"StreamCreated",type:"event"},"StreamOwnerRewardReleased(uint256,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"streamId",type:"uint256"},{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"}],name:"StreamOwnerRewardReleased",type:"event"},"StreamProposalCancelled(uint256,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"streamId",type:"uint256"},{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"token",type:"address"}],name:"StreamProposalCancelled",type:"event"},"StreamProposed(uint256,address,address,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"streamId",type:"uint256"},{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"token",type:"address"},{indexed:!1,internalType:"uint256",name:"maxDepositAmount",type:"uint256"},{indexed:!1,internalType:"uint256",name:"auroraDepositAmount",type:"uint256"}],name:"StreamProposed",type:"event"},"StreamRemoved(uint256,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"streamId",type:"uint256"},{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"token",type:"address"}],name:"StreamRemoved",type:"event"},"Unstaked(address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"user",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"}],name:"Unstaked",type:"event"},"Upgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"implementation",type:"address"}],name:"Upgraded",type:"event"}},methods:{"AIRDROP_ROLE()":{inputs:[],name:"AIRDROP_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"CLAIM_ROLE()":{inputs:[],name:"CLAIM_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"DEFAULT_ADMIN_ROLE()":{inputs:[],name:"DEFAULT_ADMIN_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"FOUR_YEARS()":{inputs:[],name:"FOUR_YEARS",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"ONE_MONTH()":{inputs:[],name:"ONE_MONTH",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"PAUSE_ROLE()":{inputs:[],name:"PAUSE_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"RPS_MULTIPLIER()":{inputs:[],name:"RPS_MULTIPLIER",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"STREAM_MANAGER_ROLE()":{inputs:[],name:"STREAM_MANAGER_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"adminDelegatecall(address,bytes)":{inputs:[{internalType:"address",name:"target",type:"address"},{internalType:"bytes",name:"data",type:"bytes"}],name:"adminDelegatecall",outputs:[{internalType:"bytes",name:"",type:"bytes"}],stateMutability:"payable",type:"function","custom:oz-upgrades-unsafe-allow":"delegatecall",details:"adminDelegatecall allows this contract to delegate calls to a target contract and execute it in the context of this contract. Only default admin role can call this function.",params:{data:"is the ABI encoded function signature and its values.",target:"the target contract address"}},"adminPause(uint256)":{inputs:[{internalType:"uint256",name:"flags",type:"uint256"}],name:"adminPause",outputs:[],stateMutability:"nonpayable",type:"function",details:"adminPause pauses this contract. Only pause role or default admin role can access this function.",params:{flags:"flags variable is used for pausing this contract."}},"adminSstore(uint256,uint256)":{inputs:[{internalType:"uint256",name:"key",type:"uint256"},{internalType:"uint256",name:"value",type:"uint256"}],name:"adminSstore",outputs:[],stateMutability:"nonpayable",type:"function",details:"adminSstore updates the state variable value. only default admin role can call this function.",params:{key:"is the storage slot of the state variable",value:"is the state variable value"}},"adminSstoreWithMask(uint256,uint256,uint256)":{inputs:[{internalType:"uint256",name:"key",type:"uint256"},{internalType:"uint256",name:"value",type:"uint256"},{internalType:"uint256",name:"mask",type:"uint256"}],name:"adminSstoreWithMask",outputs:[],stateMutability:"nonpayable",type:"function",details:"adminSstoreWithMask similar to adminSstore except it updates the state variable value after xor-ing this value with the old value and the mask, so the new value should be a result of xor(and(xor(value, oldval), mask), oldval). Only default admin role can call this function.",params:{key:"is the storage slot of the state variable",mask:"this value is used in calculating the new value",value:"is the state variable value"}},"auroraToken()":{inputs:[],name:"auroraToken",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"batchClaimOnBehalfOfAnotherUser(address,uint256[])":{inputs:[{internalType:"address",name:"account",type:"address"},{internalType:"uint256[]",name:"streamIds",type:"uint256[]"}],name:"batchClaimOnBehalfOfAnotherUser",outputs:[],stateMutability:"nonpayable",type:"function",details:"batchClaimOnBehalfOfAnotherUser when gas limits prevent users from claiming all.",params:{account:"the user account address.",streamIds:"to claim."}},"batchMoveRewardsToPending(uint256[])":{inputs:[{internalType:"uint256[]",name:"streamIds",type:"uint256[]"}],name:"batchMoveRewardsToPending",outputs:[],stateMutability:"nonpayable",type:"function",details:"moves a set of stream Id rewards to pending. Allows user to select stream ids to claim from UI.",params:{streamIds:"stream indexes"}},"batchWithdraw(uint256[])":{inputs:[{internalType:"uint256[]",name:"streamIds",type:"uint256[]"}],name:"batchWithdraw",outputs:[],stateMutability:"nonpayable",type:"function",details:"withdraw a set of stream Ids. Allows user to select stream ids to withdraw from UI.",params:{streamIds:"to withdraw."}},"before(uint256,uint256)":{inputs:[{internalType:"uint256",name:"startTime",type:"uint256"},{internalType:"uint256",name:"endTime",type:"uint256"}],name:"before",outputs:[{internalType:"uint256",name:"total",type:"uint256"},{internalType:"uint256",name:"rewardPerShareAurora",type:"uint256"},{internalType:"uint256",name:"scheduleCalculated",type:"uint256"}],stateMutability:"view",type:"function"},"c_0x022bfb71(bytes32)":{inputs:[{internalType:"bytes32",name:"c__0x022bfb71",type:"bytes32"}],name:"c_0x022bfb71",outputs:[],stateMutability:"pure",type:"function"},"c_0x7e37e874(bytes32)":{inputs:[{internalType:"bytes32",name:"c__0x7e37e874",type:"bytes32"}],name:"c_0x7e37e874",outputs:[],stateMutability:"pure",type:"function"},"c_0xafbda90b(bytes32)":{inputs:[{internalType:"bytes32",name:"c__0xafbda90b",type:"bytes32"}],name:"c_0xafbda90b",outputs:[],stateMutability:"pure",type:"function"},"c_0xd7b07179(bytes32)":{inputs:[{internalType:"bytes32",name:"c__0xd7b07179",type:"bytes32"}],name:"c_0xd7b07179",outputs:[],stateMutability:"pure",type:"function"},"calculateWeightedShares(uint256,uint256)":{inputs:[{internalType:"uint256",name:"shares",type:"uint256"},{internalType:"uint256",name:"timestamp",type:"uint256"}],name:"calculateWeightedShares",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"callBeforeTwice()":{inputs:[],name:"callBeforeTwice",outputs:[],stateMutability:"nonpayable",type:"function"},"cancelStreamProposal(uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"}],name:"cancelStreamProposal",outputs:[],stateMutability:"nonpayable",type:"function",details:"cancelStreamProposal cancels a proposal any time before the stream becomes active (created).",params:{streamId:"the stream index"}},"claimAllOnBehalfOfAnotherUser(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"claimAllOnBehalfOfAnotherUser",outputs:[],stateMutability:"nonpayable",type:"function",details:"Claim all stream rewards on behalf of another user.",params:{account:"the user account address."}},"createStream(uint256,uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"},{internalType:"uint256",name:"rewardTokenAmount",type:"uint256"}],name:"createStream",outputs:[],stateMutability:"nonpayable",type:"function",details:"create new stream (only stream owner) stream owner must approve reward tokens to this contract.",params:{streamId:"stream id"}},"extendAuroraStreamSchedule(uint256[],uint256[])":{inputs:[{internalType:"uint256[]",name:"scheduleTimes",type:"uint256[]"},{internalType:"uint256[]",name:"scheduleRewards",type:"uint256[]"}],name:"extendAuroraStreamSchedule",outputs:[],stateMutability:"nonpayable",type:"function",details:"extend Aurora stream reward schedule. It can be only called by the default contract admin. It can accept extending the schedule if the new schedule is not overlapping with the current schedule. Also, it requires to pause the contract before calling it.",params:{scheduleRewards:"remaining rewards to be delivered at the beginning of each scheduled interval. Last element is always zero.",scheduleTimes:"timestamp denoting the start of each scheduled interval. Last element is the end of the stream."}},"getAmountOfShares(uint256,address)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"},{internalType:"address",name:"account",type:"address"}],name:"getAmountOfShares",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"gets a user stream shares",params:{account:"the user address",streamId:"stream index"},returns:{_0:"user stream shares"}},"getLatestRewardPerShare(uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"}],name:"getLatestRewardPerShare",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"calculates and gets the latest reward per share (RPS) for a stream",params:{streamId:"stream index"},returns:{_0:"streams[streamId].rps + scheduled reward up till now"}},"getPending(uint256,address)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"},{internalType:"address",name:"account",type:"address"}],name:"getPending",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"gets the user's stream pending reward",params:{account:"user account",streamId:"stream index"},returns:{_0:"user.pendings[streamId]"}},"getReleaseTime(uint256,address)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"},{internalType:"address",name:"account",type:"address"}],name:"getReleaseTime",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"gets the user's stream reward release time",params:{account:"user account",streamId:"stream index"},returns:{_0:"user.releaseTime[streamId]"}},"getRewardPerShare(uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"}],name:"getRewardPerShare",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"gets reward per share (RPS) for a stream",params:{streamId:"stream index"},returns:{_0:"streams[streamId].rps"}},"getRewardPerShareForUser(uint256,address)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"},{internalType:"address",name:"account",type:"address"}],name:"getRewardPerShareForUser",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"gets the user's reward per share (RPS) for a stream",params:{streamId:"stream index"},returns:{_0:"user.rpsDuringLastClaim[streamId]"}},"getRewardsAmount(uint256,uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"},{internalType:"uint256",name:"lastUpdate",type:"uint256"}],name:"getRewardsAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"calculates and gets the latest released rewards.",params:{streamId:"stream index"},returns:{_0:"rewards released since last update."}},"getRoleAdmin(bytes32)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"}],name:"getRoleAdmin",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}."},"getStream(uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"}],name:"getStream",outputs:[{internalType:"address",name:"streamOwner",type:"address"},{internalType:"address",name:"rewardToken",type:"address"},{internalType:"uint256",name:"auroraDepositAmount",type:"uint256"},{internalType:"uint256",name:"auroraClaimedAmount",type:"uint256"},{internalType:"uint256",name:"rewardDepositAmount",type:"uint256"},{internalType:"uint256",name:"rewardClaimedAmount",type:"uint256"},{internalType:"uint256",name:"maxDepositAmount",type:"uint256"},{internalType:"uint256",name:"lastTimeOwnerClaimed",type:"uint256"},{internalType:"uint256",name:"rps",type:"uint256"},{internalType:"uint256",name:"tau",type:"uint256"},{internalType:"enum JetStakingV2.StreamStatus",name:"status",type:"uint8"}],stateMutability:"view",type:"function",details:"get the stream data",params:{streamId:"the stream index"},notice:"this function doesn't return the stream schedule due to some stake slots limitations. To get the stream schedule, refer to getStreamSchedule"},"getStreamClaimableAmount(uint256,address)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"},{internalType:"address",name:"account",type:"address"}],name:"getStreamClaimableAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"gets the user's stream claimable amount",params:{streamId:"stream index"},returns:{_0:"(latesRPS - user.rpsDuringLastClaim) * user.shares"}},"getStreamOwnerClaimableAmount(uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"}],name:"getStreamOwnerClaimableAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Stream owner claimable AURORA.",params:{streamId:"the stream index"}},"getStreamSchedule(uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"}],name:"getStreamSchedule",outputs:[{internalType:"uint256[]",name:"scheduleTimes",type:"uint256[]"},{internalType:"uint256[]",name:"scheduleRewards",type:"uint256[]"}],stateMutability:"view",type:"function",details:"get the stream schedule data",params:{streamId:"the stream index"}},"getStreamsCount()":{inputs:[],name:"getStreamsCount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"get the streams count",returns:{_0:"streams.length"}},"getTotalAmountOfStakedAurora()":{inputs:[],name:"getTotalAmountOfStakedAurora",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"gets the total amount of staked aurora",returns:{_0:"totalAmountOfStakedAurora + latest reward schedule"}},"getTreasuryBalance(address)":{inputs:[{internalType:"address",name:"token",type:"address"}],name:"getTreasuryBalance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Get the treasury balance",params:{token:"the token address"}},"getUserShares(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"getUserShares",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"gets the user shares",params:{account:"the user address"},returns:{_0:"user shares"}},"getUserTotalDeposit(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"getUserTotalDeposit",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"gets the total user deposit",params:{account:"the user address"},returns:{_0:"user total deposit in (AURORA)"}},"grantRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"grantRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role."},"hasRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"hasRole",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns `true` if `account` has been granted `role`."},"initialize(address,address,uint256[],uint256[],uint256,uint256,address,uint256,uint256)":{inputs:[{internalType:"address",name:"aurora",type:"address"},{internalType:"address",name:"streamOwner",type:"address"},{internalType:"uint256[]",name:"scheduleTimes",type:"uint256[]"},{internalType:"uint256[]",name:"scheduleRewards",type:"uint256[]"},{internalType:"uint256",name:"tauAuroraStream",type:"uint256"},{internalType:"uint256",name:"_flags",type:"uint256"},{internalType:"address",name:"_treasury",type:"address"},{internalType:"uint256",name:"_maxWeight",type:"uint256"},{internalType:"uint256",name:"_minWeight",type:"uint256"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function",details:"initialize the contract and deploys the first stream (AURORA)",params:{_flags:"admin controlled contract flags",_maxWeight:"max stream reward weighting coefficient",_minWeight:"min stream reward weighting coefficient",_treasury:"the Aurora treasury contract address",aurora:"token contract address",scheduleRewards:"init the schedule amounts",scheduleTimes:"init the schedule time",tauAuroraStream:"release time constant per stream (e.g AURORA stream)"},notice:"By calling this function, the deployer of this contract must make sure that the AURORA reward amount was deposited to the treasury contract before initializing of the default AURORA stream."},"initializeOldWeightedStreams()":{inputs:[],name:"initializeOldWeightedStreams",outputs:[],stateMutability:"nonpayable",type:"function",details:"set the old weighted share streams",notice:"This function must be called prior upgrading the contract. And the contract must be paused before initializing it."},"maxWeight()":{inputs:[],name:"maxWeight",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"minWeight()":{inputs:[],name:"minWeight",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"moveAllRewardsToPending()":{inputs:[],name:"moveAllRewardsToPending",outputs:[],stateMutability:"nonpayable",type:"function",details:"moves all the user rewards to pending reward."},"moveRewardsToPending(uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"}],name:"moveRewardsToPending",outputs:[],stateMutability:"nonpayable",type:"function",details:"moves the reward for specific stream Id to pending rewards. It will require a waiting time untill it get released. Users call this in function in order to claim rewards.",params:{streamId:"stream index"}},"oldWeightedShareStreams(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"oldWeightedShareStreams",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"paused()":{inputs:[],name:"paused",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"proposeStream(address,address,uint256,uint256,uint256,uint256[],uint256[],uint256)":{inputs:[{internalType:"address",name:"streamOwner",type:"address"},{internalType:"address",name:"rewardToken",type:"address"},{internalType:"uint256",name:"auroraDepositAmount",type:"uint256"},{internalType:"uint256",name:"maxDepositAmount",type:"uint256"},{internalType:"uint256",name:"minDepositAmount",type:"uint256"},{internalType:"uint256[]",name:"scheduleTimes",type:"uint256[]"},{internalType:"uint256[]",name:"scheduleRewards",type:"uint256[]"},{internalType:"uint256",name:"tau",type:"uint256"}],name:"proposeStream",outputs:[],stateMutability:"nonpayable",type:"function",details:"An admin of the staking contract can whitelist (propose) a stream. Whitelisting of the stream provides the option for the stream owner (presumably the issuing party of a specific token) to deposit some ERC-20 tokens on the staking contract and potentially get in return some AURORA tokens. Deposited ERC-20 tokens will be distributed to the stakers over some period of time.",params:{auroraDepositAmount:"Amount of the AURORA deposited by the Admin.",maxDepositAmount:"The upper amount of the tokens that should be deposited by the stream owner",rewardToken:"the address of the ERC-20 tokens to be deposited in the stream",scheduleRewards:"remaining rewards to be delivered at the beginning of each scheduled interval. Last element is always zero. First value (in scheduleRewards) from array is supposed to be a total amount of rewards for stream.",scheduleTimes:"timestamp denoting the start of each scheduled interval. Last element is the end of the stream.",streamOwner:"only this account would be able to create a stream",tau:"the tau is (pending release period) for this stream (e.g one day)"},notice:"treasury manager must call"},"releaseAuroraRewardsToStreamOwner(uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"}],name:"releaseAuroraRewardsToStreamOwner",outputs:[],stateMutability:"nonpayable",type:"function",details:"the release of AURORA tokens to the stream owner is subjected to the same schedule as rewards. Thus if for a specific moment in time 30% of the rewards are distributed, then it means that 30% of the AURORA deposit can be withdrawn by the stream owner too. called by the stream owner",params:{streamId:"the stream index"}},"removeStream(uint256,address)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"},{internalType:"address",name:"streamFundReceiver",type:"address"}],name:"removeStream",outputs:[],stateMutability:"nonpayable",type:"function",details:"removes a stream (only default admin role)",params:{streamFundReceiver:"receives the rest of the reward tokens in the stream",streamId:"stream index"}},"renounceRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"renounceRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been revoked `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`."},"revokeRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"revokeRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role."},"rewardsSchedule(uint256,uint256,uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"},{internalType:"uint256",name:"start",type:"uint256"},{internalType:"uint256",name:"end",type:"uint256"}],name:"rewardsSchedule",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"calculate the total amount of the released tokens within a period (start & end)",params:{end:"is the end timestamp (e.g block.timestamp .. now)",start:"is the start timestamp within the schedule",streamId:"the stream index"},returns:{_0:"amount of the released tokens for that period"}},"stake(uint256)":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"}],name:"stake",outputs:[],stateMutability:"nonpayable",type:"function",details:"a user stakes amount of AURORA tokens The user should approve these tokens to the treasury contract in order to complete the stake.",params:{amount:"is the AURORA amount."}},"stakeOnBehalfOfAnotherUser(address,uint256)":{inputs:[{internalType:"address",name:"account",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"stakeOnBehalfOfAnotherUser",outputs:[],stateMutability:"nonpayable",type:"function",details:"stakeOnBehalfOfAnotherUser is called for airdropping Aurora users",params:{account:"the account address",amount:"in AURORA tokens WARNING: rewards are not claimed during stake. Airdrop script must claim or only distribute to accounts without stake"}},"startEndScheduleIndex(uint256,uint256,uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"},{internalType:"uint256",name:"start",type:"uint256"},{internalType:"uint256",name:"end",type:"uint256"}],name:"startEndScheduleIndex",outputs:[{internalType:"uint256",name:"startIndex",type:"uint256"},{internalType:"uint256",name:"endIndex",type:"uint256"}],stateMutability:"view",type:"function",details:"gets start index and end index in a stream schedule",params:{end:"end time (in seconds)",start:"start time (in seconds)",streamId:"stream index"}},"supportsInterface(bytes4)":{inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"See {IERC165-supportsInterface}."},"tempMoveRewardsToPending(address,uint256)":{inputs:[{internalType:"address",name:"account",type:"address"},{internalType:"uint256",name:"streamId",type:"uint256"}],name:"tempMoveRewardsToPending",outputs:[],stateMutability:"nonpayable",type:"function"},"totalAmountOfStakedAurora()":{inputs:[],name:"totalAmountOfStakedAurora",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"totalAuroraShares()":{inputs:[],name:"totalAuroraShares",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"totalStreamShares()":{inputs:[],name:"totalStreamShares",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"touchedAt()":{inputs:[],name:"touchedAt",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"treasury()":{inputs:[],name:"treasury",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"unstake(uint256)":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"}],name:"unstake",outputs:[],stateMutability:"nonpayable",type:"function",details:"unstake amount from user shares value. The rest is re-staked",params:{amount:"to unstake"}},"unstakeAll()":{inputs:[],name:"unstakeAll",outputs:[],stateMutability:"nonpayable",type:"function",details:"unstake all the user's shares"},"unstakeAllOnBehalfOfOthers(address[])":{inputs:[{internalType:"address[]",name:"accounts",type:"address[]"}],name:"unstakeAllOnBehalfOfOthers",outputs:[],stateMutability:"nonpayable",type:"function"},"updateTreasury(address)":{inputs:[{internalType:"address",name:"_treasury",type:"address"}],name:"updateTreasury",outputs:[],stateMutability:"nonpayable",type:"function",details:"restricted for the admin only. Admin should pause this contract before changing the treasury address by setting the pause =1 (for changing this variable, call adminPause(1))",params:{_treasury:"treasury contract address for the reward tokens"},notice:"updates treasury account"},"updateUserCalculation()":{inputs:[],name:"updateUserCalculation",outputs:[],stateMutability:"nonpayable",type:"function"},"upgradeTo(address)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"}],name:"upgradeTo",outputs:[],stateMutability:"nonpayable",type:"function",details:"Upgrade the implementation of the proxy to `newImplementation`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."},"upgradeToAndCall(address,bytes)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"},{internalType:"bytes",name:"data",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable",type:"function",details:"Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call encoded in `data`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."},"users(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"users",outputs:[{internalType:"uint256",name:"deposit",type:"uint256"},{internalType:"uint256",name:"auroraShares",type:"uint256"},{internalType:"uint256",name:"streamShares",type:"uint256"}],stateMutability:"view",type:"function"},"withdraw(uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"}],name:"withdraw",outputs:[],stateMutability:"nonpayable",type:"function",details:"withdraw amount in the pending pool. User should wait for pending time (tau constant) in order to be able to withdraw.",params:{streamId:"stream index"}},"withdrawAll()":{inputs:[],name:"withdrawAll",outputs:[],stateMutability:"nonpayable",type:"function",details:"withdraw all claimed balances which have passed pending periode. This function will reach gas limit with too many streams, so the frontend will allow individual stream withdrawals and disable withdrawAll."}}},"contracts/testing/Token.sol:Token":{source:"contracts/testing/Token.sol",name:"Token",constructor:{inputs:[{internalType:"uint256",name:"initialSupply",type:"uint256"},{internalType:"string",name:"name",type:"string"},{internalType:"string",name:"symbol",type:"string"}],stateMutability:"nonpayable",type:"constructor"},events:{"Approval(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"spender",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Approval",type:"event"},"Transfer(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Transfer",type:"event"}},methods:{"allowance(address,address)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"spender",type:"address"}],name:"allowance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC20-allowance}."},"approve(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"approve",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"See {IERC20-approve}. Requirements: - `spender` cannot be the zero address."},"balanceOf(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC20-balanceOf}."},"c_0x08169134(bytes32)":{inputs:[{internalType:"bytes32",name:"c__0x08169134",type:"bytes32"}],name:"c_0x08169134",outputs:[],stateMutability:"pure",type:"function"},"decimals()":{inputs:[],name:"decimals",outputs:[{internalType:"uint8",name:"",type:"uint8"}],stateMutability:"view",type:"function",details:"Returns the number of decimals used to get its user representation. For example, if `decimals` equals `2`, a balance of `505` tokens should be displayed to a user as `5.05` (`505 / 10 ** 2`). Tokens usually opt for a value of 18, imitating the relationship between Ether and Wei. This is the value {ERC20} uses, unless this function is overridden; NOTE: This information is only used for _display_ purposes: it in no way affects any of the arithmetic of the contract, including {IERC20-balanceOf} and {IERC20-transfer}."},"decreaseAllowance(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"subtractedValue",type:"uint256"}],name:"decreaseAllowance",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Atomically decreases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address. - `spender` must have allowance for the caller of at least `subtractedValue`."},"increaseAllowance(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"addedValue",type:"uint256"}],name:"increaseAllowance",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Atomically increases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address."},"mint(address,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"value",type:"uint256"}],name:"mint",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function"},"name()":{inputs:[],name:"name",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"Returns the name of the token."},"symbol()":{inputs:[],name:"symbol",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"Returns the symbol of the token, usually a shorter version of the name."},"totalSupply()":{inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC20-totalSupply}."},"transfer(address,uint256)":{inputs:[{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transfer",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"See {IERC20-transfer}. Requirements: - `recipient` cannot be the zero address. - the caller must have a balance of at least `amount`."},"transferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transferFrom",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"See {IERC20-transferFrom}. Emits an {Approval} event indicating the updated allowance. This is not required by the EIP. See the note at the beginning of {ERC20}. Requirements: - `sender` and `recipient` cannot be the zero address. - `sender` must have a balance of at least `amount`. - the caller must have allowance for ``sender``'s tokens of at least `amount`."}}},"contracts/testing/upgrades/JetStakingV1/JetStakingV1ChangeFunctionSignature.sol:JetStakingV1ChangeFunctionSignature":{source:"contracts/testing/upgrades/JetStakingV1/JetStakingV1ChangeFunctionSignature.sol",name:"JetStakingV1ChangeFunctionSignature",events:{"AdminChanged(address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"previousAdmin",type:"address"},{indexed:!1,internalType:"address",name:"newAdmin",type:"address"}],name:"AdminChanged",type:"event"},"BeaconUpgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"beacon",type:"address"}],name:"BeaconUpgraded",type:"event"},"Pending(uint256,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"streamId",type:"uint256"},{indexed:!0,internalType:"address",name:"user",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"}],name:"Pending",type:"event"},"Released(uint256,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"streamId",type:"uint256"},{indexed:!0,internalType:"address",name:"user",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"}],name:"Released",type:"event"},"RoleAdminChanged(bytes32,bytes32,bytes32)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"previousAdminRole",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"newAdminRole",type:"bytes32"}],name:"RoleAdminChanged",type:"event"},"RoleGranted(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleGranted",type:"event"},"RoleRevoked(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleRevoked",type:"event"},"Staked(address,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"user",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"},{indexed:!1,internalType:"uint256",name:"shares",type:"uint256"}],name:"Staked",type:"event"},"StreamCreated(uint256,address,address,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"streamId",type:"uint256"},{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"token",type:"address"},{indexed:!1,internalType:"uint256",name:"tokenAmount",type:"uint256"},{indexed:!1,internalType:"uint256",name:"auroraAmount",type:"uint256"}],name:"StreamCreated",type:"event"},"StreamOwnerRewardReleased(uint256,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"streamId",type:"uint256"},{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"}],name:"StreamOwnerRewardReleased",type:"event"},"StreamProposalCancelled(uint256,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"streamId",type:"uint256"},{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"token",type:"address"}],name:"StreamProposalCancelled",type:"event"},"StreamProposed(uint256,address,address,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"streamId",type:"uint256"},{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"token",type:"address"},{indexed:!1,internalType:"uint256",name:"maxDepositAmount",type:"uint256"},{indexed:!1,internalType:"uint256",name:"auroraDepositAmount",type:"uint256"}],name:"StreamProposed",type:"event"},"StreamRemoved(uint256,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"streamId",type:"uint256"},{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"token",type:"address"}],name:"StreamRemoved",type:"event"},"Unstaked(address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"user",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"}],name:"Unstaked",type:"event"},"Upgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"implementation",type:"address"}],name:"Upgraded",type:"event"}},methods:{"AIRDROP_ROLE()":{inputs:[],name:"AIRDROP_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"CLAIM_ROLE()":{inputs:[],name:"CLAIM_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"DEFAULT_ADMIN_ROLE()":{inputs:[],name:"DEFAULT_ADMIN_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"FOUR_YEARS()":{inputs:[],name:"FOUR_YEARS",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"ONE_MONTH()":{inputs:[],name:"ONE_MONTH",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"PAUSE_ROLE()":{inputs:[],name:"PAUSE_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"STREAM_MANAGER_ROLE()":{inputs:[],name:"STREAM_MANAGER_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"adminDelegatecall(address,bytes)":{inputs:[{internalType:"address",name:"target",type:"address"},{internalType:"bytes",name:"data",type:"bytes"}],name:"adminDelegatecall",outputs:[{internalType:"bytes",name:"",type:"bytes"}],stateMutability:"payable",type:"function","custom:oz-upgrades-unsafe-allow":"delegatecall",details:"adminDelegatecall allows this contract to delegate calls to a target contract and execute it in the context of this contract. Only default admin role can call this function.",params:{data:"is the ABI encoded function signature and its values.",target:"the target contract address"}},"adminPause(uint256)":{inputs:[{internalType:"uint256",name:"flags",type:"uint256"}],name:"adminPause",outputs:[],stateMutability:"nonpayable",type:"function",details:"adminPause pauses this contract. Only pause role or default admin role can access this function.",params:{flags:"flags variable is used for pausing this contract."}},"adminSstore(uint256,uint256)":{inputs:[{internalType:"uint256",name:"key",type:"uint256"},{internalType:"uint256",name:"value",type:"uint256"}],name:"adminSstore",outputs:[],stateMutability:"nonpayable",type:"function",details:"adminSstore updates the state variable value. only default admin role can call this function.",params:{key:"is the storage slot of the state variable",value:"is the state variable value"}},"adminSstoreWithMask(uint256,uint256,uint256)":{inputs:[{internalType:"uint256",name:"key",type:"uint256"},{internalType:"uint256",name:"value",type:"uint256"},{internalType:"uint256",name:"mask",type:"uint256"}],name:"adminSstoreWithMask",outputs:[],stateMutability:"nonpayable",type:"function",details:"adminSstoreWithMask similar to adminSstore except it updates the state variable value after xor-ing this value with the old value and the mask, so the new value should be a result of xor(and(xor(value, oldval), mask), oldval). Only default admin role can call this function.",params:{key:"is the storage slot of the state variable",mask:"this value is used in calculating the new value",value:"is the state variable value"}},"auroraToken()":{inputs:[],name:"auroraToken",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"batchClaimOnBehalfOfAnotherUser(address,uint256[])":{inputs:[{internalType:"address",name:"account",type:"address"},{internalType:"uint256[]",name:"streamIds",type:"uint256[]"}],name:"batchClaimOnBehalfOfAnotherUser",outputs:[],stateMutability:"nonpayable",type:"function",details:"batchClaimOnBehalfOfAnotherUser when gas limits prevent users from claiming all.",params:{account:"the user account address.",streamIds:"to claim."}},"batchClaimOnBehalfOfOtherUsers(address[],uint256[])":{inputs:[{internalType:"address[]",name:"accounts",type:"address[]"},{internalType:"uint256[]",name:"streamIds",type:"uint256[]"}],name:"batchClaimOnBehalfOfOtherUsers",outputs:[],stateMutability:"nonpayable",type:"function",details:"Claim all stream rewards on behalf of other users.",params:{accounts:"the user account addresses."}},"batchMoveRewardsToPending(uint256[])":{inputs:[{internalType:"uint256[]",name:"streamIds",type:"uint256[]"}],name:"batchMoveRewardsToPending",outputs:[],stateMutability:"nonpayable",type:"function",details:"moves a set of stream Id rewards to pending. Allows user to select stream ids to claim from UI.",params:{streamIds:"stream indexes"}},"batchStakeOnBehalfOfOtherUsers(address[],uint256[],uint256,bool)":{inputs:[{internalType:"address[]",name:"accounts",type:"address[]"},{internalType:"uint256[]",name:"amounts",type:"uint256[]"},{internalType:"uint256",name:"batchAmount",type:"uint256"},{internalType:"bool",name:"checkLength",type:"bool"}],name:"batchStakeOnBehalfOfOtherUsers",outputs:[],stateMutability:"nonpayable",type:"function"},"batchWithdraw(uint256[])":{inputs:[{internalType:"uint256[]",name:"streamIds",type:"uint256[]"}],name:"batchWithdraw",outputs:[],stateMutability:"nonpayable",type:"function",details:"withdraw a set of stream Ids. Allows user to select stream ids to withdraw from UI.",params:{streamIds:"to withdraw."}},"before(uint256,uint256)":{inputs:[{internalType:"uint256",name:"startTime",type:"uint256"},{internalType:"uint256",name:"endTime",type:"uint256"}],name:"before",outputs:[{internalType:"uint256",name:"total",type:"uint256"},{internalType:"uint256",name:"rewardPerShareAurora",type:"uint256"},{internalType:"uint256",name:"scheduleCalculated",type:"uint256"}],stateMutability:"view",type:"function"},"c_0x4069a9b2(bytes32)":{inputs:[{internalType:"bytes32",name:"c__0x4069a9b2",type:"bytes32"}],name:"c_0x4069a9b2",outputs:[],stateMutability:"pure",type:"function"},"c_0x7e37e874(bytes32)":{inputs:[{internalType:"bytes32",name:"c__0x7e37e874",type:"bytes32"}],name:"c_0x7e37e874",outputs:[],stateMutability:"pure",type:"function"},"c_0xc1dd3536(bytes32)":{inputs:[{internalType:"bytes32",name:"c__0xc1dd3536",type:"bytes32"}],name:"c_0xc1dd3536",outputs:[],stateMutability:"pure",type:"function"},"c_0xdf09e261(bytes32)":{inputs:[{internalType:"bytes32",name:"c__0xdf09e261",type:"bytes32"}],name:"c_0xdf09e261",outputs:[],stateMutability:"pure",type:"function"},"calculateWeightedShares(uint256,uint256)":{inputs:[{internalType:"uint256",name:"shares",type:"uint256"},{internalType:"uint256",name:"timestamp",type:"uint256"}],name:"calculateWeightedShares",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"callBeforeTwice()":{inputs:[],name:"callBeforeTwice",outputs:[],stateMutability:"nonpayable",type:"function"},"cancelStreamProposal(uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"}],name:"cancelStreamProposal",outputs:[],stateMutability:"nonpayable",type:"function",details:"cancelStreamProposal cancels a proposal any time before the stream becomes active (created).",params:{streamId:"the stream index"}},"claimAllOnBehalfOfAnotherUser(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"claimAllOnBehalfOfAnotherUser",outputs:[],stateMutability:"nonpayable",type:"function",details:"Claim all stream rewards on behalf of another user.",params:{account:"the user account address."}},"claimAllOnBehalfOfOtherUsers(address[])":{inputs:[{internalType:"address[]",name:"accounts",type:"address[]"}],name:"claimAllOnBehalfOfOtherUsers",outputs:[],stateMutability:"nonpayable",type:"function",details:"Claim all stream rewards on behalf of other users.",params:{accounts:"the user account addresses."}},"claimOnBehalfOfAnotherUser(address,uint256)":{inputs:[{internalType:"address",name:"account",type:"address"},{internalType:"uint256",name:"streamId",type:"uint256"}],name:"claimOnBehalfOfAnotherUser",outputs:[],stateMutability:"nonpayable",type:"function",details:"Claim a stream's rewards on behalf of another user.",params:{account:"the user account address.",streamId:"to claim."}},"createStream(uint256,uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"},{internalType:"uint256",name:"rewardTokenAmount",type:"uint256"}],name:"createStream",outputs:[],stateMutability:"nonpayable",type:"function",details:"create new stream (only stream owner) stream owner must approve reward tokens to this contract.",params:{streamId:"stream id"}},"getAmountOfShares(uint256,address)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"},{internalType:"address",name:"account",type:"address"}],name:"getAmountOfShares",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"gets a user stream shares",params:{account:"the user address",streamId:"stream index"},returns:{_0:"user stream shares"}},"getLatestRewardPerShare(uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"}],name:"getLatestRewardPerShare",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"calculates and gets the latest reward per share (RPS) for a stream",params:{streamId:"stream index"},returns:{_0:"streams[streamId].rps + scheduled reward up till now"}},"getPending(uint256,address)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"},{internalType:"address",name:"account",type:"address"}],name:"getPending",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"gets the user's stream pending reward",params:{account:"user account",streamId:"stream index"},returns:{_0:"user.pendings[streamId]"}},"getReleaseTime(uint256,address)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"},{internalType:"address",name:"account",type:"address"}],name:"getReleaseTime",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"gets the user's stream reward release time",params:{account:"user account",streamId:"stream index"},returns:{_0:"user.releaseTime[streamId]"}},"getRewardPerShare(uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"}],name:"getRewardPerShare",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"gets reward per share (RPS) for a stream",params:{streamId:"stream index"},returns:{_0:"streams[streamId].rps"}},"getRewardPerShareForUser(uint256,address)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"},{internalType:"address",name:"account",type:"address"}],name:"getRewardPerShareForUser",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"gets the user's reward per share (RPS) for a stream",params:{streamId:"stream index"},returns:{_0:"user.rpsDuringLastClaim[streamId]"}},"getRewardsAmount(uint256,uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"},{internalType:"uint256",name:"lastUpdate",type:"uint256"}],name:"getRewardsAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"calculates and gets the latest released rewards.",params:{streamId:"stream index"},returns:{_0:"rewards released since last update."}},"getRoleAdmin(bytes32)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"}],name:"getRoleAdmin",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}."},"getStream(uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"}],name:"getStream",outputs:[{internalType:"address",name:"streamOwner",type:"address"},{internalType:"address",name:"rewardToken",type:"address"},{internalType:"uint256",name:"auroraDepositAmount",type:"uint256"},{internalType:"uint256",name:"auroraClaimedAmount",type:"uint256"},{internalType:"uint256",name:"rewardDepositAmount",type:"uint256"},{internalType:"uint256",name:"rewardClaimedAmount",type:"uint256"},{internalType:"uint256",name:"maxDepositAmount",type:"uint256"},{internalType:"uint256",name:"lastTimeOwnerClaimed",type:"uint256"},{internalType:"uint256",name:"rps",type:"uint256"},{internalType:"uint256",name:"tau",type:"uint256"},{internalType:"enum JetStakingV1.StreamStatus",name:"status",type:"uint8"}],stateMutability:"view",type:"function",details:"get the stream data",params:{streamId:"the stream index"},notice:"this function doesn't return the stream schedule due to some stake slots limitations. To get the stream schedule, refer to getStreamSchedule"},"getStreamClaimableAmount(uint256,address)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"},{internalType:"address",name:"account",type:"address"}],name:"getStreamClaimableAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"gets the user's stream claimable amount",params:{streamId:"stream index"},returns:{_0:"(latesRPS - user.rpsDuringLastClaim) * user.shares"}},"getStreamOwnerClaimableAmount(uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"}],name:"getStreamOwnerClaimableAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Stream owner claimable AURORA.",params:{streamId:"the stream index"}},"getStreamSchedule(uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"}],name:"getStreamSchedule",outputs:[{internalType:"uint256[]",name:"scheduleTimes",type:"uint256[]"},{internalType:"uint256[]",name:"scheduleRewards",type:"uint256[]"}],stateMutability:"view",type:"function",details:"get the stream schedule data",params:{streamId:"the stream index"}},"getStreamsCount()":{inputs:[],name:"getStreamsCount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"get the streams count",returns:{_0:"streams.length"}},"getTotalAmountOfStakedAurora()":{inputs:[],name:"getTotalAmountOfStakedAurora",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"gets the total amount of staked aurora",returns:{_0:"totalAmountOfStakedAurora + latest reward schedule"}},"getTreasuryBalance(address)":{inputs:[{internalType:"address",name:"token",type:"address"}],name:"getTreasuryBalance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Get the treasury balance",params:{token:"the token address"}},"getUserShares(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"getUserShares",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"gets the user shares",params:{account:"the user address"},returns:{_0:"user shares"}},"getUserTotalDeposit(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"getUserTotalDeposit",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"gets the total user deposit",params:{account:"the user address"},returns:{_0:"user total deposit in (AURORA)"}},"grantRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"grantRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role."},"hasRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"hasRole",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns `true` if `account` has been granted `role`."},"initialize(address,address,uint256[],uint256[],uint256,uint256,address,uint256,uint256)":{inputs:[{internalType:"address",name:"aurora",type:"address"},{internalType:"address",name:"streamOwner",type:"address"},{internalType:"uint256[]",name:"scheduleTimes",type:"uint256[]"},{internalType:"uint256[]",name:"scheduleRewards",type:"uint256[]"},{internalType:"uint256",name:"tauAuroraStream",type:"uint256"},{internalType:"uint256",name:"_flags",type:"uint256"},{internalType:"address",name:"_treasury",type:"address"},{internalType:"uint256",name:"_maxWeight",type:"uint256"},{internalType:"uint256",name:"_minWeight",type:"uint256"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function",details:"initialize the contract and deploys the first stream (AURORA)",params:{_flags:"admin controlled contract flags",_maxWeight:"max stream reward weighting coefficient",_minWeight:"min stream reward weighting coefficient",_treasury:"the Aurora treasury contract address",aurora:"token contract address",scheduleRewards:"init the schedule amounts",scheduleTimes:"init the schedule time",tauAuroraStream:"release time constant per stream (e.g AURORA stream)"},notice:"By calling this function, the deployer of this contract must make sure that the AURORA reward amount was deposited to the treasury contract before initializing of the default AURORA stream."},"maxWeight()":{inputs:[],name:"maxWeight",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"minWeight()":{inputs:[],name:"minWeight",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"moveAllRewardsToPending()":{inputs:[],name:"moveAllRewardsToPending",outputs:[],stateMutability:"nonpayable",type:"function",details:"moves all the user rewards to pending reward."},"moveRewardsToPending(uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"}],name:"moveRewardsToPending",outputs:[],stateMutability:"nonpayable",type:"function",details:"moves the reward for specific stream Id to pending rewards. It will require a waiting time untill it get released. Users call this in function in order to claim rewards.",params:{streamId:"stream index"}},"paused()":{inputs:[],name:"paused",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"proposeStream(address,address,uint256,uint256,uint256,uint256[],uint256[],uint256)":{inputs:[{internalType:"address",name:"streamOwner",type:"address"},{internalType:"address",name:"rewardToken",type:"address"},{internalType:"uint256",name:"auroraDepositAmount",type:"uint256"},{internalType:"uint256",name:"maxDepositAmount",type:"uint256"},{internalType:"uint256",name:"minDepositAmount",type:"uint256"},{internalType:"uint256[]",name:"scheduleTimes",type:"uint256[]"},{internalType:"uint256[]",name:"scheduleRewards",type:"uint256[]"},{internalType:"uint256",name:"tau",type:"uint256"}],name:"proposeStream",outputs:[],stateMutability:"nonpayable",type:"function",details:"An admin of the staking contract can whitelist (propose) a stream. Whitelisting of the stream provides the option for the stream owner (presumably the issuing party of a specific token) to deposit some ERC-20 tokens on the staking contract and potentially get in return some AURORA tokens. Deposited ERC-20 tokens will be distributed to the stakers over some period of time.",params:{auroraDepositAmount:"Amount of the AURORA deposited by the Admin.",maxDepositAmount:"The upper amount of the tokens that should be deposited by the stream owner",rewardToken:"the address of the ERC-20 tokens to be deposited in the stream",scheduleRewards:"remaining rewards to be delivered at the beginning of each scheduled interval. Last element is always zero. First value (in scheduleRewards) from array is supposed to be a total amount of rewards for stream.",scheduleTimes:"timestamp denoting the start of each scheduled interval. Last element is the end of the stream.",streamOwner:"only this account would be able to create a stream",tau:"the tau is (pending release period) for this stream (e.g one day)"},notice:"treasury manager must call"},"releaseAuroraRewardsToStreamOwner(uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"}],name:"releaseAuroraRewardsToStreamOwner",outputs:[],stateMutability:"nonpayable",type:"function",details:"the release of AURORA tokens to the stream owner is subjected to the same schedule as rewards. Thus if for a specific moment in time 30% of the rewards are distributed, then it means that 30% of the AURORA deposit can be withdrawn by the stream owner too. called by the stream owner",params:{streamId:"the stream index"}},"removeStream(uint256,address)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"},{internalType:"address",name:"streamFundReceiver",type:"address"}],name:"removeStream",outputs:[],stateMutability:"nonpayable",type:"function",details:"removes a stream (only default admin role)",params:{streamFundReceiver:"receives the rest of the reward tokens in the stream",streamId:"stream index"}},"renounceRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"renounceRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been revoked `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`."},"revokeRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"revokeRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role."},"rewardsSchedule(uint256,uint256,uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"},{internalType:"uint256",name:"start",type:"uint256"},{internalType:"uint256",name:"end",type:"uint256"}],name:"rewardsSchedule",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"calculate the total amount of the released tokens within a period (start & end)",params:{end:"is the end timestamp (e.g block.timestamp .. now)",start:"is the start timestamp within the schedule",streamId:"the stream index"},returns:{_0:"amount of the released tokens for that period"}},"stake(uint256)":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"}],name:"stake",outputs:[],stateMutability:"nonpayable",type:"function",details:"a user stakes amount of AURORA tokens The user should approve these tokens to the treasury contract in order to complete the stake.",params:{amount:"is the AURORA amount."}},"stakeOnBehalfOfAnotherUser(address,uint256)":{inputs:[{internalType:"address",name:"account",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"stakeOnBehalfOfAnotherUser",outputs:[],stateMutability:"nonpayable",type:"function",details:"stakeOnBehalfOfAnotherUser is called for airdropping Aurora users",params:{account:"the account address",amount:"in AURORA tokens WARNING: rewards are not claimed during stake. Airdrop script must claim or only distribute to accounts without stake"}},"stakeOnBehalfOfOtherUsers(address[],uint256[],uint256)":{inputs:[{internalType:"address[]",name:"accounts",type:"address[]"},{internalType:"uint256[]",name:"amounts",type:"uint256[]"},{internalType:"uint256",name:"batchAmount",type:"uint256"}],name:"stakeOnBehalfOfOtherUsers",outputs:[],stateMutability:"nonpayable",type:"function",details:"stakeOnBehalfOfOtherUsers called for airdropping Aurora users",params:{accounts:"the account address",amounts:"in AURORA tokens",batchAmount:"equals to the sum of amounts WARNING: rewards are not claimed during stake. Airdrop script must claim or only distribute to accounts without stake"}},"startEndScheduleIndex(uint256,uint256,uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"},{internalType:"uint256",name:"start",type:"uint256"},{internalType:"uint256",name:"end",type:"uint256"}],name:"startEndScheduleIndex",outputs:[{internalType:"uint256",name:"startIndex",type:"uint256"},{internalType:"uint256",name:"endIndex",type:"uint256"}],stateMutability:"view",type:"function",details:"gets start index and end index in a stream schedule",params:{end:"end time (in seconds)",start:"start time (in seconds)",streamId:"stream index"}},"supportsInterface(bytes4)":{inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"See {IERC165-supportsInterface}."},"tempMoveRewardsToPending(address,uint256)":{inputs:[{internalType:"address",name:"account",type:"address"},{internalType:"uint256",name:"streamId",type:"uint256"}],name:"tempMoveRewardsToPending",outputs:[],stateMutability:"nonpayable",type:"function"},"totalAmountOfStakedAurora()":{inputs:[],name:"totalAmountOfStakedAurora",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"totalAuroraShares()":{inputs:[],name:"totalAuroraShares",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"totalStreamShares()":{inputs:[],name:"totalStreamShares",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"touchedAt()":{inputs:[],name:"touchedAt",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"treasury()":{inputs:[],name:"treasury",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"unstake(uint256)":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"}],name:"unstake",outputs:[],stateMutability:"nonpayable",type:"function",details:"unstake amount from user shares value. The rest is re-staked",params:{amount:"to unstake"}},"unstakeAll()":{inputs:[],name:"unstakeAll",outputs:[],stateMutability:"nonpayable",type:"function",details:"unstake all the user's shares"},"unstakeAllOnBehalfOfOthers(address[])":{inputs:[{internalType:"address[]",name:"accounts",type:"address[]"}],name:"unstakeAllOnBehalfOfOthers",outputs:[],stateMutability:"nonpayable",type:"function"},"updateTreasury(address)":{inputs:[{internalType:"address",name:"_treasury",type:"address"}],name:"updateTreasury",outputs:[],stateMutability:"nonpayable",type:"function",details:"restricted for the admin only. Admin should pause this contract before changing the treasury address by setting the pause =1 (for changing this variable, call adminPause(1))",params:{_treasury:"treasury contract address for the reward tokens"},notice:"updates treasury account"},"updateUserCalculation()":{inputs:[],name:"updateUserCalculation",outputs:[],stateMutability:"nonpayable",type:"function"},"upgradeTo(address)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"}],name:"upgradeTo",outputs:[],stateMutability:"nonpayable",type:"function",details:"Upgrade the implementation of the proxy to `newImplementation`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."},"upgradeToAndCall(address,bytes)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"},{internalType:"bytes",name:"data",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable",type:"function",details:"Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call encoded in `data`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."},"users(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"users",outputs:[{internalType:"uint256",name:"deposit",type:"uint256"},{internalType:"uint256",name:"auroraShares",type:"uint256"},{internalType:"uint256",name:"streamShares",type:"uint256"}],stateMutability:"view",type:"function"},"withdraw(uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"}],name:"withdraw",outputs:[],stateMutability:"nonpayable",type:"function",details:"withdraw amount in the pending pool. User should wait for pending time (tau constant) in order to be able to withdraw.",params:{streamId:"stream index"}},"withdrawAll()":{inputs:[],name:"withdrawAll",outputs:[],stateMutability:"nonpayable",type:"function",details:"withdraw all claimed balances which have passed pending periode. This function will reach gas limit with too many streams, so the frontend will allow individual stream withdrawals and disable withdrawAll."}}},"contracts/testing/upgrades/JetStakingV1/JetStakingV1ChangeInStorage.sol:JetStakingV1ChangeInStorage":{source:"contracts/testing/upgrades/JetStakingV1/JetStakingV1ChangeInStorage.sol",name:"JetStakingV1ChangeInStorage",events:{"AdminChanged(address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"previousAdmin",type:"address"},{indexed:!1,internalType:"address",name:"newAdmin",type:"address"}],name:"AdminChanged",type:"event"},"BeaconUpgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"beacon",type:"address"}],name:"BeaconUpgraded",type:"event"},"Pending(uint256,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"streamId",type:"uint256"},{indexed:!0,internalType:"address",name:"user",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"}],name:"Pending",type:"event"},"Released(uint256,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"streamId",type:"uint256"},{indexed:!0,internalType:"address",name:"user",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"}],name:"Released",type:"event"},"RoleAdminChanged(bytes32,bytes32,bytes32)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"previousAdminRole",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"newAdminRole",type:"bytes32"}],name:"RoleAdminChanged",type:"event"},"RoleGranted(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleGranted",type:"event"},"RoleRevoked(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleRevoked",type:"event"},"Staked(address,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"user",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"},{indexed:!1,internalType:"uint256",name:"shares",type:"uint256"}],name:"Staked",type:"event"},"StreamCreated(uint256,address,address,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"streamId",type:"uint256"},{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"token",type:"address"},{indexed:!1,internalType:"uint256",name:"tokenAmount",type:"uint256"},{indexed:!1,internalType:"uint256",name:"auroraAmount",type:"uint256"}],name:"StreamCreated",type:"event"},"StreamOwnerRewardReleased(uint256,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"streamId",type:"uint256"},{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"}],name:"StreamOwnerRewardReleased",type:"event"},"StreamProposalCancelled(uint256,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"streamId",type:"uint256"},{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"token",type:"address"}],name:"StreamProposalCancelled",type:"event"},"StreamProposed(uint256,address,address,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"streamId",type:"uint256"},{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"token",type:"address"},{indexed:!1,internalType:"uint256",name:"maxDepositAmount",type:"uint256"},{indexed:!1,internalType:"uint256",name:"auroraDepositAmount",type:"uint256"}],name:"StreamProposed",type:"event"},"StreamRemoved(uint256,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"streamId",type:"uint256"},{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"token",type:"address"}],name:"StreamRemoved",type:"event"},"Unstaked(address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"user",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"}],name:"Unstaked",type:"event"},"Upgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"implementation",type:"address"}],name:"Upgraded",type:"event"}},methods:{"AIRDROP_ROLE()":{inputs:[],name:"AIRDROP_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"CLAIM_ROLE()":{inputs:[],name:"CLAIM_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"DEFAULT_ADMIN_ROLE()":{inputs:[],name:"DEFAULT_ADMIN_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"FOUR_YEARS()":{inputs:[],name:"FOUR_YEARS",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"ONE_MONTH()":{inputs:[],name:"ONE_MONTH",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"PAUSE_ROLE()":{inputs:[],name:"PAUSE_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"STREAM_MANAGER_ROLE()":{inputs:[],name:"STREAM_MANAGER_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"adminDelegatecall(address,bytes)":{inputs:[{internalType:"address",name:"target",type:"address"},{internalType:"bytes",name:"data",type:"bytes"}],name:"adminDelegatecall",outputs:[{internalType:"bytes",name:"",type:"bytes"}],stateMutability:"payable",type:"function","custom:oz-upgrades-unsafe-allow":"delegatecall",details:"adminDelegatecall allows this contract to delegate calls to a target contract and execute it in the context of this contract. Only default admin role can call this function.",params:{data:"is the ABI encoded function signature and its values.",target:"the target contract address"}},"adminPause(uint256)":{inputs:[{internalType:"uint256",name:"flags",type:"uint256"}],name:"adminPause",outputs:[],stateMutability:"nonpayable",type:"function",details:"adminPause pauses this contract. Only pause role or default admin role can access this function.",params:{flags:"flags variable is used for pausing this contract."}},"adminSstore(uint256,uint256)":{inputs:[{internalType:"uint256",name:"key",type:"uint256"},{internalType:"uint256",name:"value",type:"uint256"}],name:"adminSstore",outputs:[],stateMutability:"nonpayable",type:"function",details:"adminSstore updates the state variable value. only default admin role can call this function.",params:{key:"is the storage slot of the state variable",value:"is the state variable value"}},"adminSstoreWithMask(uint256,uint256,uint256)":{inputs:[{internalType:"uint256",name:"key",type:"uint256"},{internalType:"uint256",name:"value",type:"uint256"},{internalType:"uint256",name:"mask",type:"uint256"}],name:"adminSstoreWithMask",outputs:[],stateMutability:"nonpayable",type:"function",details:"adminSstoreWithMask similar to adminSstore except it updates the state variable value after xor-ing this value with the old value and the mask, so the new value should be a result of xor(and(xor(value, oldval), mask), oldval). Only default admin role can call this function.",params:{key:"is the storage slot of the state variable",mask:"this value is used in calculating the new value",value:"is the state variable value"}},"auroraToken()":{inputs:[],name:"auroraToken",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"batchClaimOnBehalfOfAnotherUser(address,uint256[])":{inputs:[{internalType:"address",name:"account",type:"address"},{internalType:"uint256[]",name:"streamIds",type:"uint256[]"}],name:"batchClaimOnBehalfOfAnotherUser",outputs:[],stateMutability:"nonpayable",type:"function",details:"batchClaimOnBehalfOfAnotherUser when gas limits prevent users from claiming all.",params:{account:"the user account address.",streamIds:"to claim."}},"batchClaimOnBehalfOfOtherUsers(address[],uint256[])":{inputs:[{internalType:"address[]",name:"accounts",type:"address[]"},{internalType:"uint256[]",name:"streamIds",type:"uint256[]"}],name:"batchClaimOnBehalfOfOtherUsers",outputs:[],stateMutability:"nonpayable",type:"function",details:"Claim all stream rewards on behalf of other users.",params:{accounts:"the user account addresses."}},"batchMoveRewardsToPending(uint256[])":{inputs:[{internalType:"uint256[]",name:"streamIds",type:"uint256[]"}],name:"batchMoveRewardsToPending",outputs:[],stateMutability:"nonpayable",type:"function",details:"moves a set of stream Id rewards to pending. Allows user to select stream ids to claim from UI.",params:{streamIds:"stream indexes"}},"batchWithdraw(uint256[])":{inputs:[{internalType:"uint256[]",name:"streamIds",type:"uint256[]"}],name:"batchWithdraw",outputs:[],stateMutability:"nonpayable",type:"function",details:"withdraw a set of stream Ids. Allows user to select stream ids to withdraw from UI.",params:{streamIds:"to withdraw."}},"c_0x7e37e874(bytes32)":{inputs:[{internalType:"bytes32",name:"c__0x7e37e874",type:"bytes32"}],name:"c_0x7e37e874",outputs:[],stateMutability:"pure",type:"function"},"c_0xc1dd3536(bytes32)":{inputs:[{internalType:"bytes32",name:"c__0xc1dd3536",type:"bytes32"}],name:"c_0xc1dd3536",outputs:[],stateMutability:"pure",type:"function"},"c_0xe4418a13(bytes32)":{inputs:[{internalType:"bytes32",name:"c__0xe4418a13",type:"bytes32"}],name:"c_0xe4418a13",outputs:[],stateMutability:"pure",type:"function"},"cancelStreamProposal(uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"}],name:"cancelStreamProposal",outputs:[],stateMutability:"nonpayable",type:"function",details:"cancelStreamProposal cancels a proposal any time before the stream becomes active (created).",params:{streamId:"the stream index"}},"claimAllOnBehalfOfAnotherUser(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"claimAllOnBehalfOfAnotherUser",outputs:[],stateMutability:"nonpayable",type:"function",details:"Claim all stream rewards on behalf of another user.",params:{account:"the user account address."}},"claimAllOnBehalfOfOtherUsers(address[])":{inputs:[{internalType:"address[]",name:"accounts",type:"address[]"}],name:"claimAllOnBehalfOfOtherUsers",outputs:[],stateMutability:"nonpayable",type:"function",details:"Claim all stream rewards on behalf of other users.",params:{accounts:"the user account addresses."}},"claimOnBehalfOfAnotherUser(address,uint256)":{inputs:[{internalType:"address",name:"account",type:"address"},{internalType:"uint256",name:"streamId",type:"uint256"}],name:"claimOnBehalfOfAnotherUser",outputs:[],stateMutability:"nonpayable",type:"function",details:"Claim a stream's rewards on behalf of another user.",params:{account:"the user account address.",streamId:"to claim."}},"createStream(uint256,uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"},{internalType:"uint256",name:"rewardTokenAmount",type:"uint256"}],name:"createStream",outputs:[],stateMutability:"nonpayable",type:"function",details:"create new stream (only stream owner) stream owner must approve reward tokens to this contract.",params:{streamId:"stream id"}},"getAmountOfShares(uint256,address)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"},{internalType:"address",name:"account",type:"address"}],name:"getAmountOfShares",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"gets a user stream shares",params:{account:"the user address",streamId:"stream index"},returns:{_0:"user stream shares"}},"getLatestRewardPerShare(uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"}],name:"getLatestRewardPerShare",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"calculates and gets the latest reward per share (RPS) for a stream",params:{streamId:"stream index"},returns:{_0:"streams[streamId].rps + scheduled reward up till now"}},"getPending(uint256,address)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"},{internalType:"address",name:"account",type:"address"}],name:"getPending",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"gets the user's stream pending reward",params:{account:"user account",streamId:"stream index"},returns:{_0:"user.pendings[streamId]"}},"getReleaseTime(uint256,address)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"},{internalType:"address",name:"account",type:"address"}],name:"getReleaseTime",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"gets the user's stream reward release time",params:{account:"user account",streamId:"stream index"},returns:{_0:"user.releaseTime[streamId]"}},"getRewardPerShare(uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"}],name:"getRewardPerShare",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"gets reward per share (RPS) for a stream",params:{streamId:"stream index"},returns:{_0:"streams[streamId].rps"}},"getRewardPerShareForUser(uint256,address)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"},{internalType:"address",name:"account",type:"address"}],name:"getRewardPerShareForUser",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"gets the user's reward per share (RPS) for a stream",params:{streamId:"stream index"},returns:{_0:"user.rpsDuringLastClaim[streamId]"}},"getRewardsAmount(uint256,uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"},{internalType:"uint256",name:"lastUpdate",type:"uint256"}],name:"getRewardsAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"calculates and gets the latest released rewards.",params:{streamId:"stream index"},returns:{_0:"rewards released since last update."}},"getRoleAdmin(bytes32)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"}],name:"getRoleAdmin",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}."},"getStream(uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"}],name:"getStream",outputs:[{internalType:"address",name:"streamOwner",type:"address"},{internalType:"address",name:"rewardToken",type:"address"},{internalType:"uint256",name:"auroraDepositAmount",type:"uint256"},{internalType:"uint256",name:"auroraClaimedAmount",type:"uint256"},{internalType:"uint256",name:"rewardDepositAmount",type:"uint256"},{internalType:"uint256",name:"rewardClaimedAmount",type:"uint256"},{internalType:"uint256",name:"maxDepositAmount",type:"uint256"},{internalType:"uint256",name:"lastTimeOwnerClaimed",type:"uint256"},{internalType:"uint256",name:"rps",type:"uint256"},{internalType:"uint256",name:"tau",type:"uint256"},{internalType:"enum JetStakingV1.StreamStatus",name:"status",type:"uint8"}],stateMutability:"view",type:"function",details:"get the stream data",params:{streamId:"the stream index"},notice:"this function doesn't return the stream schedule due to some stake slots limitations. To get the stream schedule, refer to getStreamSchedule"},"getStreamClaimableAmount(uint256,address)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"},{internalType:"address",name:"account",type:"address"}],name:"getStreamClaimableAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"gets the user's stream claimable amount",params:{streamId:"stream index"},returns:{_0:"(latesRPS - user.rpsDuringLastClaim) * user.shares"}},"getStreamOwnerClaimableAmount(uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"}],name:"getStreamOwnerClaimableAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Stream owner claimable AURORA.",params:{streamId:"the stream index"}},"getStreamSchedule(uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"}],name:"getStreamSchedule",outputs:[{internalType:"uint256[]",name:"scheduleTimes",type:"uint256[]"},{internalType:"uint256[]",name:"scheduleRewards",type:"uint256[]"}],stateMutability:"view",type:"function",details:"get the stream schedule data",params:{streamId:"the stream index"}},"getStreamsCount()":{inputs:[],name:"getStreamsCount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"get the streams count",returns:{_0:"streams.length"}},"getTotalAmountOfStakedAurora()":{inputs:[],name:"getTotalAmountOfStakedAurora",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"gets the total amount of staked aurora",returns:{_0:"totalAmountOfStakedAurora + latest reward schedule"}},"getTreasuryBalance(address)":{inputs:[{internalType:"address",name:"token",type:"address"}],name:"getTreasuryBalance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Get the treasury balance",params:{token:"the token address"}},"getUserShares(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"getUserShares",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"gets the user shares",params:{account:"the user address"},returns:{_0:"user shares"}},"getUserTotalDeposit(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"getUserTotalDeposit",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"gets the total user deposit",params:{account:"the user address"},returns:{_0:"user total deposit in (AURORA)"}},"grantRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"grantRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role."},"hasRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"hasRole",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns `true` if `account` has been granted `role`."},"initialize(address,address,uint256[],uint256[],uint256,uint256,address,uint256,uint256)":{inputs:[{internalType:"address",name:"aurora",type:"address"},{internalType:"address",name:"streamOwner",type:"address"},{internalType:"uint256[]",name:"scheduleTimes",type:"uint256[]"},{internalType:"uint256[]",name:"scheduleRewards",type:"uint256[]"},{internalType:"uint256",name:"tauAuroraStream",type:"uint256"},{internalType:"uint256",name:"_flags",type:"uint256"},{internalType:"address",name:"_treasury",type:"address"},{internalType:"uint256",name:"_maxWeight",type:"uint256"},{internalType:"uint256",name:"_minWeight",type:"uint256"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function",details:"initialize the contract and deploys the first stream (AURORA)",params:{_flags:"admin controlled contract flags",_maxWeight:"max stream reward weighting coefficient",_minWeight:"min stream reward weighting coefficient",_treasury:"the Aurora treasury contract address",aurora:"token contract address",scheduleRewards:"init the schedule amounts",scheduleTimes:"init the schedule time",tauAuroraStream:"release time constant per stream (e.g AURORA stream)"},notice:"By calling this function, the deployer of this contract must make sure that the AURORA reward amount was deposited to the treasury contract before initializing of the default AURORA stream."},"maxWeight()":{inputs:[],name:"maxWeight",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"minWeight()":{inputs:[],name:"minWeight",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"moveAllRewardsToPending()":{inputs:[],name:"moveAllRewardsToPending",outputs:[],stateMutability:"nonpayable",type:"function",details:"moves all the user rewards to pending reward."},"moveRewardsToPending(uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"}],name:"moveRewardsToPending",outputs:[],stateMutability:"nonpayable",type:"function",details:"moves the reward for specific stream Id to pending rewards. It will require a waiting time untill it get released. Users call this in function in order to claim rewards.",params:{streamId:"stream index"}},"paused()":{inputs:[],name:"paused",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"proposeStream(address,address,uint256,uint256,uint256,uint256[],uint256[],uint256)":{inputs:[{internalType:"address",name:"streamOwner",type:"address"},{internalType:"address",name:"rewardToken",type:"address"},{internalType:"uint256",name:"auroraDepositAmount",type:"uint256"},{internalType:"uint256",name:"maxDepositAmount",type:"uint256"},{internalType:"uint256",name:"minDepositAmount",type:"uint256"},{internalType:"uint256[]",name:"scheduleTimes",type:"uint256[]"},{internalType:"uint256[]",name:"scheduleRewards",type:"uint256[]"},{internalType:"uint256",name:"tau",type:"uint256"}],name:"proposeStream",outputs:[],stateMutability:"nonpayable",type:"function",details:"An admin of the staking contract can whitelist (propose) a stream. Whitelisting of the stream provides the option for the stream owner (presumably the issuing party of a specific token) to deposit some ERC-20 tokens on the staking contract and potentially get in return some AURORA tokens. Deposited ERC-20 tokens will be distributed to the stakers over some period of time.",params:{auroraDepositAmount:"Amount of the AURORA deposited by the Admin.",maxDepositAmount:"The upper amount of the tokens that should be deposited by the stream owner",rewardToken:"the address of the ERC-20 tokens to be deposited in the stream",scheduleRewards:"remaining rewards to be delivered at the beginning of each scheduled interval. Last element is always zero. First value (in scheduleRewards) from array is supposed to be a total amount of rewards for stream.",scheduleTimes:"timestamp denoting the start of each scheduled interval. Last element is the end of the stream.",streamOwner:"only this account would be able to create a stream",tau:"the tau is (pending release period) for this stream (e.g one day)"},notice:"treasury manager must call"},"releaseAuroraRewardsToStreamOwner(uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"}],name:"releaseAuroraRewardsToStreamOwner",outputs:[],stateMutability:"nonpayable",type:"function",details:"the release of AURORA tokens to the stream owner is subjected to the same schedule as rewards. Thus if for a specific moment in time 30% of the rewards are distributed, then it means that 30% of the AURORA deposit can be withdrawn by the stream owner too. called by the stream owner",params:{streamId:"the stream index"}},"removeStream(uint256,address)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"},{internalType:"address",name:"streamFundReceiver",type:"address"}],name:"removeStream",outputs:[],stateMutability:"nonpayable",type:"function",details:"removes a stream (only default admin role)",params:{streamFundReceiver:"receives the rest of the reward tokens in the stream",streamId:"stream index"}},"renounceRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"renounceRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been revoked `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`."},"revokeRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"revokeRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role."},"rewardsSchedule(uint256,uint256,uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"},{internalType:"uint256",name:"start",type:"uint256"},{internalType:"uint256",name:"end",type:"uint256"}],name:"rewardsSchedule",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"calculate the total amount of the released tokens within a period (start & end)",params:{end:"is the end timestamp (e.g block.timestamp .. now)",start:"is the start timestamp within the schedule",streamId:"the stream index"},returns:{_0:"amount of the released tokens for that period"}},"stake(uint256)":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"}],name:"stake",outputs:[],stateMutability:"nonpayable",type:"function",details:"a user stakes amount of AURORA tokens The user should approve these tokens to the treasury contract in order to complete the stake.",params:{amount:"is the AURORA amount."}},"stakeOnBehalfOfAnotherUser(address,uint256)":{inputs:[{internalType:"address",name:"account",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"stakeOnBehalfOfAnotherUser",outputs:[],stateMutability:"nonpayable",type:"function",details:"stakeOnBehalfOfAnotherUser is called for airdropping Aurora users",params:{account:"the account address",amount:"in AURORA tokens WARNING: rewards are not claimed during stake. Airdrop script must claim or only distribute to accounts without stake"}},"stakeOnBehalfOfOtherUsers(address[],uint256[],uint256)":{inputs:[{internalType:"address[]",name:"accounts",type:"address[]"},{internalType:"uint256[]",name:"amounts",type:"uint256[]"},{internalType:"uint256",name:"batchAmount",type:"uint256"}],name:"stakeOnBehalfOfOtherUsers",outputs:[],stateMutability:"nonpayable",type:"function",details:"stakeOnBehalfOfOtherUsers called for airdropping Aurora users",params:{accounts:"the account address",amounts:"in AURORA tokens",batchAmount:"equals to the sum of amounts WARNING: rewards are not claimed during stake. Airdrop script must claim or only distribute to accounts without stake"}},"startEndScheduleIndex(uint256,uint256,uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"},{internalType:"uint256",name:"start",type:"uint256"},{internalType:"uint256",name:"end",type:"uint256"}],name:"startEndScheduleIndex",outputs:[{internalType:"uint256",name:"startIndex",type:"uint256"},{internalType:"uint256",name:"endIndex",type:"uint256"}],stateMutability:"view",type:"function",details:"gets start index and end index in a stream schedule",params:{end:"end time (in seconds)",start:"start time (in seconds)",streamId:"stream index"}},"storageVar()":{inputs:[],name:"storageVar",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"supportsInterface(bytes4)":{inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"See {IERC165-supportsInterface}."},"totalAmountOfStakedAurora()":{inputs:[],name:"totalAmountOfStakedAurora",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"totalAuroraShares()":{inputs:[],name:"totalAuroraShares",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"totalStreamShares()":{inputs:[],name:"totalStreamShares",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"touchedAt()":{inputs:[],name:"touchedAt",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"treasury()":{inputs:[],name:"treasury",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"unstake(uint256)":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"}],name:"unstake",outputs:[],stateMutability:"nonpayable",type:"function",details:"unstake amount from user shares value. The rest is re-staked",params:{amount:"to unstake"}},"unstakeAll()":{inputs:[],name:"unstakeAll",outputs:[],stateMutability:"nonpayable",type:"function",details:"unstake all the user's shares"},"updateTreasury(address)":{inputs:[{internalType:"address",name:"_treasury",type:"address"}],name:"updateTreasury",outputs:[],stateMutability:"nonpayable",type:"function",details:"restricted for the admin only. Admin should pause this contract before changing the treasury address by setting the pause =1 (for changing this variable, call adminPause(1))",params:{_treasury:"treasury contract address for the reward tokens"},notice:"updates treasury account"},"upgradeTo(address)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"}],name:"upgradeTo",outputs:[],stateMutability:"nonpayable",type:"function",details:"Upgrade the implementation of the proxy to `newImplementation`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."},"upgradeToAndCall(address,bytes)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"},{internalType:"bytes",name:"data",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable",type:"function",details:"Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call encoded in `data`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."},"users(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"users",outputs:[{internalType:"uint256",name:"deposit",type:"uint256"},{internalType:"uint256",name:"auroraShares",type:"uint256"},{internalType:"uint256",name:"streamShares",type:"uint256"}],stateMutability:"view",type:"function"},"withdraw(uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"}],name:"withdraw",outputs:[],stateMutability:"nonpayable",type:"function",details:"withdraw amount in the pending pool. User should wait for pending time (tau constant) in order to be able to withdraw.",params:{streamId:"stream index"}},"withdrawAll()":{inputs:[],name:"withdrawAll",outputs:[],stateMutability:"nonpayable",type:"function",details:"withdraw all claimed balances which have passed pending periode. This function will reach gas limit with too many streams, so the frontend will allow individual stream withdrawals and disable withdrawAll."}}},"contracts/testing/upgrades/JetStakingV1/JetStakingV1ChangeInStorageAndLogic.sol:JetStakingV1ChangeInStorageAndLogic":{source:"contracts/testing/upgrades/JetStakingV1/JetStakingV1ChangeInStorageAndLogic.sol",name:"JetStakingV1ChangeInStorageAndLogic",events:{"AdminChanged(address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"previousAdmin",type:"address"},{indexed:!1,internalType:"address",name:"newAdmin",type:"address"}],name:"AdminChanged",type:"event"},"BeaconUpgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"beacon",type:"address"}],name:"BeaconUpgraded",type:"event"},"Pending(uint256,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"streamId",type:"uint256"},{indexed:!0,internalType:"address",name:"user",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"}],name:"Pending",type:"event"},"Released(uint256,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"streamId",type:"uint256"},{indexed:!0,internalType:"address",name:"user",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"}],name:"Released",type:"event"},"RoleAdminChanged(bytes32,bytes32,bytes32)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"previousAdminRole",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"newAdminRole",type:"bytes32"}],name:"RoleAdminChanged",type:"event"},"RoleGranted(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleGranted",type:"event"},"RoleRevoked(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleRevoked",type:"event"},"Staked(address,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"user",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"},{indexed:!1,internalType:"uint256",name:"shares",type:"uint256"}],name:"Staked",type:"event"},"StreamCreated(uint256,address,address,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"streamId",type:"uint256"},{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"token",type:"address"},{indexed:!1,internalType:"uint256",name:"tokenAmount",type:"uint256"},{indexed:!1,internalType:"uint256",name:"auroraAmount",type:"uint256"}],name:"StreamCreated",type:"event"},"StreamOwnerRewardReleased(uint256,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"streamId",type:"uint256"},{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"}],name:"StreamOwnerRewardReleased",type:"event"},"StreamProposalCancelled(uint256,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"streamId",type:"uint256"},{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"token",type:"address"}],name:"StreamProposalCancelled",type:"event"},"StreamProposed(uint256,address,address,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"streamId",type:"uint256"},{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"token",type:"address"},{indexed:!1,internalType:"uint256",name:"maxDepositAmount",type:"uint256"},{indexed:!1,internalType:"uint256",name:"auroraDepositAmount",type:"uint256"}],name:"StreamProposed",type:"event"},"StreamRemoved(uint256,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"streamId",type:"uint256"},{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"token",type:"address"}],name:"StreamRemoved",type:"event"},"Unstaked(address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"user",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"}],name:"Unstaked",type:"event"},"Upgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"implementation",type:"address"}],name:"Upgraded",type:"event"}},methods:{"AIRDROP_ROLE()":{inputs:[],name:"AIRDROP_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"CLAIM_ROLE()":{inputs:[],name:"CLAIM_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"DEFAULT_ADMIN_ROLE()":{inputs:[],name:"DEFAULT_ADMIN_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"FOUR_YEARS()":{inputs:[],name:"FOUR_YEARS",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"ONE_MONTH()":{inputs:[],name:"ONE_MONTH",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"PAUSE_ROLE()":{inputs:[],name:"PAUSE_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"STREAM_MANAGER_ROLE()":{inputs:[],name:"STREAM_MANAGER_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"adminDelegatecall(address,bytes)":{inputs:[{internalType:"address",name:"target",type:"address"},{internalType:"bytes",name:"data",type:"bytes"}],name:"adminDelegatecall",outputs:[{internalType:"bytes",name:"",type:"bytes"}],stateMutability:"payable",type:"function","custom:oz-upgrades-unsafe-allow":"delegatecall",details:"adminDelegatecall allows this contract to delegate calls to a target contract and execute it in the context of this contract. Only default admin role can call this function.",params:{data:"is the ABI encoded function signature and its values.",target:"the target contract address"}},"adminPause(uint256)":{inputs:[{internalType:"uint256",name:"flags",type:"uint256"}],name:"adminPause",outputs:[],stateMutability:"nonpayable",type:"function",details:"adminPause pauses this contract. Only pause role or default admin role can access this function.",params:{flags:"flags variable is used for pausing this contract."}},"adminSstore(uint256,uint256)":{inputs:[{internalType:"uint256",name:"key",type:"uint256"},{internalType:"uint256",name:"value",type:"uint256"}],name:"adminSstore",outputs:[],stateMutability:"nonpayable",type:"function",details:"adminSstore updates the state variable value. only default admin role can call this function.",params:{key:"is the storage slot of the state variable",value:"is the state variable value"}},"adminSstoreWithMask(uint256,uint256,uint256)":{inputs:[{internalType:"uint256",name:"key",type:"uint256"},{internalType:"uint256",name:"value",type:"uint256"},{internalType:"uint256",name:"mask",type:"uint256"}],name:"adminSstoreWithMask",outputs:[],stateMutability:"nonpayable",type:"function",details:"adminSstoreWithMask similar to adminSstore except it updates the state variable value after xor-ing this value with the old value and the mask, so the new value should be a result of xor(and(xor(value, oldval), mask), oldval). Only default admin role can call this function.",params:{key:"is the storage slot of the state variable",mask:"this value is used in calculating the new value",value:"is the state variable value"}},"auroraToken()":{inputs:[],name:"auroraToken",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"batchClaimOnBehalfOfAnotherUser(address,uint256[])":{inputs:[{internalType:"address",name:"account",type:"address"},{internalType:"uint256[]",name:"streamIds",type:"uint256[]"}],name:"batchClaimOnBehalfOfAnotherUser",outputs:[],stateMutability:"nonpayable",type:"function",details:"batchClaimOnBehalfOfAnotherUser when gas limits prevent users from claiming all.",params:{account:"the user account address.",streamIds:"to claim."}},"batchClaimOnBehalfOfOtherUsers(address[],uint256[])":{inputs:[{internalType:"address[]",name:"accounts",type:"address[]"},{internalType:"uint256[]",name:"streamIds",type:"uint256[]"}],name:"batchClaimOnBehalfOfOtherUsers",outputs:[],stateMutability:"nonpayable",type:"function",details:"Claim all stream rewards on behalf of other users.",params:{accounts:"the user account addresses."}},"batchMoveRewardsToPending(uint256[])":{inputs:[{internalType:"uint256[]",name:"streamIds",type:"uint256[]"}],name:"batchMoveRewardsToPending",outputs:[],stateMutability:"nonpayable",type:"function",details:"moves a set of stream Id rewards to pending. Allows user to select stream ids to claim from UI.",params:{streamIds:"stream indexes"}},"batchWithdraw(uint256[])":{inputs:[{internalType:"uint256[]",name:"streamIds",type:"uint256[]"}],name:"batchWithdraw",outputs:[],stateMutability:"nonpayable",type:"function",details:"withdraw a set of stream Ids. Allows user to select stream ids to withdraw from UI.",params:{streamIds:"to withdraw."}},"c_0x7e37e874(bytes32)":{inputs:[{internalType:"bytes32",name:"c__0x7e37e874",type:"bytes32"}],name:"c_0x7e37e874",outputs:[],stateMutability:"pure",type:"function"},"c_0xc1dd3536(bytes32)":{inputs:[{internalType:"bytes32",name:"c__0xc1dd3536",type:"bytes32"}],name:"c_0xc1dd3536",outputs:[],stateMutability:"pure",type:"function"},"c_0xdfe37620(bytes32)":{inputs:[{internalType:"bytes32",name:"c__0xdfe37620",type:"bytes32"}],name:"c_0xdfe37620",outputs:[],stateMutability:"pure",type:"function"},"cancelStreamProposal(uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"}],name:"cancelStreamProposal",outputs:[],stateMutability:"nonpayable",type:"function",details:"cancelStreamProposal cancels a proposal any time before the stream becomes active (created).",params:{streamId:"the stream index"}},"claimAllOnBehalfOfAnotherUser(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"claimAllOnBehalfOfAnotherUser",outputs:[],stateMutability:"nonpayable",type:"function",details:"Claim all stream rewards on behalf of another user.",params:{account:"the user account address."}},"claimAllOnBehalfOfOtherUsers(address[])":{inputs:[{internalType:"address[]",name:"accounts",type:"address[]"}],name:"claimAllOnBehalfOfOtherUsers",outputs:[],stateMutability:"nonpayable",type:"function",details:"Claim all stream rewards on behalf of other users.",params:{accounts:"the user account addresses."}},"claimOnBehalfOfAnotherUser(address,uint256)":{inputs:[{internalType:"address",name:"account",type:"address"},{internalType:"uint256",name:"streamId",type:"uint256"}],name:"claimOnBehalfOfAnotherUser",outputs:[],stateMutability:"nonpayable",type:"function",details:"Claim a stream's rewards on behalf of another user.",params:{account:"the user account address.",streamId:"to claim."}},"createStream(uint256,uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"},{internalType:"uint256",name:"rewardTokenAmount",type:"uint256"}],name:"createStream",outputs:[],stateMutability:"nonpayable",type:"function",details:"create new stream (only stream owner) stream owner must approve reward tokens to this contract.",params:{streamId:"stream id"}},"getAmountOfShares(uint256,address)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"},{internalType:"address",name:"account",type:"address"}],name:"getAmountOfShares",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"gets a user stream shares",params:{account:"the user address",streamId:"stream index"},returns:{_0:"user stream shares"}},"getLatestRewardPerShare(uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"}],name:"getLatestRewardPerShare",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"calculates and gets the latest reward per share (RPS) for a stream",params:{streamId:"stream index"},returns:{_0:"streams[streamId].rps + scheduled reward up till now"}},"getPending(uint256,address)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"},{internalType:"address",name:"account",type:"address"}],name:"getPending",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"gets the user's stream pending reward",params:{account:"user account",streamId:"stream index"},returns:{_0:"user.pendings[streamId]"}},"getReleaseTime(uint256,address)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"},{internalType:"address",name:"account",type:"address"}],name:"getReleaseTime",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"gets the user's stream reward release time",params:{account:"user account",streamId:"stream index"},returns:{_0:"user.releaseTime[streamId]"}},"getRewardPerShare(uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"}],name:"getRewardPerShare",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"gets reward per share (RPS) for a stream",params:{streamId:"stream index"},returns:{_0:"streams[streamId].rps"}},"getRewardPerShareForUser(uint256,address)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"},{internalType:"address",name:"account",type:"address"}],name:"getRewardPerShareForUser",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"gets the user's reward per share (RPS) for a stream",params:{streamId:"stream index"},returns:{_0:"user.rpsDuringLastClaim[streamId]"}},"getRewardsAmount(uint256,uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"},{internalType:"uint256",name:"lastUpdate",type:"uint256"}],name:"getRewardsAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"calculates and gets the latest released rewards.",params:{streamId:"stream index"},returns:{_0:"rewards released since last update."}},"getRoleAdmin(bytes32)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"}],name:"getRoleAdmin",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}."},"getStream(uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"}],name:"getStream",outputs:[{internalType:"address",name:"streamOwner",type:"address"},{internalType:"address",name:"rewardToken",type:"address"},{internalType:"uint256",name:"auroraDepositAmount",type:"uint256"},{internalType:"uint256",name:"auroraClaimedAmount",type:"uint256"},{internalType:"uint256",name:"rewardDepositAmount",type:"uint256"},{internalType:"uint256",name:"rewardClaimedAmount",type:"uint256"},{internalType:"uint256",name:"maxDepositAmount",type:"uint256"},{internalType:"uint256",name:"lastTimeOwnerClaimed",type:"uint256"},{internalType:"uint256",name:"rps",type:"uint256"},{internalType:"uint256",name:"tau",type:"uint256"},{internalType:"enum JetStakingV1.StreamStatus",name:"status",type:"uint8"}],stateMutability:"view",type:"function",details:"get the stream data",params:{streamId:"the stream index"},notice:"this function doesn't return the stream schedule due to some stake slots limitations. To get the stream schedule, refer to getStreamSchedule"},"getStreamClaimableAmount(uint256,address)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"},{internalType:"address",name:"account",type:"address"}],name:"getStreamClaimableAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"gets the user's stream claimable amount",params:{streamId:"stream index"},returns:{_0:"(latesRPS - user.rpsDuringLastClaim) * user.shares"}},"getStreamOwnerClaimableAmount(uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"}],name:"getStreamOwnerClaimableAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Stream owner claimable AURORA.",params:{streamId:"the stream index"}},"getStreamSchedule(uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"}],name:"getStreamSchedule",outputs:[{internalType:"uint256[]",name:"scheduleTimes",type:"uint256[]"},{internalType:"uint256[]",name:"scheduleRewards",type:"uint256[]"}],stateMutability:"view",type:"function",details:"get the stream schedule data",params:{streamId:"the stream index"}},"getStreamsCount()":{inputs:[],name:"getStreamsCount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"get the streams count",returns:{_0:"streams.length"}},"getTotalAmountOfStakedAurora()":{inputs:[],name:"getTotalAmountOfStakedAurora",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"gets the total amount of staked aurora",returns:{_0:"totalAmountOfStakedAurora + latest reward schedule"}},"getTreasuryBalance(address)":{inputs:[{internalType:"address",name:"token",type:"address"}],name:"getTreasuryBalance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Get the treasury balance",params:{token:"the token address"}},"getUserShares(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"getUserShares",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"gets the user shares",params:{account:"the user address"},returns:{_0:"user shares"}},"getUserTotalDeposit(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"getUserTotalDeposit",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"gets the total user deposit",params:{account:"the user address"},returns:{_0:"user total deposit in (AURORA)"}},"grantRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"grantRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role."},"hasRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"hasRole",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns `true` if `account` has been granted `role`."},"initialize(address,address,uint256[],uint256[],uint256,uint256,address,uint256,uint256)":{inputs:[{internalType:"address",name:"aurora",type:"address"},{internalType:"address",name:"streamOwner",type:"address"},{internalType:"uint256[]",name:"scheduleTimes",type:"uint256[]"},{internalType:"uint256[]",name:"scheduleRewards",type:"uint256[]"},{internalType:"uint256",name:"tauAuroraStream",type:"uint256"},{internalType:"uint256",name:"_flags",type:"uint256"},{internalType:"address",name:"_treasury",type:"address"},{internalType:"uint256",name:"_maxWeight",type:"uint256"},{internalType:"uint256",name:"_minWeight",type:"uint256"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function",details:"initialize the contract and deploys the first stream (AURORA)",params:{_flags:"admin controlled contract flags",_maxWeight:"max stream reward weighting coefficient",_minWeight:"min stream reward weighting coefficient",_treasury:"the Aurora treasury contract address",aurora:"token contract address",scheduleRewards:"init the schedule amounts",scheduleTimes:"init the schedule time",tauAuroraStream:"release time constant per stream (e.g AURORA stream)"},notice:"By calling this function, the deployer of this contract must make sure that the AURORA reward amount was deposited to the treasury contract before initializing of the default AURORA stream."},"maxWeight()":{inputs:[],name:"maxWeight",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"minWeight()":{inputs:[],name:"minWeight",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"moveAllRewardsToPending()":{inputs:[],name:"moveAllRewardsToPending",outputs:[],stateMutability:"nonpayable",type:"function",details:"moves all the user rewards to pending reward."},"moveRewardsToPending(uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"}],name:"moveRewardsToPending",outputs:[],stateMutability:"nonpayable",type:"function",details:"moves the reward for specific stream Id to pending rewards. It will require a waiting time untill it get released. Users call this in function in order to claim rewards.",params:{streamId:"stream index"}},"paused()":{inputs:[],name:"paused",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"proposeStream(address,address,uint256,uint256,uint256,uint256[],uint256[],uint256)":{inputs:[{internalType:"address",name:"streamOwner",type:"address"},{internalType:"address",name:"rewardToken",type:"address"},{internalType:"uint256",name:"auroraDepositAmount",type:"uint256"},{internalType:"uint256",name:"maxDepositAmount",type:"uint256"},{internalType:"uint256",name:"minDepositAmount",type:"uint256"},{internalType:"uint256[]",name:"scheduleTimes",type:"uint256[]"},{internalType:"uint256[]",name:"scheduleRewards",type:"uint256[]"},{internalType:"uint256",name:"tau",type:"uint256"}],name:"proposeStream",outputs:[],stateMutability:"nonpayable",type:"function",details:"An admin of the staking contract can whitelist (propose) a stream. Whitelisting of the stream provides the option for the stream owner (presumably the issuing party of a specific token) to deposit some ERC-20 tokens on the staking contract and potentially get in return some AURORA tokens. Deposited ERC-20 tokens will be distributed to the stakers over some period of time.",params:{auroraDepositAmount:"Amount of the AURORA deposited by the Admin.",maxDepositAmount:"The upper amount of the tokens that should be deposited by the stream owner",rewardToken:"the address of the ERC-20 tokens to be deposited in the stream",scheduleRewards:"remaining rewards to be delivered at the beginning of each scheduled interval. Last element is always zero. First value (in scheduleRewards) from array is supposed to be a total amount of rewards for stream.",scheduleTimes:"timestamp denoting the start of each scheduled interval. Last element is the end of the stream.",streamOwner:"only this account would be able to create a stream",tau:"the tau is (pending release period) for this stream (e.g one day)"},notice:"treasury manager must call"},"releaseAuroraRewardsToStreamOwner(uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"}],name:"releaseAuroraRewardsToStreamOwner",outputs:[],stateMutability:"nonpayable",type:"function",details:"the release of AURORA tokens to the stream owner is subjected to the same schedule as rewards. Thus if for a specific moment in time 30% of the rewards are distributed, then it means that 30% of the AURORA deposit can be withdrawn by the stream owner too. called by the stream owner",params:{streamId:"the stream index"}},"removeStream(uint256,address)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"},{internalType:"address",name:"streamFundReceiver",type:"address"}],name:"removeStream",outputs:[],stateMutability:"nonpayable",type:"function",details:"removes a stream (only default admin role)",params:{streamFundReceiver:"receives the rest of the reward tokens in the stream",streamId:"stream index"}},"renounceRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"renounceRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been revoked `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`."},"revokeRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"revokeRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role."},"rewardsSchedule(uint256,uint256,uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"},{internalType:"uint256",name:"start",type:"uint256"},{internalType:"uint256",name:"end",type:"uint256"}],name:"rewardsSchedule",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"calculate the total amount of the released tokens within a period (start & end)",params:{end:"is the end timestamp (e.g block.timestamp .. now)",start:"is the start timestamp within the schedule",streamId:"the stream index"},returns:{_0:"amount of the released tokens for that period"}},"stake(uint256)":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"}],name:"stake",outputs:[],stateMutability:"nonpayable",type:"function",details:"a user stakes amount of AURORA tokens The user should approve these tokens to the treasury contract in order to complete the stake.",params:{amount:"is the AURORA amount."}},"stakeOnBehalfOfAnotherUser(address,uint256)":{inputs:[{internalType:"address",name:"account",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"stakeOnBehalfOfAnotherUser",outputs:[],stateMutability:"nonpayable",type:"function",details:"stakeOnBehalfOfAnotherUser is called for airdropping Aurora users",params:{account:"the account address",amount:"in AURORA tokens WARNING: rewards are not claimed during stake. Airdrop script must claim or only distribute to accounts without stake"}},"stakeOnBehalfOfOtherUsers(address[],uint256[],uint256)":{inputs:[{internalType:"address[]",name:"accounts",type:"address[]"},{internalType:"uint256[]",name:"amounts",type:"uint256[]"},{internalType:"uint256",name:"batchAmount",type:"uint256"}],name:"stakeOnBehalfOfOtherUsers",outputs:[],stateMutability:"nonpayable",type:"function",details:"stakeOnBehalfOfOtherUsers called for airdropping Aurora users",params:{accounts:"the account address",amounts:"in AURORA tokens",batchAmount:"equals to the sum of amounts WARNING: rewards are not claimed during stake. Airdrop script must claim or only distribute to accounts without stake"}},"startEndScheduleIndex(uint256,uint256,uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"},{internalType:"uint256",name:"start",type:"uint256"},{internalType:"uint256",name:"end",type:"uint256"}],name:"startEndScheduleIndex",outputs:[{internalType:"uint256",name:"startIndex",type:"uint256"},{internalType:"uint256",name:"endIndex",type:"uint256"}],stateMutability:"view",type:"function",details:"gets start index and end index in a stream schedule",params:{end:"end time (in seconds)",start:"start time (in seconds)",streamId:"stream index"}},"storageVar()":{inputs:[],name:"storageVar",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"supportsInterface(bytes4)":{inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"See {IERC165-supportsInterface}."},"totalAmountOfStakedAurora()":{inputs:[],name:"totalAmountOfStakedAurora",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"totalAuroraShares()":{inputs:[],name:"totalAuroraShares",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"totalStreamShares()":{inputs:[],name:"totalStreamShares",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"touchedAt()":{inputs:[],name:"touchedAt",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"treasury()":{inputs:[],name:"treasury",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"unstake(uint256)":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"}],name:"unstake",outputs:[],stateMutability:"nonpayable",type:"function",details:"unstake amount from user shares value. The rest is re-staked",params:{amount:"to unstake"}},"unstakeAll()":{inputs:[],name:"unstakeAll",outputs:[],stateMutability:"nonpayable",type:"function",details:"unstake all the user's shares"},"updateStorageVar(uint256)":{inputs:[{internalType:"uint256",name:"newVal",type:"uint256"}],name:"updateStorageVar",outputs:[],stateMutability:"nonpayable",type:"function"},"updateTreasury(address)":{inputs:[{internalType:"address",name:"_treasury",type:"address"}],name:"updateTreasury",outputs:[],stateMutability:"nonpayable",type:"function",details:"restricted for the admin only. Admin should pause this contract before changing the treasury address by setting the pause =1 (for changing this variable, call adminPause(1))",params:{_treasury:"treasury contract address for the reward tokens"},notice:"updates treasury account"},"upgradeTo(address)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"}],name:"upgradeTo",outputs:[],stateMutability:"nonpayable",type:"function",details:"Upgrade the implementation of the proxy to `newImplementation`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."},"upgradeToAndCall(address,bytes)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"},{internalType:"bytes",name:"data",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable",type:"function",details:"Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call encoded in `data`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."},"users(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"users",outputs:[{internalType:"uint256",name:"deposit",type:"uint256"},{internalType:"uint256",name:"auroraShares",type:"uint256"},{internalType:"uint256",name:"streamShares",type:"uint256"}],stateMutability:"view",type:"function"},"withdraw(uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"}],name:"withdraw",outputs:[],stateMutability:"nonpayable",type:"function",details:"withdraw amount in the pending pool. User should wait for pending time (tau constant) in order to be able to withdraw.",params:{streamId:"stream index"}},"withdrawAll()":{inputs:[],name:"withdrawAll",outputs:[],stateMutability:"nonpayable",type:"function",details:"withdraw all claimed balances which have passed pending periode. This function will reach gas limit with too many streams, so the frontend will allow individual stream withdrawals and disable withdrawAll."}}},"contracts/testing/upgrades/JetStakingV1/JetStakingV1ExtraFunctionality.sol:JetStakingV1ExtraFunctionality":{source:"contracts/testing/upgrades/JetStakingV1/JetStakingV1ExtraFunctionality.sol",name:"JetStakingV1ExtraFunctionality",events:{"AdminChanged(address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"previousAdmin",type:"address"},{indexed:!1,internalType:"address",name:"newAdmin",type:"address"}],name:"AdminChanged",type:"event"},"BeaconUpgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"beacon",type:"address"}],name:"BeaconUpgraded",type:"event"},"Pending(uint256,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"streamId",type:"uint256"},{indexed:!0,internalType:"address",name:"user",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"}],name:"Pending",type:"event"},"Released(uint256,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"streamId",type:"uint256"},{indexed:!0,internalType:"address",name:"user",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"}],name:"Released",type:"event"},"RoleAdminChanged(bytes32,bytes32,bytes32)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"previousAdminRole",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"newAdminRole",type:"bytes32"}],name:"RoleAdminChanged",type:"event"},"RoleGranted(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleGranted",type:"event"},"RoleRevoked(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleRevoked",type:"event"},"Staked(address,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"user",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"},{indexed:!1,internalType:"uint256",name:"shares",type:"uint256"}],name:"Staked",type:"event"},"StreamCreated(uint256,address,address,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"streamId",type:"uint256"},{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"token",type:"address"},{indexed:!1,internalType:"uint256",name:"tokenAmount",type:"uint256"},{indexed:!1,internalType:"uint256",name:"auroraAmount",type:"uint256"}],name:"StreamCreated",type:"event"},"StreamOwnerRewardReleased(uint256,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"streamId",type:"uint256"},{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"}],name:"StreamOwnerRewardReleased",type:"event"},"StreamProposalCancelled(uint256,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"streamId",type:"uint256"},{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"token",type:"address"}],name:"StreamProposalCancelled",type:"event"},"StreamProposed(uint256,address,address,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"streamId",type:"uint256"},{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"token",type:"address"},{indexed:!1,internalType:"uint256",name:"maxDepositAmount",type:"uint256"},{indexed:!1,internalType:"uint256",name:"auroraDepositAmount",type:"uint256"}],name:"StreamProposed",type:"event"},"StreamRemoved(uint256,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"streamId",type:"uint256"},{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"token",type:"address"}],name:"StreamRemoved",type:"event"},"Unstaked(address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"user",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"}],name:"Unstaked",type:"event"},"Upgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"implementation",type:"address"}],name:"Upgraded",type:"event"}},methods:{"AIRDROP_ROLE()":{inputs:[],name:"AIRDROP_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"CLAIM_ROLE()":{inputs:[],name:"CLAIM_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"DEFAULT_ADMIN_ROLE()":{inputs:[],name:"DEFAULT_ADMIN_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"FOUR_YEARS()":{inputs:[],name:"FOUR_YEARS",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"ONE_MONTH()":{inputs:[],name:"ONE_MONTH",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"PAUSE_ROLE()":{inputs:[],name:"PAUSE_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"STREAM_MANAGER_ROLE()":{inputs:[],name:"STREAM_MANAGER_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"adminDelegatecall(address,bytes)":{inputs:[{internalType:"address",name:"target",type:"address"},{internalType:"bytes",name:"data",type:"bytes"}],name:"adminDelegatecall",outputs:[{internalType:"bytes",name:"",type:"bytes"}],stateMutability:"payable",type:"function","custom:oz-upgrades-unsafe-allow":"delegatecall",details:"adminDelegatecall allows this contract to delegate calls to a target contract and execute it in the context of this contract. Only default admin role can call this function.",params:{data:"is the ABI encoded function signature and its values.",target:"the target contract address"}},"adminPause(uint256)":{inputs:[{internalType:"uint256",name:"flags",type:"uint256"}],name:"adminPause",outputs:[],stateMutability:"nonpayable",type:"function",details:"adminPause pauses this contract. Only pause role or default admin role can access this function.",params:{flags:"flags variable is used for pausing this contract."}},"adminSstore(uint256,uint256)":{inputs:[{internalType:"uint256",name:"key",type:"uint256"},{internalType:"uint256",name:"value",type:"uint256"}],name:"adminSstore",outputs:[],stateMutability:"nonpayable",type:"function",details:"adminSstore updates the state variable value. only default admin role can call this function.",params:{key:"is the storage slot of the state variable",value:"is the state variable value"}},"adminSstoreWithMask(uint256,uint256,uint256)":{inputs:[{internalType:"uint256",name:"key",type:"uint256"},{internalType:"uint256",name:"value",type:"uint256"},{internalType:"uint256",name:"mask",type:"uint256"}],name:"adminSstoreWithMask",outputs:[],stateMutability:"nonpayable",type:"function",details:"adminSstoreWithMask similar to adminSstore except it updates the state variable value after xor-ing this value with the old value and the mask, so the new value should be a result of xor(and(xor(value, oldval), mask), oldval). Only default admin role can call this function.",params:{key:"is the storage slot of the state variable",mask:"this value is used in calculating the new value",value:"is the state variable value"}},"auroraToken()":{inputs:[],name:"auroraToken",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"batchClaimOnBehalfOfAnotherUser(address,uint256[])":{inputs:[{internalType:"address",name:"account",type:"address"},{internalType:"uint256[]",name:"streamIds",type:"uint256[]"}],name:"batchClaimOnBehalfOfAnotherUser",outputs:[],stateMutability:"nonpayable",type:"function",details:"batchClaimOnBehalfOfAnotherUser when gas limits prevent users from claiming all.",params:{account:"the user account address.",streamIds:"to claim."}},"batchClaimOnBehalfOfOtherUsers(address[],uint256[])":{inputs:[{internalType:"address[]",name:"accounts",type:"address[]"},{internalType:"uint256[]",name:"streamIds",type:"uint256[]"}],name:"batchClaimOnBehalfOfOtherUsers",outputs:[],stateMutability:"nonpayable",type:"function",details:"Claim all stream rewards on behalf of other users.",params:{accounts:"the user account addresses."}},"batchMoveRewardsToPending(uint256[])":{inputs:[{internalType:"uint256[]",name:"streamIds",type:"uint256[]"}],name:"batchMoveRewardsToPending",outputs:[],stateMutability:"nonpayable",type:"function",details:"moves a set of stream Id rewards to pending. Allows user to select stream ids to claim from UI.",params:{streamIds:"stream indexes"}},"batchWithdraw(uint256[])":{inputs:[{internalType:"uint256[]",name:"streamIds",type:"uint256[]"}],name:"batchWithdraw",outputs:[],stateMutability:"nonpayable",type:"function",details:"withdraw a set of stream Ids. Allows user to select stream ids to withdraw from UI.",params:{streamIds:"to withdraw."}},"before(uint256,uint256)":{inputs:[{internalType:"uint256",name:"startTime",type:"uint256"},{internalType:"uint256",name:"endTime",type:"uint256"}],name:"before",outputs:[{internalType:"uint256",name:"total",type:"uint256"},{internalType:"uint256",name:"rewardPerShareAurora",type:"uint256"},{internalType:"uint256",name:"scheduleCalculated",type:"uint256"}],stateMutability:"view",type:"function"},"c_0x7e37e874(bytes32)":{inputs:[{internalType:"bytes32",name:"c__0x7e37e874",type:"bytes32"}],name:"c_0x7e37e874",outputs:[],stateMutability:"pure",type:"function"},"c_0xc1dd3536(bytes32)":{inputs:[{internalType:"bytes32",name:"c__0xc1dd3536",type:"bytes32"}],name:"c_0xc1dd3536",outputs:[],stateMutability:"pure",type:"function"},"c_0xca661c5e(bytes32)":{inputs:[{internalType:"bytes32",name:"c__0xca661c5e",type:"bytes32"}],name:"c_0xca661c5e",outputs:[],stateMutability:"pure",type:"function"},"c_0xdf09e261(bytes32)":{inputs:[{internalType:"bytes32",name:"c__0xdf09e261",type:"bytes32"}],name:"c_0xdf09e261",outputs:[],stateMutability:"pure",type:"function"},"calculateWeightedShares(uint256,uint256)":{inputs:[{internalType:"uint256",name:"shares",type:"uint256"},{internalType:"uint256",name:"timestamp",type:"uint256"}],name:"calculateWeightedShares",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"callBeforeTwice()":{inputs:[],name:"callBeforeTwice",outputs:[],stateMutability:"nonpayable",type:"function"},"cancelStreamProposal(uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"}],name:"cancelStreamProposal",outputs:[],stateMutability:"nonpayable",type:"function",details:"cancelStreamProposal cancels a proposal any time before the stream becomes active (created).",params:{streamId:"the stream index"}},"claimAllOnBehalfOfAnotherUser(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"claimAllOnBehalfOfAnotherUser",outputs:[],stateMutability:"nonpayable",type:"function",details:"Claim all stream rewards on behalf of another user.",params:{account:"the user account address."}},"claimAllOnBehalfOfOtherUsers(address[])":{inputs:[{internalType:"address[]",name:"accounts",type:"address[]"}],name:"claimAllOnBehalfOfOtherUsers",outputs:[],stateMutability:"nonpayable",type:"function",details:"Claim all stream rewards on behalf of other users.",params:{accounts:"the user account addresses."}},"claimOnBehalfOfAnotherUser(address,uint256)":{inputs:[{internalType:"address",name:"account",type:"address"},{internalType:"uint256",name:"streamId",type:"uint256"}],name:"claimOnBehalfOfAnotherUser",outputs:[],stateMutability:"nonpayable",type:"function",details:"Claim a stream's rewards on behalf of another user.",params:{account:"the user account address.",streamId:"to claim."}},"createStream(uint256,uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"},{internalType:"uint256",name:"rewardTokenAmount",type:"uint256"}],name:"createStream",outputs:[],stateMutability:"nonpayable",type:"function",details:"create new stream (only stream owner) stream owner must approve reward tokens to this contract.",params:{streamId:"stream id"}},"dummy()":{inputs:[],name:"dummy",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"getAmountOfShares(uint256,address)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"},{internalType:"address",name:"account",type:"address"}],name:"getAmountOfShares",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"gets a user stream shares",params:{account:"the user address",streamId:"stream index"},returns:{_0:"user stream shares"}},"getLatestRewardPerShare(uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"}],name:"getLatestRewardPerShare",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"calculates and gets the latest reward per share (RPS) for a stream",params:{streamId:"stream index"},returns:{_0:"streams[streamId].rps + scheduled reward up till now"}},"getPending(uint256,address)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"},{internalType:"address",name:"account",type:"address"}],name:"getPending",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"gets the user's stream pending reward",params:{account:"user account",streamId:"stream index"},returns:{_0:"user.pendings[streamId]"}},"getReleaseTime(uint256,address)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"},{internalType:"address",name:"account",type:"address"}],name:"getReleaseTime",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"gets the user's stream reward release time",params:{account:"user account",streamId:"stream index"},returns:{_0:"user.releaseTime[streamId]"}},"getRewardPerShare(uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"}],name:"getRewardPerShare",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"gets reward per share (RPS) for a stream",params:{streamId:"stream index"},returns:{_0:"streams[streamId].rps"}},"getRewardPerShareForUser(uint256,address)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"},{internalType:"address",name:"account",type:"address"}],name:"getRewardPerShareForUser",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"gets the user's reward per share (RPS) for a stream",params:{streamId:"stream index"},returns:{_0:"user.rpsDuringLastClaim[streamId]"}},"getRewardsAmount(uint256,uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"},{internalType:"uint256",name:"lastUpdate",type:"uint256"}],name:"getRewardsAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"calculates and gets the latest released rewards.",params:{streamId:"stream index"},returns:{_0:"rewards released since last update."}},"getRoleAdmin(bytes32)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"}],name:"getRoleAdmin",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}."},"getStream(uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"}],name:"getStream",outputs:[{internalType:"address",name:"streamOwner",type:"address"},{internalType:"address",name:"rewardToken",type:"address"},{internalType:"uint256",name:"auroraDepositAmount",type:"uint256"},{internalType:"uint256",name:"auroraClaimedAmount",type:"uint256"},{internalType:"uint256",name:"rewardDepositAmount",type:"uint256"},{internalType:"uint256",name:"rewardClaimedAmount",type:"uint256"},{internalType:"uint256",name:"maxDepositAmount",type:"uint256"},{internalType:"uint256",name:"lastTimeOwnerClaimed",type:"uint256"},{internalType:"uint256",name:"rps",type:"uint256"},{internalType:"uint256",name:"tau",type:"uint256"},{internalType:"enum JetStakingV1.StreamStatus",name:"status",type:"uint8"}],stateMutability:"view",type:"function",details:"get the stream data",params:{streamId:"the stream index"},notice:"this function doesn't return the stream schedule due to some stake slots limitations. To get the stream schedule, refer to getStreamSchedule"},"getStreamClaimableAmount(uint256,address)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"},{internalType:"address",name:"account",type:"address"}],name:"getStreamClaimableAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"gets the user's stream claimable amount",params:{streamId:"stream index"},returns:{_0:"(latesRPS - user.rpsDuringLastClaim) * user.shares"}},"getStreamOwnerClaimableAmount(uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"}],name:"getStreamOwnerClaimableAmount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Stream owner claimable AURORA.",params:{streamId:"the stream index"}},"getStreamSchedule(uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"}],name:"getStreamSchedule",outputs:[{internalType:"uint256[]",name:"scheduleTimes",type:"uint256[]"},{internalType:"uint256[]",name:"scheduleRewards",type:"uint256[]"}],stateMutability:"view",type:"function",details:"get the stream schedule data",params:{streamId:"the stream index"}},"getStreamsCount()":{inputs:[],name:"getStreamsCount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"get the streams count",returns:{_0:"streams.length"}},"getTotalAmountOfStakedAurora()":{inputs:[],name:"getTotalAmountOfStakedAurora",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"gets the total amount of staked aurora",returns:{_0:"totalAmountOfStakedAurora + latest reward schedule"}},"getTreasuryBalance(address)":{inputs:[{internalType:"address",name:"token",type:"address"}],name:"getTreasuryBalance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Get the treasury balance",params:{token:"the token address"}},"getUserShares(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"getUserShares",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"gets the user shares",params:{account:"the user address"},returns:{_0:"user shares"}},"getUserTotalDeposit(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"getUserTotalDeposit",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"gets the total user deposit",params:{account:"the user address"},returns:{_0:"user total deposit in (AURORA)"}},"grantRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"grantRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role."},"hasRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"hasRole",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns `true` if `account` has been granted `role`."},"initialize(address,address,uint256[],uint256[],uint256,uint256,address,uint256,uint256)":{inputs:[{internalType:"address",name:"aurora",type:"address"},{internalType:"address",name:"streamOwner",type:"address"},{internalType:"uint256[]",name:"scheduleTimes",type:"uint256[]"},{internalType:"uint256[]",name:"scheduleRewards",type:"uint256[]"},{internalType:"uint256",name:"tauAuroraStream",type:"uint256"},{internalType:"uint256",name:"_flags",type:"uint256"},{internalType:"address",name:"_treasury",type:"address"},{internalType:"uint256",name:"_maxWeight",type:"uint256"},{internalType:"uint256",name:"_minWeight",type:"uint256"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function",details:"initialize the contract and deploys the first stream (AURORA)",params:{_flags:"admin controlled contract flags",_maxWeight:"max stream reward weighting coefficient",_minWeight:"min stream reward weighting coefficient",_treasury:"the Aurora treasury contract address",aurora:"token contract address",scheduleRewards:"init the schedule amounts",scheduleTimes:"init the schedule time",tauAuroraStream:"release time constant per stream (e.g AURORA stream)"},notice:"By calling this function, the deployer of this contract must make sure that the AURORA reward amount was deposited to the treasury contract before initializing of the default AURORA stream."},"maxWeight()":{inputs:[],name:"maxWeight",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"minWeight()":{inputs:[],name:"minWeight",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"moveAllRewardsToPending()":{inputs:[],name:"moveAllRewardsToPending",outputs:[],stateMutability:"nonpayable",type:"function",details:"moves all the user rewards to pending reward."},"moveRewardsToPending(uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"}],name:"moveRewardsToPending",outputs:[],stateMutability:"nonpayable",type:"function",details:"moves the reward for specific stream Id to pending rewards. It will require a waiting time untill it get released. Users call this in function in order to claim rewards.",params:{streamId:"stream index"}},"paused()":{inputs:[],name:"paused",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"proposeStream(address,address,uint256,uint256,uint256,uint256[],uint256[],uint256)":{inputs:[{internalType:"address",name:"streamOwner",type:"address"},{internalType:"address",name:"rewardToken",type:"address"},{internalType:"uint256",name:"auroraDepositAmount",type:"uint256"},{internalType:"uint256",name:"maxDepositAmount",type:"uint256"},{internalType:"uint256",name:"minDepositAmount",type:"uint256"},{internalType:"uint256[]",name:"scheduleTimes",type:"uint256[]"},{internalType:"uint256[]",name:"scheduleRewards",type:"uint256[]"},{internalType:"uint256",name:"tau",type:"uint256"}],name:"proposeStream",outputs:[],stateMutability:"nonpayable",type:"function",details:"An admin of the staking contract can whitelist (propose) a stream. Whitelisting of the stream provides the option for the stream owner (presumably the issuing party of a specific token) to deposit some ERC-20 tokens on the staking contract and potentially get in return some AURORA tokens. Deposited ERC-20 tokens will be distributed to the stakers over some period of time.",params:{auroraDepositAmount:"Amount of the AURORA deposited by the Admin.",maxDepositAmount:"The upper amount of the tokens that should be deposited by the stream owner",rewardToken:"the address of the ERC-20 tokens to be deposited in the stream",scheduleRewards:"remaining rewards to be delivered at the beginning of each scheduled interval. Last element is always zero. First value (in scheduleRewards) from array is supposed to be a total amount of rewards for stream.",scheduleTimes:"timestamp denoting the start of each scheduled interval. Last element is the end of the stream.",streamOwner:"only this account would be able to create a stream",tau:"the tau is (pending release period) for this stream (e.g one day)"},notice:"treasury manager must call"},"releaseAuroraRewardsToStreamOwner(uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"}],name:"releaseAuroraRewardsToStreamOwner",outputs:[],stateMutability:"nonpayable",type:"function",details:"the release of AURORA tokens to the stream owner is subjected to the same schedule as rewards. Thus if for a specific moment in time 30% of the rewards are distributed, then it means that 30% of the AURORA deposit can be withdrawn by the stream owner too. called by the stream owner",params:{streamId:"the stream index"}},"removeStream(uint256,address)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"},{internalType:"address",name:"streamFundReceiver",type:"address"}],name:"removeStream",outputs:[],stateMutability:"nonpayable",type:"function",details:"removes a stream (only default admin role)",params:{streamFundReceiver:"receives the rest of the reward tokens in the stream",streamId:"stream index"}},"renounceRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"renounceRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been revoked `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`."},"revokeRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"revokeRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role."},"rewardsSchedule(uint256,uint256,uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"},{internalType:"uint256",name:"start",type:"uint256"},{internalType:"uint256",name:"end",type:"uint256"}],name:"rewardsSchedule",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"calculate the total amount of the released tokens within a period (start & end)",params:{end:"is the end timestamp (e.g block.timestamp .. now)",start:"is the start timestamp within the schedule",streamId:"the stream index"},returns:{_0:"amount of the released tokens for that period"}},"stake(uint256)":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"}],name:"stake",outputs:[],stateMutability:"nonpayable",type:"function",details:"a user stakes amount of AURORA tokens The user should approve these tokens to the treasury contract in order to complete the stake.",params:{amount:"is the AURORA amount."}},"stakeOnBehalfOfAnotherUser(address,uint256)":{inputs:[{internalType:"address",name:"account",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"stakeOnBehalfOfAnotherUser",outputs:[],stateMutability:"nonpayable",type:"function",details:"stakeOnBehalfOfAnotherUser is called for airdropping Aurora users",params:{account:"the account address",amount:"in AURORA tokens WARNING: rewards are not claimed during stake. Airdrop script must claim or only distribute to accounts without stake"}},"stakeOnBehalfOfOtherUsers(address[],uint256[],uint256)":{inputs:[{internalType:"address[]",name:"accounts",type:"address[]"},{internalType:"uint256[]",name:"amounts",type:"uint256[]"},{internalType:"uint256",name:"batchAmount",type:"uint256"}],name:"stakeOnBehalfOfOtherUsers",outputs:[],stateMutability:"nonpayable",type:"function",details:"stakeOnBehalfOfOtherUsers called for airdropping Aurora users",params:{accounts:"the account address",amounts:"in AURORA tokens",batchAmount:"equals to the sum of amounts WARNING: rewards are not claimed during stake. Airdrop script must claim or only distribute to accounts without stake"}},"startEndScheduleIndex(uint256,uint256,uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"},{internalType:"uint256",name:"start",type:"uint256"},{internalType:"uint256",name:"end",type:"uint256"}],name:"startEndScheduleIndex",outputs:[{internalType:"uint256",name:"startIndex",type:"uint256"},{internalType:"uint256",name:"endIndex",type:"uint256"}],stateMutability:"view",type:"function",details:"gets start index and end index in a stream schedule",params:{end:"end time (in seconds)",start:"start time (in seconds)",streamId:"stream index"}},"supportsInterface(bytes4)":{inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"See {IERC165-supportsInterface}."},"tempMoveRewardsToPending(address,uint256)":{inputs:[{internalType:"address",name:"account",type:"address"},{internalType:"uint256",name:"streamId",type:"uint256"}],name:"tempMoveRewardsToPending",outputs:[],stateMutability:"nonpayable",type:"function"},"totalAmountOfStakedAurora()":{inputs:[],name:"totalAmountOfStakedAurora",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"totalAuroraShares()":{inputs:[],name:"totalAuroraShares",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"totalStreamShares()":{inputs:[],name:"totalStreamShares",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"touchedAt()":{inputs:[],name:"touchedAt",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"treasury()":{inputs:[],name:"treasury",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"unstake(uint256)":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"}],name:"unstake",outputs:[],stateMutability:"nonpayable",type:"function",details:"unstake amount from user shares value. The rest is re-staked",params:{amount:"to unstake"}},"unstakeAll()":{inputs:[],name:"unstakeAll",outputs:[],stateMutability:"nonpayable",type:"function",details:"unstake all the user's shares"},"unstakeAllOnBehalfOfOthers(address[])":{inputs:[{internalType:"address[]",name:"accounts",type:"address[]"}],name:"unstakeAllOnBehalfOfOthers",outputs:[],stateMutability:"nonpayable",type:"function"},"updateTreasury(address)":{inputs:[{internalType:"address",name:"_treasury",type:"address"}],name:"updateTreasury",outputs:[],stateMutability:"nonpayable",type:"function",details:"restricted for the admin only. Admin should pause this contract before changing the treasury address by setting the pause =1 (for changing this variable, call adminPause(1))",params:{_treasury:"treasury contract address for the reward tokens"},notice:"updates treasury account"},"updateUserCalculation()":{inputs:[],name:"updateUserCalculation",outputs:[],stateMutability:"nonpayable",type:"function"},"upgradeTo(address)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"}],name:"upgradeTo",outputs:[],stateMutability:"nonpayable",type:"function",details:"Upgrade the implementation of the proxy to `newImplementation`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."},"upgradeToAndCall(address,bytes)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"},{internalType:"bytes",name:"data",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable",type:"function",details:"Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call encoded in `data`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."},"users(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"users",outputs:[{internalType:"uint256",name:"deposit",type:"uint256"},{internalType:"uint256",name:"auroraShares",type:"uint256"},{internalType:"uint256",name:"streamShares",type:"uint256"}],stateMutability:"view",type:"function"},"withdraw(uint256)":{inputs:[{internalType:"uint256",name:"streamId",type:"uint256"}],name:"withdraw",outputs:[],stateMutability:"nonpayable",type:"function",details:"withdraw amount in the pending pool. User should wait for pending time (tau constant) in order to be able to withdraw.",params:{streamId:"stream index"}},"withdrawAll()":{inputs:[],name:"withdrawAll",outputs:[],stateMutability:"nonpayable",type:"function",details:"withdraw all claimed balances which have passed pending periode. This function will reach gas limit with too many streams, so the frontend will allow individual stream withdrawals and disable withdrawAll."}}},"contracts/testing/upgrades/Treasury/TreasuryChangeFunctionSignature.sol:TreasuryChangeFunctionSignature":{source:"contracts/testing/upgrades/Treasury/TreasuryChangeFunctionSignature.sol",name:"TreasuryChangeFunctionSignature",events:{"AdminChanged(address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"previousAdmin",type:"address"},{indexed:!1,internalType:"address",name:"newAdmin",type:"address"}],name:"AdminChanged",type:"event"},"BeaconUpgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"beacon",type:"address"}],name:"BeaconUpgraded",type:"event"},"RoleAdminChanged(bytes32,bytes32,bytes32)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"previousAdminRole",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"newAdminRole",type:"bytes32"}],name:"RoleAdminChanged",type:"event"},"RoleGranted(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleGranted",type:"event"},"RoleRevoked(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleRevoked",type:"event"},"TokenAdded(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"token",type:"address"},{indexed:!0,internalType:"address",name:"addedBy",type:"address"},{indexed:!1,internalType:"uint256",name:"timestamp",type:"uint256"}],name:"TokenAdded",type:"event"},"TokenRemoved(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"token",type:"address"},{indexed:!0,internalType:"address",name:"addedBy",type:"address"},{indexed:!1,internalType:"uint256",name:"timestamp",type:"uint256"}],name:"TokenRemoved",type:"event"},"Upgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"implementation",type:"address"}],name:"Upgraded",type:"event"}},methods:{"DEFAULT_ADMIN_ROLE()":{inputs:[],name:"DEFAULT_ADMIN_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"PAUSE_ROLE()":{inputs:[],name:"PAUSE_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"TREASURY_MANAGER_ROLE()":{inputs:[],name:"TREASURY_MANAGER_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"addSupportedToken(address)":{inputs:[{internalType:"address",name:"_token",type:"address"}],name:"addSupportedToken",outputs:[],stateMutability:"nonpayable",type:"function",params:{_token:"stream ERC20 token address"},notice:"adds token as a supproted rewards token by Treasury supported tokens means any future stream token should be whitelisted here"},"addSupportedToken(address,bool)":{inputs:[{internalType:"address",name:"_token",type:"address"},{internalType:"bool",name:"isSupported",type:"bool"}],name:"addSupportedToken",outputs:[],stateMutability:"nonpayable",type:"function"},"adminDelegatecall(address,bytes)":{inputs:[{internalType:"address",name:"target",type:"address"},{internalType:"bytes",name:"data",type:"bytes"}],name:"adminDelegatecall",outputs:[{internalType:"bytes",name:"",type:"bytes"}],stateMutability:"payable",type:"function","custom:oz-upgrades-unsafe-allow":"delegatecall",details:"adminDelegatecall allows this contract to delegate calls to a target contract and execute it in the context of this contract. Only default admin role can call this function.",params:{data:"is the ABI encoded function signature and its values.",target:"the target contract address"}},"adminPause(uint256)":{inputs:[{internalType:"uint256",name:"flags",type:"uint256"}],name:"adminPause",outputs:[],stateMutability:"nonpayable",type:"function",details:"adminPause pauses this contract. Only pause role or default admin role can access this function.",params:{flags:"flags variable is used for pausing this contract."}},"adminSstore(uint256,uint256)":{inputs:[{internalType:"uint256",name:"key",type:"uint256"},{internalType:"uint256",name:"value",type:"uint256"}],name:"adminSstore",outputs:[],stateMutability:"nonpayable",type:"function",details:"adminSstore updates the state variable value. only default admin role can call this function.",params:{key:"is the storage slot of the state variable",value:"is the state variable value"}},"adminSstoreWithMask(uint256,uint256,uint256)":{inputs:[{internalType:"uint256",name:"key",type:"uint256"},{internalType:"uint256",name:"value",type:"uint256"},{internalType:"uint256",name:"mask",type:"uint256"}],name:"adminSstoreWithMask",outputs:[],stateMutability:"nonpayable",type:"function",details:"adminSstoreWithMask similar to adminSstore except it updates the state variable value after xor-ing this value with the old value and the mask, so the new value should be a result of xor(and(xor(value, oldval), mask), oldval). Only default admin role can call this function.",params:{key:"is the storage slot of the state variable",mask:"this value is used in calculating the new value",value:"is the state variable value"}},"c_0x47b6ea16(bytes32)":{inputs:[{internalType:"bytes32",name:"c__0x47b6ea16",type:"bytes32"}],name:"c_0x47b6ea16",outputs:[],stateMutability:"pure",type:"function"},"c_0x4aa68770(bytes32)":{inputs:[{internalType:"bytes32",name:"c__0x4aa68770",type:"bytes32"}],name:"c_0x4aa68770",outputs:[],stateMutability:"pure",type:"function"},"c_0x7e37e874(bytes32)":{inputs:[{internalType:"bytes32",name:"c__0x7e37e874",type:"bytes32"}],name:"c_0x7e37e874",outputs:[],stateMutability:"pure",type:"function"},"getRoleAdmin(bytes32)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"}],name:"getRoleAdmin",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}."},"grantRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"grantRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role."},"hasRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"hasRole",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns `true` if `account` has been granted `role`."},"initialize(address[],uint256)":{inputs:[{internalType:"address[]",name:"_supportedTokens",type:"address[]"},{internalType:"uint256",name:"_flags",type:"uint256"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function",params:{_supportedTokens:"list of supported tokens"},notice:"initializes ownable Treasury with list of managers and supported tokens"},"isSupportedToken(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"isSupportedToken",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"paused()":{inputs:[],name:"paused",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"payRewards(address,address,uint256)":{inputs:[{internalType:"address",name:"_user",type:"address"},{internalType:"address",name:"_token",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"}],name:"payRewards",outputs:[],stateMutability:"nonpayable",type:"function",details:"Used by jet staking contracts",params:{_amount:"token to transfer to user",_token:"token to transfer to user",_user:"user to transfer tokens to"},notice:"transfers token amount from Treasury balance to user."},"removeSupportedToken(address)":{inputs:[{internalType:"address",name:"_token",type:"address"}],name:"removeSupportedToken",outputs:[],stateMutability:"nonpayable",type:"function",params:{_token:"stream ERC20 token address"},notice:"removed token as a supproted rewards token by Treasury"},"renounceRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"renounceRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been revoked `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`."},"revokeRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"revokeRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role."},"supportsInterface(bytes4)":{inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"See {IERC165-supportsInterface}."},"upgradeTo(address)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"}],name:"upgradeTo",outputs:[],stateMutability:"nonpayable",type:"function",details:"Upgrade the implementation of the proxy to `newImplementation`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."},"upgradeToAndCall(address,bytes)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"},{internalType:"bytes",name:"data",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable",type:"function",details:"Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call encoded in `data`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."}}},"contracts/testing/upgrades/Treasury/TreasuryChangeInStorage.sol:TreasuryChangeInStorage":{source:"contracts/testing/upgrades/Treasury/TreasuryChangeInStorage.sol",name:"TreasuryChangeInStorage",events:{"AdminChanged(address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"previousAdmin",type:"address"},{indexed:!1,internalType:"address",name:"newAdmin",type:"address"}],name:"AdminChanged",type:"event"},"BeaconUpgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"beacon",type:"address"}],name:"BeaconUpgraded",type:"event"},"RoleAdminChanged(bytes32,bytes32,bytes32)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"previousAdminRole",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"newAdminRole",type:"bytes32"}],name:"RoleAdminChanged",type:"event"},"RoleGranted(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleGranted",type:"event"},"RoleRevoked(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleRevoked",type:"event"},"TokenAdded(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"token",type:"address"},{indexed:!0,internalType:"address",name:"addedBy",type:"address"},{indexed:!1,internalType:"uint256",name:"timestamp",type:"uint256"}],name:"TokenAdded",type:"event"},"TokenRemoved(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"token",type:"address"},{indexed:!0,internalType:"address",name:"addedBy",type:"address"},{indexed:!1,internalType:"uint256",name:"timestamp",type:"uint256"}],name:"TokenRemoved",type:"event"},"Upgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"implementation",type:"address"}],name:"Upgraded",type:"event"}},methods:{"DEFAULT_ADMIN_ROLE()":{inputs:[],name:"DEFAULT_ADMIN_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"PAUSE_ROLE()":{inputs:[],name:"PAUSE_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"TREASURY_MANAGER_ROLE()":{inputs:[],name:"TREASURY_MANAGER_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"addSupportedToken(address)":{inputs:[{internalType:"address",name:"_token",type:"address"}],name:"addSupportedToken",outputs:[],stateMutability:"nonpayable",type:"function",params:{_token:"stream ERC20 token address"},notice:"adds token as a supproted rewards token by Treasury supported tokens means any future stream token should be whitelisted here"},"adminDelegatecall(address,bytes)":{inputs:[{internalType:"address",name:"target",type:"address"},{internalType:"bytes",name:"data",type:"bytes"}],name:"adminDelegatecall",outputs:[{internalType:"bytes",name:"",type:"bytes"}],stateMutability:"payable",type:"function","custom:oz-upgrades-unsafe-allow":"delegatecall",details:"adminDelegatecall allows this contract to delegate calls to a target contract and execute it in the context of this contract. Only default admin role can call this function.",params:{data:"is the ABI encoded function signature and its values.",target:"the target contract address"}},"adminPause(uint256)":{inputs:[{internalType:"uint256",name:"flags",type:"uint256"}],name:"adminPause",outputs:[],stateMutability:"nonpayable",type:"function",details:"adminPause pauses this contract. Only pause role or default admin role can access this function.",params:{flags:"flags variable is used for pausing this contract."}},"adminSstore(uint256,uint256)":{inputs:[{internalType:"uint256",name:"key",type:"uint256"},{internalType:"uint256",name:"value",type:"uint256"}],name:"adminSstore",outputs:[],stateMutability:"nonpayable",type:"function",details:"adminSstore updates the state variable value. only default admin role can call this function.",params:{key:"is the storage slot of the state variable",value:"is the state variable value"}},"adminSstoreWithMask(uint256,uint256,uint256)":{inputs:[{internalType:"uint256",name:"key",type:"uint256"},{internalType:"uint256",name:"value",type:"uint256"},{internalType:"uint256",name:"mask",type:"uint256"}],name:"adminSstoreWithMask",outputs:[],stateMutability:"nonpayable",type:"function",details:"adminSstoreWithMask similar to adminSstore except it updates the state variable value after xor-ing this value with the old value and the mask, so the new value should be a result of xor(and(xor(value, oldval), mask), oldval). Only default admin role can call this function.",params:{key:"is the storage slot of the state variable",mask:"this value is used in calculating the new value",value:"is the state variable value"}},"c_0x47b6ea16(bytes32)":{inputs:[{internalType:"bytes32",name:"c__0x47b6ea16",type:"bytes32"}],name:"c_0x47b6ea16",outputs:[],stateMutability:"pure",type:"function"},"c_0x7e37e874(bytes32)":{inputs:[{internalType:"bytes32",name:"c__0x7e37e874",type:"bytes32"}],name:"c_0x7e37e874",outputs:[],stateMutability:"pure",type:"function"},"c_0xe875bcda(bytes32)":{inputs:[{internalType:"bytes32",name:"c__0xe875bcda",type:"bytes32"}],name:"c_0xe875bcda",outputs:[],stateMutability:"pure",type:"function"},"getRoleAdmin(bytes32)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"}],name:"getRoleAdmin",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}."},"grantRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"grantRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role."},"hasRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"hasRole",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns `true` if `account` has been granted `role`."},"initialize(address[],uint256)":{inputs:[{internalType:"address[]",name:"_supportedTokens",type:"address[]"},{internalType:"uint256",name:"_flags",type:"uint256"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function",params:{_supportedTokens:"list of supported tokens"},notice:"initializes ownable Treasury with list of managers and supported tokens"},"isSupportedToken(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"isSupportedToken",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"newTreasury()":{inputs:[],name:"newTreasury",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"paused()":{inputs:[],name:"paused",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"payRewards(address,address,uint256)":{inputs:[{internalType:"address",name:"_user",type:"address"},{internalType:"address",name:"_token",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"}],name:"payRewards",outputs:[],stateMutability:"nonpayable",type:"function",details:"Used by jet staking contracts",params:{_amount:"token to transfer to user",_token:"token to transfer to user",_user:"user to transfer tokens to"},notice:"transfers token amount from Treasury balance to user."},"removeSupportedToken(address)":{inputs:[{internalType:"address",name:"_token",type:"address"}],name:"removeSupportedToken",outputs:[],stateMutability:"nonpayable",type:"function",params:{_token:"stream ERC20 token address"},notice:"removed token as a supproted rewards token by Treasury"},"renounceRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"renounceRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been revoked `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`."},"revokeRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"revokeRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role."},"supportsInterface(bytes4)":{inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"See {IERC165-supportsInterface}."},"upgradeTo(address)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"}],name:"upgradeTo",outputs:[],stateMutability:"nonpayable",type:"function",details:"Upgrade the implementation of the proxy to `newImplementation`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."},"upgradeToAndCall(address,bytes)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"},{internalType:"bytes",name:"data",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable",type:"function",details:"Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call encoded in `data`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."}}},"contracts/testing/upgrades/Treasury/TreasuryChangeInStorageAndLogic.sol:TreasuryChangeInStorageAndLogic":{source:"contracts/testing/upgrades/Treasury/TreasuryChangeInStorageAndLogic.sol",name:"TreasuryChangeInStorageAndLogic",events:{"AdminChanged(address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"previousAdmin",type:"address"},{indexed:!1,internalType:"address",name:"newAdmin",type:"address"}],name:"AdminChanged",type:"event"},"BeaconUpgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"beacon",type:"address"}],name:"BeaconUpgraded",type:"event"},"RoleAdminChanged(bytes32,bytes32,bytes32)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"previousAdminRole",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"newAdminRole",type:"bytes32"}],name:"RoleAdminChanged",type:"event"},"RoleGranted(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleGranted",type:"event"},"RoleRevoked(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleRevoked",type:"event"},"TokenAdded(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"token",type:"address"},{indexed:!0,internalType:"address",name:"addedBy",type:"address"},{indexed:!1,internalType:"uint256",name:"timestamp",type:"uint256"}],name:"TokenAdded",type:"event"},"TokenRemoved(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"token",type:"address"},{indexed:!0,internalType:"address",name:"addedBy",type:"address"},{indexed:!1,internalType:"uint256",name:"timestamp",type:"uint256"}],name:"TokenRemoved",type:"event"},"Upgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"implementation",type:"address"}],name:"Upgraded",type:"event"}},methods:{"DEFAULT_ADMIN_ROLE()":{inputs:[],name:"DEFAULT_ADMIN_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"PAUSE_ROLE()":{inputs:[],name:"PAUSE_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"TREASURY_MANAGER_ROLE()":{inputs:[],name:"TREASURY_MANAGER_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"addSupportedToken(address)":{inputs:[{internalType:"address",name:"_token",type:"address"}],name:"addSupportedToken",outputs:[],stateMutability:"nonpayable",type:"function",params:{_token:"stream ERC20 token address"},notice:"adds token as a supproted rewards token by Treasury supported tokens means any future stream token should be whitelisted here"},"adminDelegatecall(address,bytes)":{inputs:[{internalType:"address",name:"target",type:"address"},{internalType:"bytes",name:"data",type:"bytes"}],name:"adminDelegatecall",outputs:[{internalType:"bytes",name:"",type:"bytes"}],stateMutability:"payable",type:"function","custom:oz-upgrades-unsafe-allow":"delegatecall",details:"adminDelegatecall allows this contract to delegate calls to a target contract and execute it in the context of this contract. Only default admin role can call this function.",params:{data:"is the ABI encoded function signature and its values.",target:"the target contract address"}},"adminPause(uint256)":{inputs:[{internalType:"uint256",name:"flags",type:"uint256"}],name:"adminPause",outputs:[],stateMutability:"nonpayable",type:"function",details:"adminPause pauses this contract. Only pause role or default admin role can access this function.",params:{flags:"flags variable is used for pausing this contract."}},"adminSstore(uint256,uint256)":{inputs:[{internalType:"uint256",name:"key",type:"uint256"},{internalType:"uint256",name:"value",type:"uint256"}],name:"adminSstore",outputs:[],stateMutability:"nonpayable",type:"function",details:"adminSstore updates the state variable value. only default admin role can call this function.",params:{key:"is the storage slot of the state variable",value:"is the state variable value"}},"adminSstoreWithMask(uint256,uint256,uint256)":{inputs:[{internalType:"uint256",name:"key",type:"uint256"},{internalType:"uint256",name:"value",type:"uint256"},{internalType:"uint256",name:"mask",type:"uint256"}],name:"adminSstoreWithMask",outputs:[],stateMutability:"nonpayable",type:"function",details:"adminSstoreWithMask similar to adminSstore except it updates the state variable value after xor-ing this value with the old value and the mask, so the new value should be a result of xor(and(xor(value, oldval), mask), oldval). Only default admin role can call this function.",params:{key:"is the storage slot of the state variable",mask:"this value is used in calculating the new value",value:"is the state variable value"}},"c_0x47b6ea16(bytes32)":{inputs:[{internalType:"bytes32",name:"c__0x47b6ea16",type:"bytes32"}],name:"c_0x47b6ea16",outputs:[],stateMutability:"pure",type:"function"},"c_0x7e37e874(bytes32)":{inputs:[{internalType:"bytes32",name:"c__0x7e37e874",type:"bytes32"}],name:"c_0x7e37e874",outputs:[],stateMutability:"pure",type:"function"},"c_0xc7f0f0cb(bytes32)":{inputs:[{internalType:"bytes32",name:"c__0xc7f0f0cb",type:"bytes32"}],name:"c_0xc7f0f0cb",outputs:[],stateMutability:"pure",type:"function"},"getRoleAdmin(bytes32)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"}],name:"getRoleAdmin",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}."},"grantRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"grantRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role."},"hasRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"hasRole",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns `true` if `account` has been granted `role`."},"initialize(address[],uint256)":{inputs:[{internalType:"address[]",name:"_supportedTokens",type:"address[]"},{internalType:"uint256",name:"_flags",type:"uint256"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function",params:{_supportedTokens:"list of supported tokens"},notice:"initializes ownable Treasury with list of managers and supported tokens"},"isSupportedToken(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"isSupportedToken",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"newTreasury()":{inputs:[],name:"newTreasury",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"paused()":{inputs:[],name:"paused",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"payRewards(address,address,uint256)":{inputs:[{internalType:"address",name:"_user",type:"address"},{internalType:"address",name:"_token",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"}],name:"payRewards",outputs:[],stateMutability:"nonpayable",type:"function",details:"Used by jet staking contracts",params:{_amount:"token to transfer to user",_token:"token to transfer to user",_user:"user to transfer tokens to"},notice:"transfers token amount from Treasury balance to user."},"removeSupportedToken(address)":{inputs:[{internalType:"address",name:"_token",type:"address"}],name:"removeSupportedToken",outputs:[],stateMutability:"nonpayable",type:"function",params:{_token:"stream ERC20 token address"},notice:"removed token as a supproted rewards token by Treasury"},"renounceRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"renounceRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been revoked `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`."},"revokeRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"revokeRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role."},"supportsInterface(bytes4)":{inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"See {IERC165-supportsInterface}."},"updateStorageVar(address)":{inputs:[{internalType:"address",name:"newTreasuryVal",type:"address"}],name:"updateStorageVar",outputs:[],stateMutability:"nonpayable",type:"function"},"upgradeTo(address)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"}],name:"upgradeTo",outputs:[],stateMutability:"nonpayable",type:"function",details:"Upgrade the implementation of the proxy to `newImplementation`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."},"upgradeToAndCall(address,bytes)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"},{internalType:"bytes",name:"data",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable",type:"function",details:"Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call encoded in `data`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."}}},"contracts/testing/upgrades/Treasury/TreasuryExtraFunctionality.sol:TreasuryExtraFunctionality":{source:"contracts/testing/upgrades/Treasury/TreasuryExtraFunctionality.sol",name:"TreasuryExtraFunctionality",events:{"AdminChanged(address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"previousAdmin",type:"address"},{indexed:!1,internalType:"address",name:"newAdmin",type:"address"}],name:"AdminChanged",type:"event"},"BeaconUpgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"beacon",type:"address"}],name:"BeaconUpgraded",type:"event"},"RoleAdminChanged(bytes32,bytes32,bytes32)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"previousAdminRole",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"newAdminRole",type:"bytes32"}],name:"RoleAdminChanged",type:"event"},"RoleGranted(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleGranted",type:"event"},"RoleRevoked(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleRevoked",type:"event"},"TokenAdded(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"token",type:"address"},{indexed:!0,internalType:"address",name:"addedBy",type:"address"},{indexed:!1,internalType:"uint256",name:"timestamp",type:"uint256"}],name:"TokenAdded",type:"event"},"TokenRemoved(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"token",type:"address"},{indexed:!0,internalType:"address",name:"addedBy",type:"address"},{indexed:!1,internalType:"uint256",name:"timestamp",type:"uint256"}],name:"TokenRemoved",type:"event"},"Upgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"implementation",type:"address"}],name:"Upgraded",type:"event"}},methods:{"DEFAULT_ADMIN_ROLE()":{inputs:[],name:"DEFAULT_ADMIN_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"PAUSE_ROLE()":{inputs:[],name:"PAUSE_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"TREASURY_MANAGER_ROLE()":{inputs:[],name:"TREASURY_MANAGER_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"addSupportedToken(address)":{inputs:[{internalType:"address",name:"_token",type:"address"}],name:"addSupportedToken",outputs:[],stateMutability:"nonpayable",type:"function",params:{_token:"stream ERC20 token address"},notice:"adds token as a supproted rewards token by Treasury supported tokens means any future stream token should be whitelisted here"},"adminDelegatecall(address,bytes)":{inputs:[{internalType:"address",name:"target",type:"address"},{internalType:"bytes",name:"data",type:"bytes"}],name:"adminDelegatecall",outputs:[{internalType:"bytes",name:"",type:"bytes"}],stateMutability:"payable",type:"function","custom:oz-upgrades-unsafe-allow":"delegatecall",details:"adminDelegatecall allows this contract to delegate calls to a target contract and execute it in the context of this contract. Only default admin role can call this function.",params:{data:"is the ABI encoded function signature and its values.",target:"the target contract address"}},"adminPause(uint256)":{inputs:[{internalType:"uint256",name:"flags",type:"uint256"}],name:"adminPause",outputs:[],stateMutability:"nonpayable",type:"function",details:"adminPause pauses this contract. Only pause role or default admin role can access this function.",params:{flags:"flags variable is used for pausing this contract."}},"adminSstore(uint256,uint256)":{inputs:[{internalType:"uint256",name:"key",type:"uint256"},{internalType:"uint256",name:"value",type:"uint256"}],name:"adminSstore",outputs:[],stateMutability:"nonpayable",type:"function",details:"adminSstore updates the state variable value. only default admin role can call this function.",params:{key:"is the storage slot of the state variable",value:"is the state variable value"}},"adminSstoreWithMask(uint256,uint256,uint256)":{inputs:[{internalType:"uint256",name:"key",type:"uint256"},{internalType:"uint256",name:"value",type:"uint256"},{internalType:"uint256",name:"mask",type:"uint256"}],name:"adminSstoreWithMask",outputs:[],stateMutability:"nonpayable",type:"function",details:"adminSstoreWithMask similar to adminSstore except it updates the state variable value after xor-ing this value with the old value and the mask, so the new value should be a result of xor(and(xor(value, oldval), mask), oldval). Only default admin role can call this function.",params:{key:"is the storage slot of the state variable",mask:"this value is used in calculating the new value",value:"is the state variable value"}},"c_0x47b6ea16(bytes32)":{inputs:[{internalType:"bytes32",name:"c__0x47b6ea16",type:"bytes32"}],name:"c_0x47b6ea16",outputs:[],stateMutability:"pure",type:"function"},"c_0x7e37e874(bytes32)":{inputs:[{internalType:"bytes32",name:"c__0x7e37e874",type:"bytes32"}],name:"c_0x7e37e874",outputs:[],stateMutability:"pure",type:"function"},"c_0xfd316145(bytes32)":{inputs:[{internalType:"bytes32",name:"c__0xfd316145",type:"bytes32"}],name:"c_0xfd316145",outputs:[],stateMutability:"pure",type:"function"},"dummy()":{inputs:[],name:"dummy",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"getRoleAdmin(bytes32)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"}],name:"getRoleAdmin",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}."},"grantRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"grantRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role."},"hasRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"hasRole",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns `true` if `account` has been granted `role`."},"initialize(address[],uint256)":{inputs:[{internalType:"address[]",name:"_supportedTokens",type:"address[]"},{internalType:"uint256",name:"_flags",type:"uint256"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function",params:{_supportedTokens:"list of supported tokens"},notice:"initializes ownable Treasury with list of managers and supported tokens"},"isSupportedToken(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"isSupportedToken",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"paused()":{inputs:[],name:"paused",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"payRewards(address,address,uint256)":{inputs:[{internalType:"address",name:"_user",type:"address"},{internalType:"address",name:"_token",type:"address"},{internalType:"uint256",name:"_amount",type:"uint256"}],name:"payRewards",outputs:[],stateMutability:"nonpayable",type:"function",details:"Used by jet staking contracts",params:{_amount:"token to transfer to user",_token:"token to transfer to user",_user:"user to transfer tokens to"},notice:"transfers token amount from Treasury balance to user."},"removeSupportedToken(address)":{inputs:[{internalType:"address",name:"_token",type:"address"}],name:"removeSupportedToken",outputs:[],stateMutability:"nonpayable",type:"function",params:{_token:"stream ERC20 token address"},notice:"removed token as a supproted rewards token by Treasury"},"renounceRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"renounceRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been revoked `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`."},"revokeRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"revokeRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role."},"supportsInterface(bytes4)":{inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"See {IERC165-supportsInterface}."},"upgradeTo(address)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"}],name:"upgradeTo",outputs:[],stateMutability:"nonpayable",type:"function",details:"Upgrade the implementation of the proxy to `newImplementation`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."},"upgradeToAndCall(address,bytes)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"},{internalType:"bytes",name:"data",type:"bytes"}],name:"upgradeToAndCall",outputs:[],stateMutability:"payable",type:"function",details:"Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call encoded in `data`. Calls {_authorizeUpgrade}. Emits an {Upgraded} event."}}}};new hu({el:"#app",router:new id({routes:[{path:"/",component:Ud,props:()=>({json:Ed})},{path:"*",component:Sd,props:e=>({json:Ed[e.path.slice(1)]})}]}),mounted(){document.dispatchEvent(new Event("render-event"))},render:e=>e(dd)})})()})();